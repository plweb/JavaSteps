% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[a4paper,12pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage[cm-default]{fontspec}
\usepackage{xunicode}
\usepackage{xcolor}
\usepackage{fontspec}
\usepackage{titlesec}
\usepackage{fancyvrb,relsize}
\usepackage[slantfont,boldfont]{xeCJK}
\XeTeXlinebreaklocale "zh"
\XeTeXlinebreakskip = 0pt plus 1pt
\setmainfont[BoldFont=Apple LiGothic Medium]{Apple LiSung Light}
\setCJKmainfont[BoldFont=Apple LiGothic Medium]{Apple LiSung Light}
\setromanfont[BoldFont=Apple LiGothic Medium]{Apple LiSung Light}
\setmonofont{Monaco}
\renewcommand{\baselinestretch}{1.25}
\DefineVerbatimEnvironment{Verbatim}{Verbatim}{numbers=left, fontsize=\relsize{-1}}


\title{程式碼實作學習\\Java Steps: Learning Java Step by Step}
\date{September 30, 2011}
\release{1.0}
\author{董少桓、林彥宏}
\newcommand{\sphinxlogo}{\includegraphics{logo.eps}\par}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\def\PYG@tok@gd{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\def\PYG@tok@gu{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\def\PYG@tok@gt{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.25,0.82}{##1}}}
\def\PYG@tok@gs{\let\PYG@bf=\textbf}
\def\PYG@tok@gr{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\def\PYG@tok@cm{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@vg{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@m{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mh{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@cs{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\colorbox[rgb]{1.00,0.94,0.94}{##1}}}
\def\PYG@tok@ge{\let\PYG@it=\textit}
\def\PYG@tok@vc{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@il{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@go{\def\PYG@tc##1{\textcolor[rgb]{0.19,0.19,0.19}{##1}}}
\def\PYG@tok@cp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@gi{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\def\PYG@tok@gh{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\def\PYG@tok@ni{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\def\PYG@tok@nl{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\def\PYG@tok@nn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@no{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\def\PYG@tok@na{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@nb{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@nd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\def\PYG@tok@ne{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nf{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\def\PYG@tok@si{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\def\PYG@tok@s2{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@vi{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@nt{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\def\PYG@tok@nv{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@s1{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@gp{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@sh{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@ow{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@sx{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@bp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c1{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@kc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@mf{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@err{\def\PYG@bc##1{\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{##1}}}
\def\PYG@tok@kd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@ss{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\def\PYG@tok@sr{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\def\PYG@tok@mo{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mi{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@kn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@o{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\def\PYG@tok@kr{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@s{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@kp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@w{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\def\PYG@tok@kt{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\def\PYG@tok@sc{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sb{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@k{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@se{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sd{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}



\chapter{簡介}
\label{java_intro::doc}\label{java_intro:java-steps}\label{java_intro:id1}

\section{Java 程式語言的特色}
\label{java_intro:java}
Java 程式語言起源於 1991 年，
Green Team 軟體開發團隊用它來開發 Star 7 機器上的應用程式，
當時設計此語言的 James Gosling 因為看見窗外的「橡樹（oak）」，
決定將新語言命名為 Oak 。
但是由於工程師們喜歡邊喝咖啡邊討論，
隨後又將名稱改為 Java（一種咖啡的名稱），
這個名稱就一直沿用到現在。

Java 原本是為了控制冰箱、冷氣、微波爐等家電用品而設計的程式語言。
由於家電用品相當多樣，因此 Java 選用了一個與傳統的程式語言不一樣的執行模式：
\begin{itemize}
\item {} 
傳統的程式語言在編譯後會產生 machince code（機器碼），
然後直接在硬體上執行；

\item {} 
Java 在編譯後則會產生 Byte Code 並間接的在 Java Virtual Machine（JVM）上執行。
這個 JVM（Java虛擬機器）其實是一個軟體，其功用是解譯並執行 Byte Code，而 JVM 仍然是在硬體上執行。

\end{itemize}

因為 JVM 是軟體，所以 Java 也有跨平台的特性：
只要為不同的處理器或作業系統設計其專屬的 JVM，
Java 的程式便可以不需改寫的在這些處理器或作業系統上執行。
這便是「Write once, runs everywhere或一次編譯、到處執行」的由來。

Java 也支援物件導向程式設計（Object-Oriented Programming），
所謂「物件」，簡單的說有「屬性」也有「方法」，
例如冷氣機的「屬性」可以包括：「開關」及「溫度」；
而「方法」則可以包括：「開機」、「關機」及「設定溫度」等。
為了讓程式設計師，可以比較容易的使用物件撰寫模擬、控制與
應用電腦本身（如滑鼠與鍵盤等也是物件）和我們生活周遭的物件的程式，
因此便有研究人員發明了支援物件導向程式設計的語言。

Java 的設計搭上了全球資訊網的順風車，
原因是 Java 的設計團隊可以寫一個能夠在瀏覽器中執行的 JVM，
而讓 Java 的程式可以透過網路下載至瀏覽器中執行。
這個「網路」＋「物件導向」的特性讓 Java 瞬間爆紅。

除了跨平台、物件導向、可透過網路動態的載入及執行程式等功能之外，
Java 還支援多執行緒、例外狀態處理與自動記憶體回收的功能：
\begin{itemize}
\item {} 
多執行緒讓一個程式可以執行數個工作；

\item {} 
例外狀態處理讓處理例外的程式碼也能夠物件化；

\item {} 
自動記憶體回收則讓程式設計師免除了使用低階的指標（pointers）來設計資料結構及管理記憶體的負擔。
這個特色成了 C 語言程式設計師的福音，因為它可以為程式設計師減少許多不容易 debug 的錯誤。

\end{itemize}


\section{安裝JDK}
\label{java_intro:jdk}
在編譯與執行 Java 程式前，你的電腦必須先安裝 JDK（Java Development Kit）：
\begin{itemize}
\item {} 
可以從這裡下載新版的JDK \href{http://java.sun.com/javase/downloads/index.jsp}{http://java.sun.com/javase/downloads/index.jsp}

\end{itemize}

在安裝完成後，也需要完成 path 及 classpath 的設定：

\begin{Verbatim}[commandchars=@\[\]]
path=C:\Program Files\Java\jdk1.6.0\bin;....
classpath=.;C:\Program Files\Java\jdk1.6.0\lib;....
\end{Verbatim}

請注意：以上路徑中的 jdk1.6.0 會因版本的不同而異。
此外，在設定 classpath 時要特別注意在 ＝ 號的右邊要輸入這個 \textbf{「.」} 。
這個點的意義是目前的目錄（current directory），也是執行 Java 程式時用來搜尋執行檔的目錄。


\section{編譯及執行Java程式}
\label{java_intro:id2}
有兩種方式可以編譯及執行一個 Java 程式。
第一種是使用程式開發環境（program development environment），
例如： \href{http://eclipse.org/}{Eclipse} ；
另一種則是使用一般的程式編輯器。
以下是使用「記事本」寫 Java 程式時所需要進行的三個步驟：
\begin{enumerate}
\item {} 
使用「記事本」輸入以下的程式並將檔案命名為 EnglishExam.java
（注意：附檔名必須是 .java 而不是 .txt，
\textbf{而這個檔案的主檔名必須與 public class 後面的 EnglishExam 相同} ）：

\end{enumerate}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{EnglishExam} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{argv}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"Your score is 97."}\PYG{o}{)}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
執行「命令提示字元」並將目錄切換至儲存 EnglishExam.java 的目錄，然後執行：

\begin{Verbatim}[commandchars=@\[\]]
javac EnglishExam.java
\end{Verbatim}

執行這個 javac 指令就是執行 Java 的編譯器（compiler），
其結果是在同樣的目錄產生一個 EnglishExam.class 的 byte code 檔。

\item {} 
上面的步驟如果有編譯錯誤則繼續修改程式。如果沒有編譯錯誤則可以執行：

\begin{Verbatim}[commandchars=@\[\]]
java EnglishExam
\end{Verbatim}

執行後 Your score is 97。便會顯示在螢幕上。

\end{enumerate}

在開發 Java 程式的過程中，有可能發生編譯錯誤（compile-time error）。
這時便需要再次的使用編輯器修改錯誤，直到沒有任何的編譯錯誤為止。
編譯完畢之後，在程式執行時也有可能發生 run-time error。
同樣的，這時也需要使用編輯器修改、編譯、執行、除錯，直到沒有錯誤為止。

一般的 Java 程式都是由一或多個類別（class）所組成，
\textbf{其中的一個類別至少要有一個命名為 public static void main 的方法（method），
而這個程式就是由 main 開始執行} 。
（透過網路瀏覽器執行的 Java applet 不適用此規則。）

上例中的 public class EnglishExam 是指定 EnglishExam 這個類別是 public 是公用的，
也就是可以被程式中其他的類別引用。而 public static void main(String argv{[}{]}) 的意義是：
\begin{enumerate}
\item {} 
public：指定 main 為一個可以被其他類別使用的 public method；

\item {} 
static：指定 main 為一個類別方法（static method），一個類別方法隸屬於一個 class；

\item {} 
void：代表 main 執行完畢後回傳的型態，因為 main 沒有回傳任何數值，因此它的回傳型態是 void；

\item {} 
String argv{[}{]}：指這個方法的輸入參數是 argv{[}{]} 而 String 則是它的型態。
main 的輸入參數 String argv{[}{]} 可以在執行一個 Java 程式時將字串（String）資料輸入這個程式。
例如在編譯以下的程式之後：

\end{enumerate}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{HelloJava} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{argv}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"Hello "} \PYG{o}{+} \PYG{n}{argv}\PYG{o}{[}\PYG{l+m+mi}{0}\PYG{o}{]} \PYG{o}{+} \PYG{n}{argv}\PYG{o}{[}\PYG{l+m+mi}{1}\PYG{o}{]}\PYG{o}{)}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

以「命令提示字元」執行：

\begin{Verbatim}[commandchars=@\[\]]
java HelloJava Basic C++
\end{Verbatim}

便會呼叫 System.out.println 並輸出：

\begin{Verbatim}[commandchars=@\[\]]
Hello Basic C++
\end{Verbatim}

這個程式的 argv{[}{]} 代表 argv 這個變數是一個陣列，
而 argv{[}0{]}、argv{[}1{]} 則取用 argv 內第0、1個儲存格的內容。

Java 程式中 \textbf{用大刮號 \{ \} 標示的 Block（區塊）} 是用來組織程式層次關係的語法。

例如上例的程式就有兩個區塊，一組用來標示 class 的區塊，
另一組則用來標示 main 的區域。區塊中可以包含其他的區塊，
在撰寫程式時也應注意要把區塊的內容往右縮排。
一組用來標示類別的區塊內，可以有數個變數與方法。
而一組用來標示方法的區塊內可以有一或多句以「；」結束的程式碼。這些程式碼共同構成了這個方法的 body。

為 Java 程式中使用的名字命名，有一個不成文的規定：
\textbf{類別名稱的第一個字母要用大寫} 。
\textbf{方法或變數的第一個字母則是小寫} ，
若有數個字合併時則 \textbf{後續的字的第一個字母也習慣用大寫} 。

\href{http://v2.plweb.org/webstart.groovy?mode=student\&course\_id=158\&lesson\_id=2\&class\_id=2011100006}{動手練習：修正程式碼的錯誤}


\chapter{Java 的變數、方法與型態}
\label{java_basis:java}\label{java_basis::doc}
一個電腦程式基本上是由兩部分組成：
\begin{enumerate}
\item {} 
資料：這部分的程式碼要為所處理的資料命名、指定其型態、並存放於記憶體中；

\item {} 
處理：這部分的程式碼要使用撰寫在方法（method）中的運算式、條件判斷式、迴圈，來存取資料、計算結果、然後輸出。

\end{enumerate}

這兩部分的內容（程式碼），不但是機器要知道如何執行，更要讓人（程式設計師）容易寫，也容易讀。
而讓程式碼易寫、易讀的最基本的方法，就像收拾家中的衣櫃一般：按照種類與性質，分別放置整齊。

Java語言整理程式碼的最基本的單元稱做「類別」。一個類別可以有儲存資料的「變數」與負責處理資料的「方法」。

「類別」可以提供兩種整理程式碼的方式：一種是以程式的邏輯結構當作分類的方式（俗稱的結構化程式設計）；
另一種則是以物件的種類來歸類。而有的時候，一個類別也可以同時提供這兩種方式。

以程式的邏輯結構（例如將迴圈的邏輯放入一個方法中，或將一個判斷分數高低的邏輯放入一個方法中）來分類時，
所使用到的變數稱為類別變數或static field，而所用到的方法稱為類別方法或static method。稱做static（靜態）的原因是，這類的變數與方法是在程式開始執行時便在記憶體中產生了，而且它們的壽命一直到程式結束時才結束。

以物件來歸類的話，則是將類別內的程式碼，看成是產生這種類別的物件的「規格」。
由於只是規格，所以只有在使用這個類別製造物件時，所對應的記憶體才會產生。
而這種在程式執行時「動態」產生的物件實例中的變數與方法，
稱為實例變數（instance variable），與實例方法（instance method）。

類別方法或實例方法，也需要自己有儲存資料的地方，而在類別方法或實例方法中儲存資料的變數，
都叫區域變數（local variable），意思是在一個方法所屬的區域內才可以使用的變數。

Java如何分區呢？主要是使用大刮號，例如：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZob{}}
        \PYG{o}{\PYGZob{}}
                \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
        \PYG{o}{\PYGZcb{}}
        \PYG{o}{\PYGZob{}}
                \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
        \PYG{o}{\PYGZcb{}}
        \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

程式語言的句子與一般說話的語言一樣是由基本的字詞（names）組合而成。
Java 為這些字詞命名的規定是一個字詞可以包含一個或多個英文字母、數字、\_ 及 \$ 所組成的字元，而第一個字元不可以是數字。

Java 語言有 public, class, void, if, while, for 等
\href{http://download-llnw.oracle.com/javase/tutorial/java/nutsandbolts/\_keywords.html}{保留字} 。
除了開始認識這些保留字的意義與用法之外，程式設計師所要學習的第一件事，
就是為儲存資料的 \textbf{變數} 與執行處理的 \textbf{方法} 命名。

\textbf{變數（variable）} 是程式中的一種字詞。
一個變數有一個 \textbf{名字（name）} 、一個 \textbf{資料值（value）} 、
一塊儲存資料值的 \textbf{記憶體} 以及這個資料值的 \textbf{型態（type）} （如 int、double 等）。
由於一個變數的型態，定義了這個變數的值所需要的記憶體的大小，
所以一個 Java 程式在編譯時，就可以知道如何為這些變數，在執行時，
配置適當大小的記憶體空間，以存放這些變數的值。

整的來說，Java 有三種變數：
\begin{enumerate}
\item {} 
\textbf{區域變數（local variable）} ：宣告在方法內或參數部分的變數；

\item {} 
\textbf{類別變數（class variable or static field）} ：在一個類別中以 static 宣告的變數；

\item {} 
\textbf{實例變數（instance variable or non-static field）} ：在一個類別中沒有使用 static 宣告的變數。

\end{enumerate}

Java 也有兩種方法：
\begin{enumerate}
\item {} 
\textbf{類別方法（class method or static method）} ：
這種方法以 static 宣告。呼叫的方式是 C.m(...)，其中 C 是類別名稱，m 是方法名稱，...則是0至多個傳入的參數。

\item {} 
\textbf{實例方法（instance method or non-static method）} ：
這種方法不以 static 宣告，隸屬於一個類別所產生的實例。呼叫的方式是 o.m(...)，
其中 o 是這個類別或其子類別的實例，而 m 是其方法名稱，...則是0至多個傳入的參數。

\end{enumerate}

Java 之所以有種類這麼多的變數與方法，
是因為 Java 同時支援結構化（例如：C 與 Basic）與物件導向兩種普遍使用的程式設計方式。
撰寫結構化程式時需要使用類別變數與類別方法。類別變數在概念上與結構化程式語言的全域變數（global variable）一致；
而類別方法在概念上則與結構化程式語言的函式（function）或程序（procedure）一致。
實例變數、實例方法，則屬物件導向程式設計的功能。一般的 Java 程式可以同時使用結構化與物件導向並存的方式設計程式。

這份講義介紹 Java 結構化程式設計的語法及語意，
另一份講義《Java 物件導向程式設計》則介紹 Java 物件導向程式設計的功能。

此外，Java 變數的型態也有兩大類：
\begin{enumerate}
\item {} 
\textbf{primitive type} ，包括： \href{http://download-llnw.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html}{int、double、boolean、char} 等。

\item {} \begin{description}
\item[{\textbf{reference type} ，包括：}] \leavevmode\begin{enumerate}
\item {} 
類別型態：經由類別（class）的宣告而得到。如果 Car 是一個類別，而 aCar 是一個這個類別的變數，則 Car 便是 aCar 的型態（type）。之所以稱為 reference type，是因為 aCar 這個變數在記憶體中的位置，實際上是存著指向（reference）一個 Car 實例的地址。

\item {} 
介面型態：經由介面（interface）的宣告而得到。

\item {} 
陣列（array）型態。

\item {} 
enum 型態：一種特別的類別宣告方式，用於宣告月份、一週的七天等。

\end{enumerate}

\end{description}

\end{enumerate}


\chapter{區域變數與基本資料型態}
\label{java_vartype::doc}\label{java_vartype:id1}
區域變數是一個方法的參數或是宣告在一個方法的區塊中。
以下是宣告區域變數的幾個範例，其中 int 代表整數，而 double 代表倍精準浮點數，
宣告的意義是告訴編譯器一個變數的型態是什麼：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{EnglishExam} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{argv}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{c+c1}{// argv 是傳入參數，同時也是一種區域變數}

                \PYG{c+c1}{// 宣告三個區域變數}
                \PYG{k+kt}{int} \PYG{n}{vocabulary}\PYG{o}{;}
                \PYG{k+kt}{int} \PYG{n}{grammar}\PYG{o}{;}
                \PYG{k+kt}{int} \PYG{n}{listening}\PYG{o}{;}
                \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

多個變數的宣告，可以合併在一行：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{EnglishExam} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{argv}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{c+c1}{// 將以上三個區域變數，合併在一行}
                \PYG{k+kt}{int} \PYG{n}{vocabulary}\PYG{o}{,} \PYG{n}{grammar}\PYG{o}{,} \PYG{n}{listening}\PYG{o}{;}
                \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

宣告變數時，也可以同時指定數值：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{EnglishExam} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{argv}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{c+c1}{// 在宣告時也將數值存入這三個區域變數中}
                \PYG{k+kt}{int} \PYG{n}{vocabulary} \PYG{o}{=} \PYG{l+m+mi}{24}\PYG{o}{;}
                \PYG{k+kt}{int} \PYG{n}{grammar} \PYG{o}{=} \PYG{l+m+mi}{26}\PYG{o}{;}
                \PYG{k+kt}{int} \PYG{n}{listening} \PYG{o}{=} \PYG{l+m+mi}{33}\PYG{o}{;}
                \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{EnglishExam} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{argv}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{c+c1}{// 也可以這樣寫：}
                \PYG{k+kt}{double} \PYG{n}{vocabulary} \PYG{o}{=} \PYG{l+m+mf}{22.5}\PYG{o}{,} \PYG{n}{grammar} \PYG{o}{=} \PYG{l+m+mf}{25.4}\PYG{o}{,} \PYG{n}{listening} \PYG{o}{=} \PYG{l+m+mf}{32.0}\PYG{o}{;}
                \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

有了變數之後，可以使用設值運算符號（=），將數值存入區域變數中，
如果一個區域變數尚未被存入數值，則其預設值（default value）會被存入，而數字的預設值是 0。例如：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{EnglishExam} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{argv}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{k+kt}{int} \PYG{n}{vocabulary}\PYG{o}{,} \PYG{n}{grammar}\PYG{o}{,} \PYG{n}{listening}\PYG{o}{;}
                \PYG{k+kt}{int} \PYG{n}{score}\PYG{o}{;}

                \PYG{n}{vocabulary} \PYG{o}{=} \PYG{l+m+mi}{22}\PYG{o}{;}
                \PYG{n}{grammar} \PYG{o}{=} \PYG{l+m+mi}{26}\PYG{o}{;}
                \PYG{n}{score} \PYG{o}{=} \PYG{n}{vocabulary} \PYG{o}{+} \PYG{n}{grammar} \PYG{o}{+} \PYG{n}{listening}\PYG{o}{;}

                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{print}\PYG{o}{(}\PYG{l+s}{"The score of the exam is "}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{score}\PYG{o}{)}\PYG{o}{;}
                \PYG{c+c1}{// listening 的預設值是0, 所以印出 48}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

以上程式碼執行的結果為：

\begin{Verbatim}[commandchars=@\[\]]
The score of the exam is 48
\end{Verbatim}

Java的註解是以 \textbf{//} 或 \textbf{/* */} 表示，例如：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// 這是註解}
\PYG{c+cm}{/*}
\PYG{c+cm}{   這也是註解}
\PYG{c+cm}{   這還是註解}
\PYG{c+cm}{*/}
\end{Verbatim}


\chapter{螢幕輸出及鍵盤輸入}
\label{java_stdio::doc}\label{java_stdio:id1}
螢幕輸出有幾種方式。
第一種是前面章節已經使用過的 System.out.print 及 System.out.println。
這兩種方法的的差別是前者沒有換行，而後者有換行。
如果有數個資料需要一起印出時，則可以使用 + 進行串接。例如：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Show} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{argv}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{k+kt}{int} \PYG{n}{design}\PYG{o}{,} \PYG{n}{acting}\PYG{o}{;}

                \PYG{n}{design} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{o}{;}
                \PYG{n}{acting} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(} \PYG{l+s}{"Design is "} \PYG{o}{+} \PYG{n}{design} \PYG{o}{+} \PYG{l+s}{"and acting is "} \PYG{o}{+} \PYG{n}{acting} \PYG{o}{)}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

第二種方式是在 J2SDK5 之後才支援 \footnote{
System.out.printf(), \href{http://www.java2s.com/Code/JavaAPI/java.lang/System.out.printf.htm}{http://www.java2s.com/Code/JavaAPI/java.lang/System.out.printf.htm}
} 。
這個方式與 C 語言的 printf 功能類似。例如：

\begin{Verbatim}[commandchars=@\[\]]
System.out.printf("Today is @%s, @%d.\n", "January", 18);
// @%s 的位置替換成 January 這個 String
// @%d 的位置替換成 18 這個整數
// \n 表示換行符號
\end{Verbatim}

顯示：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Today} \PYG{o+ow}{is} \PYG{n}{January}\PYG{p}{,} \PYG{l+m+mi}{18}
\end{Verbatim}

例如：

\begin{Verbatim}[commandchars=@\[\]]
double score = 92.345
System.out.printf("My score is @%.2f.\n", score);
// @%.2f 的意義是小數點以下取兩位，並四捨五入。
System.out.printf("My score is @%6.2f.@%n", score);
// @%6.2f 的意義是：包括小數點共6位，小數點以下取兩位，
// 並四捨五入。所以9的左邊多空一格。
\end{Verbatim}

顯示：

\begin{Verbatim}[commandchars=@\[\]]
My score is 92.35.
My score is  92.35.
\end{Verbatim}

鍵盤輸入則可以透過 \footnote{
java.util.Scanner, \href{http://www.java2s.com/Code/JavaAPI/java.util/Scanner.htm}{http://www.java2s.com/Code/JavaAPI/java.util/Scanner.htm}
} 。例如：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// 使用時先載入 Scanner 所屬的 package}
\PYG{k+kn}{import} \PYG{n+nn}{java.util.*}\PYG{o}{;}  \PYG{c+c1}{// * 的意義是 java.util 內所有的類別}

\PYG{c+c1}{// 定義物件：}
\PYG{n}{Scanner} \PYG{n}{scanner} \PYG{o}{=} \PYG{k}{new} \PYG{n}{Scanner}\PYG{o}{(}\PYG{n}{System}\PYG{o}{.}\PYG{n+na}{in}\PYG{o}{)}\PYG{o}{;}

\PYG{c+c1}{// 輸入字串：}
\PYG{n}{String} \PYG{n}{name} \PYG{o}{=} \PYG{n}{scanner}\PYG{o}{.}\PYG{n+na}{nextLine}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}

\PYG{c+c1}{// 輸入整數：}
\PYG{k+kt}{int} \PYG{n}{score} \PYG{o}{=} \PYG{n}{scanner}\PYG{o}{.}\PYG{n+na}{nextInt}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}

\PYG{c+c1}{// 輸入double}
\PYG{k+kt}{double} \PYG{n}{height} \PYG{o}{=} \PYG{n}{scanner}\PYG{o}{.}\PYG{n+na}{nextDouble}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}

\PYG{c+c1}{// 輸入float}
\PYG{k+kt}{float} \PYG{n}{weight} \PYG{o}{=} \PYG{n}{scanner}\PYG{o}{.}\PYG{n+na}{nextFloat}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
\end{Verbatim}

以下是一個完整的範例：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{java.util.*}\PYG{o}{;}

\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{EnglishExam} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{argv}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{k+kt}{int} \PYG{n}{vocab}\PYG{o}{,} \PYG{n}{grammar}\PYG{o}{,} \PYG{n}{listen}\PYG{o}{,} \PYG{n}{score}\PYG{o}{;}

                \PYG{n}{Scanner} \PYG{n}{scanner} \PYG{o}{=} \PYG{k}{new} \PYG{n}{Scanner}\PYG{o}{(}\PYG{n}{System}\PYG{o}{.}\PYG{n+na}{in}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{String} \PYG{n}{name} \PYG{o}{=} \PYG{n}{scanner}\PYG{o}{.}\PYG{n+na}{nextLine}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{vocab} \PYG{o}{=} \PYG{n}{scanner}\PYG{o}{.}\PYG{n+na}{nextInt}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{grammar} \PYG{o}{=} \PYG{n}{scanner}\PYG{o}{.}\PYG{n+na}{nextInt}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{listen} \PYG{o}{=} \PYG{n}{scanner}\PYG{o}{.}\PYG{n+na}{nextInt}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{score} \PYG{o}{=} \PYG{n}{vocab} \PYG{o}{+} \PYG{n}{grammar} \PYG{o}{+} \PYG{n}{listen}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{printf}\PYG{o}{(}\PYG{l+s}{"The total score of \PYGZpc{}s is \PYGZpc{}d.\PYGZpc{}n"}\PYG{o}{,} \PYG{n}{name}\PYG{o}{,} \PYG{n}{score}\PYG{o}{)}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}


\chapter{算術運算式}
\label{java_expr::doc}\label{java_expr:id1}
使用算術運算式要注意的是運算的優先次序。
例如：先乘除、後加減。如果不記得運算的優先次序，那麼最簡便的方法是使用（）也就是指定內層的刮號先執行。
以下是算術運算式的幾個範例：

使用算術運算式另一項要注意的是型態的轉換，也就是在一個算術式中同時有整數與浮點數時，
Java 會將整數先轉換成浮點數然後再進行運算。

例如：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{o}{(}\PYG{l+m+mi}{3} \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{o}{)} \PYG{o}{/}  \PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{o}{*}  \PYG{c+c1}{// 兩個整數相除，結果仍是整數，小數部分捨棄。傳回 2}
\PYG{k+kt}{double} \PYG{n}{f}\PYG{o}{;}
\PYG{n}{f} \PYG{o}{=} \PYG{o}{(}\PYG{l+m+mi}{3} \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{o}{)} \PYG{o}{/}  \PYG{o}{*}\PYG{o}{*}\PYG{l+m+mf}{3.0}\PYG{o}{*}\PYG{o}{*}    \PYG{c+c1}{// 7 轉型成浮點數，然後與浮點數 3.0 相除。傳回 2.333...}
\PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{i}\PYG{o}{)}\PYG{o}{;}
\PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{f}\PYG{o}{)}\PYG{o}{;}
\end{Verbatim}

印出：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{2}
\PYG{l+m+mf}{2.3333333333333335}
\end{Verbatim}

如果需要指定轉換的型態，則可以使用以下的方式：

至於 i、f 的原來的值還是不變。

如同一般的算術運算式，設值運算式（=）也會傳回值。例如：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{3}         \PYG{c+c1}{// 傳回 3}
\PYG{n}{y} \PYG{o}{=} \PYG{o}{(}\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{o}{)}   \PYG{c+c1}{// 因為 x = 3 傳回3, 所以 y 的值也設成 3}
\end{Verbatim}

自動將資料範圍較小的型態轉為資料範圍較大的型態，稱為自動轉型 (promotion)。
Java 資料型態範圍之大小次序為：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{byte} \PYG{o}{\textless{}} \PYG{n}{short} \PYG{o}{\textless{}} \PYG{n+nb}{int} \PYG{o}{\textless{}} \PYG{n+nb}{long} \PYG{o}{\textless{}} \PYG{n+nb}{float} \PYG{o}{\textless{}} \PYG{n}{double}
\end{Verbatim}

以下的例子會出現 possible loss of precision 的錯誤：

這個錯誤是因為a會自動轉型成較大的 long 再跟 b 相加，
但是 int 型態的 c 放不下 long 的資料。
此時就要透過強制轉型(casting)，將 a 轉型成 int：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n}{c} \PYG{o}{=} \PYG{o}{(}\PYG{k+kt}{int}\PYG{o}{)}\PYG{o}{(}\PYG{n}{a} \PYG{o}{+} \PYG{n}{b}\PYG{o}{)}\PYG{o}{;}
\end{Verbatim}

當資料型態由小轉為大時，會自動轉型；
當資料型態由大轉為小時，則需強迫轉型。


\chapter{類別變數與類別方法}
\label{java_static::doc}\label{java_static:id1}
非物件導向程式語言（例如：C），程式設計師主要是使用函式（function、
全域變數與區域變數將一個大的程式分割成幾個小的部份，以簡化程式的撰寫。
這些觀念在 Java 中仍然可以使用，而使用的方式是透過類別變數與類別方法。

舉例而言，如果要為英文檢定考試寫一個計算成績的程式，
那麼這個程式應該有一個計算成績的方法。例如：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{EnglishExam} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{int} \PYG{n+nf}{englishScore}\PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{v}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{g}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{l}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{k}{return} \PYG{n}{v} \PYG{o}{+} \PYG{n}{g} \PYG{o}{+} \PYG{n}{l}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{argv}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{print}\PYG{o}{(}\PYG{l+s}{"The score of the exam is "}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{englishScore}\PYG{o}{(}\PYG{l+m+mi}{24}\PYG{o}{,} \PYG{l+m+mi}{27}\PYG{o}{,} \PYG{l+m+mi}{32}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

執行結果：

\begin{Verbatim}[commandchars=@\[\]]
The score of the exam is 83
\end{Verbatim}

public static int englishScore(int v, int g, int l) 定義了 englishScore 這個類別方法，
這個方法有三個命名為 v, g, l 的輸入參數，它們的型態都是 int。
這個方法的輸出型態也是 int，也就是會使用 return 傳出一個 int 的值 (v + g + l)。
Java 使用 static 這個保留字來定義類別方法。因為這種方法是靜態的，
也就是在程式執行時，呼叫這個方法的程式碼，一定都會執行相同的方法。

在 main 中的 System.out.println(englishScore(24, 27, 32))
將 24, 27, 32 傳入 englishScore 中，並依序成為 v, g, l 三個輸入參數的值，
而這三個數相加的結果 83 會繼續的傳入 System.out.println，然後顯示在螢幕上。
一個方法的輸入參數也是那個方法的區域變數。所以 v, g, l 三個輸入參數也是 englishScore 的區域變數。

除了直接將數值傳入方法中以外，還可以將變數或其他也有傳回值的式子，寫在方法呼叫中傳入的位置。例如：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{EnglishExam} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{int} \PYG{n+nf}{englishScore}\PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{v}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{g}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{l}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{k}{return} \PYG{n}{v} \PYG{o}{+} \PYG{n}{g} \PYG{o}{+} \PYG{n}{l}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{argv}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{k+kt}{int} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{o}{,} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{print}\PYG{o}{(}\PYG{l+s}{"The score of the exam is "}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{englishScore}\PYG{o}{(} \PYG{o}{*}\PYG{o}{*}\PYG{n}{a}\PYG{o}{,} \PYG{n}{b}\PYG{o}{,} \PYG{n}{a} \PYG{o}{+} \PYG{n}{b}\PYG{o}{*}\PYG{o}{*} \PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

執行結果：

\begin{Verbatim}[commandchars=@\[\]]
The score of the exam is 14
\end{Verbatim}

Java 會在得到 a, b, a + b 的數值後，才將 3, 4, 7 傳入 englishScore 中。
也就是先得到數值再傳入，然後 v, g, l 便使用傳入的數值生成三個區域變數。
這個特性稱為  \textbf{call-by-value 或傳值呼叫} 。
v, g, l 三個參數之所以也是區域變數，因為這三個變數的可見範圍（scope）只包含 englishScore 的區塊。

如果一個方法沒有傳回值，那麼這個方法的輸出型態便是 void。例如：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{EnglishExam} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static}  \PYG{o}{*}\PYG{o}{*}\PYG{k+kt}{void} \PYG{n}{displayScore}\PYG{o}{*}\PYG{o}{*} \PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{v}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{g}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{l}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{print}\PYG{o}{(}\PYG{l+s}{"The score of the exam is "}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{v} \PYG{o}{+} \PYG{n}{g} \PYG{o}{+} \PYG{n}{l}\PYG{o}{)}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}

        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{argv}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{n}{displayScore}\PYG{o}{(}\PYG{l+m+mi}{24}\PYG{o}{,} \PYG{l+m+mi}{27}\PYG{o}{,} \PYG{l+m+mi}{32}\PYG{o}{)}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

執行結果：

\begin{Verbatim}[commandchars=@\[\]]
The score of the exam is 83
\end{Verbatim}

displayScore 這個方法將字串顯示在螢幕上，不需要傳回值，
因此它的輸出型態是宣告成 void，而 main 的輸出型態也是 void。

不同的類別中也可以定義同名的方法。這個功能稱做  \textbf{overloading} 。
而Java 是以 \textbf{類別名稱.方法名稱(0或多個參數)；} 呼叫宣告在不同類別的類別方法。例如：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Exam} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{argv}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{k+kt}{int} \PYG{n}{voc} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{o}{,} \PYG{n}{grammar} \PYG{o}{=} \PYG{l+m+mi}{7}\PYG{o}{,} \PYG{n}{listen} \PYG{o}{=} \PYG{l+m+mi}{8}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{print}\PYG{o}{(}\PYG{l+s}{"The score of the english exam is "}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{EnglishExam}\PYG{o}{.}\PYG{n+na}{displayScore}\PYG{o}{(}\PYG{n}{voc}\PYG{o}{,} \PYG{n}{grammar}\PYG{o}{,} \PYG{n}{listen}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{print}\PYG{o}{(}\PYG{l+s}{"The score of simple english exam is "}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{SimpleEnglishExam}\PYG{o}{.}\PYG{n+na}{displayScore}\PYG{o}{(}\PYG{n}{voc}\PYG{o}{,} \PYG{n}{grammar}\PYG{o}{,} \PYG{n}{listen}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}

\PYG{k+kd}{class} \PYG{n+nc}{EnglishExam} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{int} \PYG{n+nf}{displayScore}\PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{v}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{g}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{l}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{k}{return} \PYG{n}{v} \PYG{o}{+} \PYG{n}{g} \PYG{o}{+} \PYG{n}{l}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}

\PYG{k+kd}{class} \PYG{n+nc}{SimpleEnglishExam} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{int} \PYG{n+nf}{displayScore}\PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{v}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{g}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{l}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{k}{return} \PYG{n}{v} \PYG{o}{+} \PYG{n}{g} \PYG{o}{+} \PYG{l+m+mi}{0}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

執行結果：

\begin{Verbatim}[commandchars=@\[\]]
The score of the english exam is 18
The score of simple english exam is 10
\end{Verbatim}

一個類別中也可以有同名的方法，但是他們必須有不同的輸出入型態。例如：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Exam} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{argv}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{k+kt}{int} \PYG{n}{voc} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{o}{,} \PYG{n}{grammar} \PYG{o}{=} \PYG{l+m+mi}{7}\PYG{o}{,} \PYG{n}{listen} \PYG{o}{=} \PYG{l+m+mi}{8}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{print}\PYG{o}{(}\PYG{l+s}{"The int score of the exam is "}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(} \PYG{o}{*}\PYG{o}{*}\PYG{n}{EnglishExam}\PYG{o}{.}\PYG{n+na}{displayScore}\PYG{o}{(}\PYG{l+m+mi}{3}\PYG{o}{,} \PYG{l+m+mi}{7}\PYG{o}{,} \PYG{l+m+mi}{8}\PYG{o}{)}\PYG{o}{*}\PYG{o}{*} \PYG{o}{)}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{print}\PYG{o}{(}\PYG{l+s}{"The double score of the exam is "}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(} \PYG{o}{*}\PYG{o}{*}\PYG{n}{EnglishExam}\PYG{o}{.}\PYG{n+na}{displayScore}\PYG{o}{(}\PYG{l+m+mf}{3.0}\PYG{o}{,} \PYG{l+m+mf}{8.0}\PYG{o}{,} \PYG{l+m+mf}{7.0}\PYG{o}{)}\PYG{o}{*}\PYG{o}{*} \PYG{o}{)}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}

\PYG{k+kd}{class} \PYG{n+nc}{EnglishExam} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{int}  \PYG{o}{*}\PYG{o}{*}\PYG{n}{displayScore}\PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{v}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{g}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{l}\PYG{o}{)}\PYG{o}{*}\PYG{o}{*}  \PYG{o}{\PYGZob{}}
                \PYG{k}{return} \PYG{n}{v} \PYG{o}{+} \PYG{n}{g} \PYG{o}{+} \PYG{n}{l}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{double}  \PYG{o}{*}\PYG{o}{*}\PYG{n}{displayScore}\PYG{o}{(}\PYG{k+kt}{double} \PYG{n}{v}\PYG{o}{,} \PYG{k+kt}{double} \PYG{n}{g}\PYG{o}{,} \PYG{k+kt}{double} \PYG{n}{l}\PYG{o}{)}\PYG{o}{*}\PYG{o}{*}  \PYG{o}{\PYGZob{}}
                \PYG{k}{return} \PYG{n}{v} \PYG{o}{+} \PYG{n}{g} \PYG{o}{+} \PYG{n}{l}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

執行結果：

\begin{Verbatim}[commandchars=@\[\]]
The int score of the exam is 18
The double score of the exam is 18.0
\end{Verbatim}

另一個 overloading 的例子是：＋。＋可以用來將數字相加，也可以將字串合併。例如：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{o}{,} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{o}{;}
\PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{print}\PYG{o}{(}\PYG{l+m+mi}{3} \PYG{o}{+} \PYG{n}{a} \PYG{o}{+} \PYG{n}{b}\PYG{o}{)}\PYG{o}{;}
\end{Verbatim}

執行結果：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{12}
\end{Verbatim}

例如：

\begin{Verbatim}[commandchars=@\[\]]
.. code-block:: java
\end{Verbatim}
\begin{quote}

String a = ``xy'', b = ``Z'';
System.out.print(``3'' + a + b);
\end{quote}

執行結果：

\begin{Verbatim}[commandchars=@\[\]]
3xyz
\end{Verbatim}

使用類別方法在程式中有許多好處：
\begin{enumerate}
\item {} 
增加程式碼的再用性：同樣的計算步驟，只需要透過呼叫類別方法便可以重複使用。

\item {} 
讓程式碼的細節，被隱藏在類別方法中：程式設計師在完成類別方法的撰寫後，便只需要知道那個類別方法的輸入、輸出與功用即可，而不用擔心執行的細節。

\item {} 
容易除錯：除錯的過程可以一個類別方法、一個類別方法的進行，容易找出錯誤的根源。

\item {} 
容易擴充類別方法內程式碼的功能：只要在類別方法內擴充其功能，而不用在每次呼叫時都重複的擴充。例如以下的程式碼擴充了成績的計算方式，所有 displayScore 的呼叫的計算結果都同步改變：

\end{enumerate}

除了使用 static 宣告類別方法外，還有也是使用 static 宣告的類別變數。
以下是一個在程式中內建三筆考試成績的資料，呼叫 displayScore 計算成績後，
將三筆資料加總並存入 total 這個類別變數中的範例：

\begin{Verbatim}[commandchars=@\[\]]
.. code-block:: java
\end{Verbatim}
\begin{quote}
\begin{description}
\item[{public class Exam \{}] \leavevmode
public static int total = 0;
\begin{description}
\item[{public static void main(String argv{[}{]}) \{}] \leavevmode
total = displayScore(3, 4, 5); // total = 12
total = total + displayScore(4, 5, 6);          // total = 27
total = total + displayScore(1, 2, 3);          // total = 33
System.out.print(``The total score is '');
System.out.println(total);

\end{description}

\}
\begin{description}
\item[{public static int displayScore(int v, int g, int l) \{}] \leavevmode
return v + g + l;

\end{description}

\}

\end{description}

\}
\end{quote}

執行結果：

\begin{Verbatim}[commandchars=@\[\]]
The total score is 33
\end{Verbatim}

程式設計師也可以使用不是定義在自己類別中的類別變數，而 Java 是以 \textbf{類別名稱.變數名稱}
使用定義在其他類別中的類別變數。以下便是一種將 total 宣告在另一個類別 EnglishExam 中的寫法是：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Exam} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{argv}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{n}{EnglishExam}\PYG{o}{.}\PYG{n+na}{computeScore}\PYG{o}{(}\PYG{l+m+mi}{3}\PYG{o}{,} \PYG{l+m+mi}{4}\PYG{o}{,} \PYG{l+m+mi}{5}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{EnglishExam}\PYG{o}{.}\PYG{n+na}{computeScore}\PYG{o}{(}\PYG{l+m+mi}{4}\PYG{o}{,} \PYG{l+m+mi}{5}\PYG{o}{,} \PYG{l+m+mi}{6}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{EnglishExam}\PYG{o}{.}\PYG{n+na}{computeScore}\PYG{o}{(}\PYG{l+m+mi}{1}\PYG{o}{,} \PYG{l+m+mi}{2}\PYG{o}{,} \PYG{l+m+mi}{3}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{print}\PYG{o}{(}\PYG{l+s}{"The total score is "}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{EnglishExam}\PYG{o}{.}\PYG{n+na}{total}\PYG{o}{)}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}

\PYG{k+kd}{class} \PYG{n+nc}{EnglishExam} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{int} \PYG{n}{total} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{;}

        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{computeScore}\PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{v}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{g}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{l}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{n}{total} \PYG{o}{=} \PYG{n}{total} \PYG{o}{+} \PYG{o}{(}\PYG{n}{v} \PYG{o}{+} \PYG{n}{g} \PYG{o}{+} \PYG{n}{l}\PYG{o}{)}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

執行結果：

\begin{Verbatim}[commandchars=@\[\]]
The total score is 33
\end{Verbatim}

以下則是一個為考試成績的計算，加入權重的範例。
在這個範例中是以 Exam.wV, Exam.wG, Exam.wL 來使用這三個類別變數：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Exam} \PYG{o}{\PYGZob{}}

        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{double} \PYG{n}{wV} \PYG{o}{=} \PYG{l+m+mf}{0.3}\PYG{o}{,} \PYG{n}{wG} \PYG{o}{=} \PYG{l+m+mf}{0.3}\PYG{o}{,} \PYG{n}{wL} \PYG{o}{=} \PYG{l+m+mf}{0.4}\PYG{o}{;}

        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{argv}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{k+kt}{int} \PYG{n}{voc} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{o}{,} \PYG{n}{grammar} \PYG{o}{=} \PYG{l+m+mi}{7}\PYG{o}{,} \PYG{n}{listen} \PYG{o}{=} \PYG{l+m+mi}{8}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{print}\PYG{o}{(}\PYG{l+s}{"The score of the english exam is "}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{EnglishExam}\PYG{o}{.}\PYG{n+na}{displayScore}\PYG{o}{(}\PYG{n}{voc}\PYG{o}{,} \PYG{n}{grammar}\PYG{o}{,} \PYG{n}{listen}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{print}\PYG{o}{(}\PYG{l+s}{"The score of simple english exam is "}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{SimpleEnglishExam}\PYG{o}{.}\PYG{n+na}{displayScore}\PYG{o}{(}\PYG{n}{voc}\PYG{o}{,} \PYG{n}{grammar}\PYG{o}{,} \PYG{n}{listen}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}

\PYG{k+kd}{class} \PYG{n+nc}{EnglishExam} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{double} \PYG{n+nf}{displayScore}\PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{v}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{g}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{l}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{v} \PYG{o}{*} \PYG{n}{Exam}\PYG{o}{.}\PYG{n+na}{wV} \PYG{o}{+} \PYG{n}{g} \PYG{o}{*} \PYG{n}{Exam}\PYG{o}{.}\PYG{n+na}{wG} \PYG{o}{+} \PYG{n}{l} \PYG{o}{*} \PYG{n}{Exam}\PYG{o}{.}\PYG{n+na}{wL}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}

\PYG{k+kd}{class} \PYG{n+nc}{SimpleEnglishExam} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{double} \PYG{n+nf}{displayScore}\PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{v}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{g}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{l}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{k}{return} \PYG{n}{v} \PYG{o}{*} \PYG{n}{Exam}\PYG{o}{.}\PYG{n+na}{wV} \PYG{o}{+} \PYG{n}{g} \PYG{o}{*} \PYG{n}{Exam}\PYG{o}{.}\PYG{n+na}{wG} \PYG{o}{+} \PYG{l+m+mi}{0}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

執行結果：

\begin{Verbatim}[commandchars=@\[\]]
The score of the english exam is 6.2
The score of simple english exam is 3.0
\end{Verbatim}

類別變數與區域變數，在變數的可用「區域」與存在的「時間」上都不相同。類別變數若是定義為 public，則它的可用區域便包括整個程式，而且在整個程式執行時都存在。區域變數則是在程式執行到一個區塊或方法內時，那個區塊或方法的區域變數才存在，一旦離開那個區塊或方法，便消失了。因此區域變數的可用區域，只在定義該區域變數的區塊或方法內。

以下是一個「計算蛋與水果總價」的程式及其執行過程的動畫：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{class} \PYG{n+nc}{Market} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{static} \PYG{k+kt}{int} \PYG{n}{sEgg} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{o}{,} \PYG{n}{sFruit} \PYG{o}{=} \PYG{l+m+mi}{20}\PYG{o}{;}
                \PYG{k+kd}{static} \PYG{k+kt}{int} \PYG{n+nf}{getMoney}\PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{nEgg}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{nFruit}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{k}{return} \PYG{n}{sEgg} \PYG{o}{*} \PYG{n}{nEgg} \PYG{o}{+} \PYG{n}{sFruit} \PYG{o}{*} \PYG{n}{nFruit}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}

\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Ex1} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{argv}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{k+kt}{int} \PYG{n}{egg} \PYG{o}{=} \PYG{l+m+mi}{20}\PYG{o}{,} \PYG{n}{fruit} \PYG{o}{=} \PYG{l+m+mi}{30}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{print}\PYG{o}{(}\PYG{l+s}{"Money:"}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{Market}\PYG{o}{.}\PYG{n+na}{getMoney}\PYG{o}{(}\PYG{n}{egg}\PYG{o}{,} \PYG{n}{fruit}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

執行結果：

\begin{Verbatim}[commandchars=@\[\]]
Money:700
\end{Verbatim}

Media:Ex1new.swf 觀看執行過程


\chapter{運算式、句子與條件判斷句}
\label{java_cond::doc}\label{java_cond:id1}
運算式（expression）執行完畢會後傳回一個值；句子（statement）在執行之後，則不回傳值。一個運算式與句子在執行時都可能會改變電腦的狀態，例如：更改變數、陣列或檔案的內容。算術運算式已經介紹了，而最簡單的句子，包括：
\begin{enumerate}
\item {} 
expression statement：在運算式後加一個 '';'' 。

\item {} 
block statement：在 \{ \} 內可以有 0 或多個變數宣告或句子。

\end{enumerate}

這兩種句子，也都已經看過範例。這個單元將介紹關係運算式、邏輯運算式及 if、switch等句子。


\section{關係運算式}
\label{java_cond:id2}
以下是在寫關係運算式（relational expression）時常常會使用到的關係運算子（relational operator），整理如下：
\begin{itemize}
\item {} 
需注意關係運算式使用的  \textbf{``==''}  ，和寫設值運算式（assignment expression）的 ``='' 是不一樣的。

\end{itemize}


\section{邏輯運算式}
\label{java_cond:id3}
Java 常用的邏輯運算子（logical operators）有三個，分別是 \&\& (AND)、\textbar{}\textbar{} (OR)、! (NOT)。
邏輯運算式使用邏輯運算子以連結二個或以上的關係運算式。
\begin{itemize}
\item {} 
\&\& (AND)

\end{itemize}

\&\& 是「AND（且）」運算：左右二邊「都」為 true，結果為 true；其餘情況其結果都為 false。

如果左邊為 false，則系統就不會去執行右邊；
因為結果必為 false；既然左邊已經為 false，不管右邊結果為何，結果一定為 false。
\begin{itemize}
\item {} 
\textbar{}\textbar{} (OR)

\end{itemize}

\textbar{}\textbar{} 是「OR（或）」運算，左右二邊只要有一邊為 true，結果為 true；只有左右二邊都為 false，結果才為 false。

如果左邊為 true，則系統就不會去執行右邊；因為結果必為 true；
即然左邊已經為 true，不管右邊結果為何，結果一定為 true。
\begin{itemize}
\item {} 
! (NOT)

\end{itemize}

! 是「NOT（相反）」運算，其結果為 ! 右邊的相反。


\section{運算子的優先順序}
\label{java_cond:id4}
以下是在在寫運算式時常常會使用到的運算子的優先順序，整理如下：

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{
優先順序
} & \textbf{
運算子
}\\
\hline

1
 & 
\textbf{(} (左括號)  \textbf{)} (右括號) \textbf{++} (左遞增) \textbf{--} (左遞減)
\\

2
 & 
\textbf{+} (正) \textbf{-} (負) \textbf{!} (NOT) \textbf{++} (右遞增) \textbf{--} (右遞減)
\\

3
 & 
\textbf{*} (乘) \textbf{/} (除) \textbf{\%} (取餘數)
\\

4
 & 
\textbf{+} (加) \textbf{-} (減)
\\

5
 & 
\textbf{\textless{}} (小於) \textbf{\textless{}=} (小於等於) \textbf{\textgreater{}} (大於) \textbf{\textgreater{}=} (大於等於)
\\

6
 & 
\textbf{==} (等於) \textbf{!=} (不等於)
\\

7
 & 
\textbf{\&\&} (AND)
\\

8
 & 
\textbf{\textbar{}\textbar{}} (OR)
\\

9
 & 
\textbf{?:} (條件判斷)
\\
\hline
\end{tabulary}


上表雖然不易記憶，然而，由於 ``('' 與 '')'' 的優先順序是最優先，
所以在程式的設計過程中，我們可以藉由使用左、右括號來指定運算式的優先順序。

立即練習：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{48}
\PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{32}
\PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{55}

\PYG{n}{d} \PYG{o}{=} \PYG{n}{a}\PYG{o}{\textgreater{}}\PYG{n}{b}\PYG{o}{?}\PYG{n}{a}\PYG{o}{+}\PYG{n}{b}\PYG{o}{+}\PYG{o}{+}\PYG{o}{*}\PYG{o}{-}\PYG{o}{-}\PYG{n+nl}{c:}\PYG{n}{a}\PYG{o}{-}\PYG{n}{b}\PYG{o}{-}\PYG{o}{-}\PYG{o}{*}\PYG{o}{+}\PYG{o}{+}\PYG{n}{c}
\end{Verbatim}
\begin{enumerate}
\item {} 
請問 d 的值是多少？

\end{enumerate}

上面的程式碼，讀者可能需要查閱運算子優先次序，才能計算輸出的值是多少，
雖然對電腦來說，可以很快就按照規則計算出正確的數字，
但畢竟程式碼是由「人」撰寫和維護，要記住這些瑣碎的規則可是一點都不容易。

請再嘗試以下的練習：
\begin{enumerate}
\item {} 
在上一個練習的程式碼加上 ( ) 括號，讓你自己可以很容易看懂計算的優先次序。

\end{enumerate}


\section{Java 條件判斷句的種類}
\label{java_cond:java}
Java 的條件判斷句（statement）可以分成以下 3 種：
\begin{enumerate}
\item {} 
if...

\item {} 
if... else...

\item {} 
switch

\end{enumerate}


\subsection{if 條件判斷句}
\label{java_cond:if}
Java 語言 if (...) \{...\} 條件判斷句的流程圖及語法如下：

Image If-1.png

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{o}{(}\PYG{c+cm}{/* 條件判斷 */}\PYG{o}{)} \PYG{o}{\PYGZob{}}
  \PYG{c+c1}{//條件判斷成立時執行的程式碼}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

說明：
\begin{enumerate}
\item {} 
如果第 1 行的條件判斷成立（值 == true），則會執行第 2 \textasciitilde{} 4 行的程式碼（圖形藍色的路徑）。而如果條件判斷不成立（值 == false），則會跳過第 2 \textasciitilde{} 4 行程式碼不執行（圖形黑色 False 的路徑）。

\item {} 
如果第 1 行的條件判斷成立時，執行的程式碼只有一行，則區塊符號可以省略不寫。如果超過一行，其區塊符號 \{ \} 不可以省略。

\end{enumerate}

Example 1：請設計一個 Java 程式，讓使用者自行輸入一個成績，判斷輸入的成績是否「大於或等於」60 ，如果是就輸出「成績及格！」。

Image If-2.png

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{java.util.Scanner}\PYG{o}{;}
\PYG{k+kd}{class} \PYG{n+nc}{if\PYGZus{}loop} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String}\PYG{o}{[}\PYG{o}{]} \PYG{n}{args}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{n}{if\PYGZus{}condition}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}

  \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{if\PYGZus{}condition}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{print}\PYG{o}{(}\PYG{l+s}{"請輸入成績:"}\PYG{o}{)}\PYG{o}{;}
    \PYG{n}{Scanner} \PYG{n}{scanner} \PYG{o}{=} \PYG{k}{new} \PYG{n}{Scanner}\PYG{o}{(}\PYG{n}{System}\PYG{o}{.}\PYG{n+na}{in}\PYG{o}{)}\PYG{o}{;}
    \PYG{k+kt}{int} \PYG{n}{grade} \PYG{o}{=} \PYG{n}{scanner}\PYG{o}{.}\PYG{n+na}{nextInt}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}

    \PYG{k}{if} \PYG{o}{(}\PYG{n}{grade} \PYG{o}{\textgreater{}}\PYG{o}{=} \PYG{l+m+mi}{60}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"成績及格!"}\PYG{o}{)}\PYG{o}{;}
    \PYG{o}{\PYGZcb{}}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

執行結果：

\begin{Verbatim}[commandchars=@\[\]]
請輸入成績:60
成績及格!
\end{Verbatim}

說明：
\begin{itemize}
\item {} 
輸入的 grade 為 60 ，條件判斷的結果為 true（60 \textgreater{}= 60），會執行條件判斷成立區塊內的程式碼，輸出「成績及格!」（圖形藍色的路徑）。

\item {} 
因為範例中條件判斷成立時，執行的程式碼只有一行： System.out.println(``成績及格!''); 所以區塊符號可以省略不寫。

\end{itemize}


\subsection{if… else… 條件判斷句}
\label{java_cond:if-else}
Java 語言 if (...) \{...\} else \{...\} 條件判斷句的語法如下：

Image If-else-1.png

\begin{Verbatim}[commandchars=@\[\]]
if (條件判斷)
{
  條件判斷成立時執行的程式碼;
  ....
}
else
{
  條件判斷不成立時執行的程式碼;
  ....
}
\end{Verbatim}

說明：
\begin{itemize}
\item {} 
如果第 1 行的條件判斷成立（值 == true），則執行第 2 \textasciitilde{} 5 行區塊符號內的程式碼（圖形藍色的路徑）。

\item {} 
如果第 1 行的條件判斷不成立（值 ==false），則跳過第 2 \textasciitilde{} 5 行的程式碼，而執行第 7 \textasciitilde{} 10 行區塊符號內的程式碼（圖形紅色的路徑）。

\item {} 
如果 if 條件判斷成立或不成立時，執行的程式碼只有一行，則該區塊符號可以省略不寫。而如果超過一行，則區塊符號不可以省略。

\item {} 
if 和 else 是彼此互斥的關係，二個條件區塊在程式執行的過程中，只會選擇一個條件區塊去執行。

\end{itemize}

Example 2：請設計一個 Java 程式，讓使用者輸入一個成績，判斷該輸入的成績是否「大於或等於」60 ，如果是就輸出「成績及格!」；如果不是則輸出「成績不及格!」。

Image If-else-2.png

\begin{Verbatim}[commandchars=@\[\]]
import java.util.Scanner;

class if@_else@_loop {
  public static void main(String@PYGZlb[]@PYGZrb[] args) {
    if@_else@_condition();
    if@_else@_condition();
  }

  public static void if@_else@_condition() {
    System.out.print("請輸入成績:");
　　 Scanner scanner = new Scanner(System.in);
　　 int grade = scanner.nextInt();

　　 if (grade @textgreater[]= 60) {
      System.out.println("成績及格!");
　　 }
    else {
      System.out.println("成績不及格!");
    }
  }
}
\end{Verbatim}

執行結果：

\begin{Verbatim}[commandchars=@\[\]]
請輸入成績:88
成績及格!
請輸入成績:59
成績不及格!
\end{Verbatim}

說明：
\begin{itemize}
\item {} 
第一次輸入的 grade 為 88 ，其條件判斷的結果為 True（88 \textgreater{}= 60），執行 if 成立區塊內的程式碼，輸出 「成績及格!」（圖形藍色的路徑）。

\item {} 
第二次輸入的 grade 為 59 ，其條件判斷的結果為 False（59 \textgreater{}= 60），執行 else 區塊內的程式碼，輸出 「成績不及格!」（圖形紅色的路徑）。

\item {} 
因為 if 條件判斷成立和不成立時，執行的程式碼都只有一行，所以二者的區塊符號都可以省略不寫。

\end{itemize}


\subsection{數個 if 的條件判斷}
\label{java_cond:id5}
幾個接續在一起的 if 句子，可以寫成： if (...) \{...\} else if (...) \{...\} else \{...\}：

{[}{[}Image:If-elseif-else-1.png{]}{]}

\begin{Verbatim}[commandchars=@\[\]]
if (條件判斷1) {
  條件判斷1成立時執行的程式碼;
  ....
}
else if (條件判斷2) {
  條件判斷2成立時執行的程式碼;
  ....
}
：
：
else {
  上述條件判斷都不成立時執行的程式碼;
  ....
}
\end{Verbatim}

說明：
\begin{itemize}
\item {} 
如果在第 1 行的條件判斷1 成立（值 == true），則執行第 2 \textasciitilde{} 5 行區塊符號內的程式碼（圖形藍色的路徑），並略過其餘的程式碼。

\item {} 
如果在第 6 行的條件判斷2 成立（值 == true），則執行第 7 \textasciitilde{} 10 行區塊符號內的程式碼（圖形綠色的路徑），並略過其餘的程式碼。

\item {} 
如果所有的條件判斷都不成立（值 == false），則跳過第 1 \textasciitilde{} 12 行的程式碼，而執行第 14 \textasciitilde{} 17 行區塊符號內的程式碼 (圖形紅色的路徑) 。

\item {} 
if 、 else if 和 else 是彼此互斥的關係，所有條件區塊在程式執行的過程中，只會選擇一個條件區塊去執行。

\end{itemize}

Example 3：請設計一個 Java 程式，讓使用者自行輸入一個成績，判斷該輸入的成績是屬於 A, B, C, D 或 E 。

{[}{[}Image:If-elseif-else-2.png{]}{]}

\begin{Verbatim}[commandchars=@\[\]]
import java.util.Scanner;
class if@_elseif@_else@_loop {
　　public static void main(String@PYGZlb[]@PYGZrb[] args) {
　　　　if@_elseif@_else@_condition();
　　　　if@_elseif@_else@_condition();
　　　　if@_elseif@_else@_condition();
　　　　if@_elseif@_else@_condition();
　　　　if@_elseif@_else@_condition();
　　}

　　public static void if@_elseif@_else@_condition() {
　　　　System.out.print("請輸入成績:");
　　　　Scanner scanner = new Scanner(System.in);
　　　　int grade = scanner.nextInt();

　　　　if (grade @textgreater[]= 90)
　　　　　　System.out.println("成績為A");
　　　　else if (grade @textgreater[]= 80)
　　　　　　System.out.println("成績為B");
　　　　else if (grade @textgreater[]= 70)
　　　　　　System.out.println("成績為C");
　　　　else if (grade @textgreater[]= 60)
　　　　　　System.out.println("成績為D");
           else
　　　　　　System.out.println("成績為E");
　　}
}
\end{Verbatim}

執行結果：

\begin{Verbatim}[commandchars=@\[\]]
請輸入成績:90
成績為A
請輸入成績:89
成績為B
請輸入成績:70
成績為C
請輸入成績:60
成績為D
請輸入成績:59
成績為E
\end{Verbatim}

說明：
\begin{itemize}
\item {} 
第一次輸入的 grade 為 90 ，符合條件判斷 1，輸出 ``成績為A'' (圖形藍色的路徑) 。

\item {} 
第二次輸入的 grade 為 89 ，符合條件判斷 2，輸出 ``成績為B'' (圖形綠色的路徑) 。

\item {} 
第三次輸入的 grade 為 70 ，符合條件判斷 3，輸出 ``成績為C'' (圖形粉紅色的路徑) 。

\item {} 
第四次輸入的 grade 為 60 ，符合條件判斷 4，輸出 ``成績為D'' (圖形淺藍色的路徑) 。

\item {} 
第五次輸入的 grade 為 59 ，都不符合上面的條件判斷，會執行 else 區塊內的程式碼，輸出 ``成績為E'' (圖形紅色的路徑) 。

\item {} 
因為 if 條件判斷、所有 else if 條件判斷或 else 成立時，執行的程式碼都只有一行，所以區塊符號都可以省略不寫。

\end{itemize}


\subsection{switch 與 break}
\label{java_cond:switch-break}

\subsubsection{breake}
\label{java_cond:breake}\begin{itemize}
\item {} 
break：在程式執行時，遇到 break，會跳過目前執行區塊後的程式碼，並跳出目前的區塊。

\end{itemize}


\subsubsection{switch}
\label{java_cond:switch}
當需要對一個 int、short、char、byte 或是 enum 型態值做多種不同的判斷時，可以使用 switch ，以下是 switch 的語法：

{[}{[}Image:Switch-1.png{]}{]}

\begin{Verbatim}[commandchars=@\[\]]
1  switch (變數或運算式) {
2      case 值1:
3          符合值1執行的程式碼;
4          ....
5          break;
6      case 值2:
7          符合值2執行的程式碼;
8          ....
9          break;
10       ：
11       ：
12     case 值n:
13         符合值n執行的程式碼;
14         ....
15         break;
16     default:
17         都不符合上述值執行的程式碼;
18         ....
19 }
\end{Verbatim}

說明：
\begin{itemize}
\item {} 
第 1 行： Switch 後面括號內的程式碼，可以是變數（例如：grade）或是運算式，然而其型態必需是 int、short、char、byte 或是 enum 型態（圖形藍色菱形的部份）。

\item {} 
第 2 、 6 、 12 行：用以判斷 switch 後面括號內的變數或運算式的值是否符合值1（第2行；圖形藍色的路徑）、值2（第6行；圖形綠色的路徑）、值n（第12行；圖形粉紅色的路徑）的條件判斷。值1、值2、值n必須是常數（compile-time constant）。

\item {} 
第 (3\textasciitilde{}4) 、 (7\textasciitilde{}8) 、 (13\textasciitilde{}14) 行：如果符合值1（圖形藍色的路徑）、值2（圖形綠色的路徑）、值n（圖形粉紅色的路徑）時會執行的程式碼。

\item {} 
第 16 行：如果都不符合 case 值1 到 case 值n 的情況下，則會去執行 default 區塊內（第17、18行；圖形紅色的路徑）的程式碼，然後離開整個 swtich 的條件判斷。

\item {} 
第 5 、 9 、 15 行： \textbf{當程式執行遇到 break 敘述，會結束 swtich 的執行} 。

\item {} 
在 Java 語言中， \textbf{switch 條件判斷的 case 的值只能是單一的常數值（compile-time constant），不可以是範圍值（例如：\textgreater{}=90）} 。

\end{itemize}

Example 4：請使用 switch 來設計一個 Java 程式，讓使用者自行輸入一個成績，判斷該輸入的成績是介於哪一個區間之內。

{[}{[}Image:Switch-2.png{]}{]}

\begin{Verbatim}[commandchars=@\[\]]
import java.util.Scanner;
class Switch@_Statement {
　　public static void main(String@PYGZlb[]@PYGZrb[] args) {
　　　　switch@_statement();
　　　　switch@_statement();
           switch@_statement();
　　　　switch@_statement();
　　　　switch@_statement();
           switch@_statement();
　　}

        public static void switch@_statement() {
　　　　System.out.print("請輸入成績:");
　　　　Scanner scanner = new Scanner(System.in);
　　　　int grade = scanner.nextInt();
           grade = (int)grade / 10;

           switch (grade) {
                   case 10:
                   case 9:
                           System.out.println("90@textasciitilde[]100");
                           break;
                   case 8:
                           System.out.println("80@textasciitilde[]89");
                           break;
                   case 7:
                           System.out.println("70@textasciitilde[]100");
                           break;
                   case 6:
                           System.out.println("60@textasciitilde[]69");
                           break;
                   default:
                           System.out.println("0@textasciitilde[]59");
           }
        }
}
\end{Verbatim}

執行結果：

\begin{Verbatim}[commandchars=@\[\]]
請輸入成績:100
90@textasciitilde[]100
請輸入成績:90
90@textasciitilde[]100
請輸入成績:89
80@textasciitilde[]89
請輸入成績:74
70@textasciitilde[]59
請輸入成績:60
60@textasciitilde[]69
請輸入成績:59
0@textasciitilde[]59
\end{Verbatim}

說明：
\begin{itemize}
\item {} 
第一次輸入的 grade 為 100，符合 case 10 的條件判斷，但 case 10 區塊內沒有 break 敘述（圖形藍色的路徑）會繼續往下執行到 case 9 區塊內的程式碼，輸出 ``90\textasciitilde{}100''（圖形綠色的路徑），之後遇到 break 敘述跳離開整個 swtich。

\item {} 
第二次輸入的 grade 為 90，符合 case 9 的條件判斷，會執行 case 9 區塊內的程式碼，輸出 ``90\textasciitilde{}100''（圖形綠色的路徑），之後遇到 break 敘述跳離開整個 swtich 。

\item {} 
第三次輸入的 grade 為 89，符合 case 8 的條件判斷，會執行 case 8 區塊內的程式碼，輸出 ``80\textasciitilde{}89''（圖形粉紅色的路徑），之後遇到 break 敘述跳離開整個 swtich。

\item {} 
第四次輸入的 grade 為 74，符合 case 7 的條件判斷，會執行 case 7 區塊內的程式碼，輸出 ``70\textasciitilde{}79''（圖形淺藍色的路徑），之後遇到 break 敘述跳離開整個 swtich。

\item {} 
第五次輸入的 grade 為 60，符合 case 6 的條件判斷，會執行 case 6 區塊內的程式碼，輸出 ``60\textasciitilde{}69''（圖形橘色的路徑），之後遇到 break 敘述跳離開整個 swtich。

\item {} 
第六次輸入的 grade 為 59，都不符合上面 case 的條件判斷，會執行 default 區塊內的程式碼，輸出 ``0\textasciitilde{}59''（圖形紅色的路徑），之後離開 swtich。

\end{itemize}


\subsection{巢狀條件判斷}
\label{java_cond:id6}
巢狀條件判斷（nested-if）：是指在一個 if 裡面還有 if 。

Example 5：請寫一個判斷使用者輸入的數是否是2或3或6的倍數，或者都不是他們倍數的java程式。

{[}{[}Image:nested\_if.png\textbar{}link={]}{]}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{java.util.Scanner}\PYG{o}{;}
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Times} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{n}{Scanner} \PYG{n}{keyboard} \PYG{o}{=} \PYG{k}{new} \PYG{n}{Scanner}\PYG{o}{(}\PYG{n}{System}\PYG{o}{.}\PYG{n+na}{in}\PYG{o}{)}\PYG{o}{;}

        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String}\PYG{o}{[}\PYG{o}{]} \PYG{n}{args}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{n}{times}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{times}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{times}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{times}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}

        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{times}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{print}\PYG{o}{(}\PYG{l+s}{"請輸入一個整數："}\PYG{o}{)}\PYG{o}{;}
                \PYG{k+kt}{int} \PYG{n}{num} \PYG{o}{=} \PYG{n}{keyboard}\PYG{o}{.}\PYG{n+na}{nextInt}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}

                \PYG{k}{if} \PYG{o}{(}\PYG{o}{(}\PYG{n}{num} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{2}\PYG{o}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                        \PYG{k}{if} \PYG{o}{(}\PYG{o}{(}\PYG{n}{num} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{3}\PYG{o}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{num} \PYG{o}{+} \PYG{l+s}{"是2、3、6的倍數。"}\PYG{o}{)}\PYG{o}{;}
                        \PYG{o}{\PYGZcb{}}
                        \PYG{k}{else} \PYG{o}{\PYGZob{}}
                                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{num} \PYG{o}{+} \PYG{l+s}{"是2的倍數。"}\PYG{o}{)}\PYG{o}{;}
                        \PYG{o}{\PYGZcb{}}
                \PYG{o}{\PYGZcb{}}
                \PYG{k}{else} \PYG{o}{\PYGZob{}}
                        \PYG{k}{if} \PYG{o}{(}\PYG{o}{(}\PYG{n}{num} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{3}\PYG{o}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{num} \PYG{o}{+} \PYG{l+s}{"是3的倍數。"}\PYG{o}{)}\PYG{o}{;}
                        \PYG{o}{\PYGZcb{}}
                        \PYG{k}{else} \PYG{o}{\PYGZob{}}
                                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{num} \PYG{o}{+} \PYG{l+s}{"都不是2、3、6的倍數。"}\PYG{o}{)}\PYG{o}{;}
                        \PYG{o}{\PYGZcb{}}
                \PYG{o}{\PYGZcb{}}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

輸出結果：

\begin{Verbatim}[commandchars=@\[\]]
請輸入一個整數：12
12是2、3、6的倍數。
請輸入一個整數：4
4是2的倍數。
請輸入一個整數：9
9是3的倍數。
請輸入一個整數：11
11都不是2、3、6的倍數。
\end{Verbatim}

說明：
\begin{itemize}
\item {} 
當輸入的 num 為 12 時，第一層（外層）可被 2 整除（執行 if 區塊），再往第二層（內層）可被 3 整除（執行 if 區塊），輸出 ``12是2、3、6的倍數。''（圖形藍色的路徑）。

\item {} 
當輸入的 num 為 4 時，第一層（外層）可被 2 整除（執行 if 區塊），再往第二層（內層）不可被 3 整除（執行 else 區塊），輸出 ``4是2的倍數。''（圖形粉紅色的路徑）。

\item {} 
當輸入的 num 為 9 時，第一層（外層）不可被 2 整除（執行 else 區塊），再往第二層（內層）可被 3 整除（執行 if 區塊內），輸出 ``9是3的倍數。''（圖形綠色的路徑）。

\item {} 
當輸入的 num 為 11 時，第一層（外層）不可被 2 整除（執行 else 區塊），再往第二層（內層）不可被 3 整除（執行 else 區塊），輸出 ``11都不是2、3、6的倍數。''（圖形紅色的路徑）。

\end{itemize}


\subsection{? : 條件判斷式}
\label{java_cond:id7}
條件判斷 ? 條件判斷成立時執行的程式碼 : 條件判斷不成立時執行的程式碼 ;

if 與 ? : 的差別在於 if 不傳回值；而 ? : 可以傳回值（見以下範例）

Example 6：請設計一個 Java 程式，可以判斷成績是否及格。

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{o}{(}\PYG{n}{grade} \PYG{o}{\textgreater{}}\PYG{o}{=} \PYG{l+m+mi}{60}\PYG{o}{)}
        \PYG{n}{message} \PYG{o}{=} \PYG{l+s}{"成績及格!"}\PYG{o}{;}
\PYG{k}{else}
        \PYG{n}{message} \PYG{o}{=} \PYG{l+s}{"成績不及格!"}\PYG{o}{;}
\end{Verbatim}

上面 Example 6 可以改寫成下面只有一行的 ? : 條件判斷式。

\begin{Verbatim}[commandchars=@\[\]]
message = (grade @textgreater[]=60) ? "成績及格!" : "成績不及格!";

message 的值是上例執行 ? : 運算式之後傳回的結果。
\end{Verbatim}


\chapter{迴圈與遞迴}
\label{java_loop::doc}\label{java_loop:id1}

\section{迴圈}
\label{java_loop:id2}
我們在撰寫程式時，常常需要用到迴圈。
像是要讓使用者輸入10位學生的成績，
如果沒有使用迴圈，就必須將輸入成績的程式碼寫10次，
而這10次的程式碼卻完全一樣。
如果使用迴圈，便只需要寫 1 次就可以了。
使用迴圈讓這輸入成績的程式碼可以連續執行10次，以達到相同的效果，
因此可以讓程式設計的更精簡、有彈性。

Java 用來寫迴圈的句子有以下三個：
\begin{enumerate}
\item {} 
for

\item {} 
while

\item {} 
do-while

\end{enumerate}


\subsection{for-loop}
\label{java_loop:for-loop}
for-loop 的語法如下：

\begin{Verbatim}[commandchars=@\[\]]
for (控制變數的初始值設定; 控制變數的條件判斷; 控制變數值的改變) {
  符合控制變數的條件判斷時，執行的程式碼區塊;
  ....
}
\end{Verbatim}

說明：
\begin{itemize}
\item {} 
for-loop 主要由四個部份所組成，分別是「控制變數的初始值設定」、「控制變數的條件判斷」、「控制變數值的改變」與「符合控制變數的條件判斷時，執行的程式碼區塊」。

\item {} 
「控制變數的初始值設定」：只有在迴圈第一次執行時才會執行，其目的是用來設定控制迴圈變數（loop control variable）初始值的設定。例如：int i = 0; 表示 for 迴圈一開始執行時，宣告一個 int 的控制變數，其值為0。

\item {} 
「控制變數的條件判斷」：每一次執行 \{  \} 內的程式碼區塊前，會先執行「控制變數的條件判斷」。如果符合該條件判斷，才會去執行迴圈內的程式碼；不符合便結束迴圈的執行。例如：i \&lt; 5; 表示如果此時迴圈的控制變數 i 的值小於 5 才會去執行迴圈內的程式碼，否則便離開迴圈。

\item {} 
「控制變數值的改變」：每一次 for 執行完在 \{  \} 內的程式碼區塊之後，會執行的部份。它會改變迴圈控制變數的值。例如：i++; 表示每一次迴圈執行完之後，將變數 i 的值加 1。

\item {} 
「符合控制變數的條件判斷時，執行的程式碼區塊」（第 2 行的 \{ 至第5行的 \}）：符合控制變數的條件判斷時，會執行的程式碼。例如：System.out.println(i); 表示將迴圈的控制變數 i 的值輸出。

\end{itemize}

Example 1：請利用 for-loop 來設計一個程式，讓迴圈執行5次，每次執行時都輸出迴圈執行到第幾次。

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{for\PYGZus{}loop} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String}\PYG{o}{[}\PYG{o}{]} \PYG{n}{args}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{k}{for} \PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{;} \PYG{n}{i}\PYG{o}{\textless{}}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{o}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{o}{)}
      \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"for迴圈執行第"} \PYG{o}{+} \PYG{n}{i} \PYG{o}{+} \PYG{l+s}{"次。"}\PYG{o}{)}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

執行結果：

\begin{Verbatim}[commandchars=@\[\]]
for迴圈執行第1次。
for迴圈執行第2次。
for迴圈執行第3次。
for迴圈執行第4次。
for迴圈執行第5次。
\end{Verbatim}
\begin{itemize}
\item {} 
由於區塊內的程式碼只有一個句子，所以 \{ \} 可以省略不寫。

\end{itemize}

Example 2：請利用 for-loop 搭配 if 條件判斷來設計一個 Java 程式，將 1 到 10 中的偶數輸出。

\begin{Verbatim}[commandchars=@\[\]]
public class for@_loop2 {
  public static void main(String@PYGZlb[]@PYGZrb[] args) {
    for (int i=1; i@textless[]=10; i++)
      if (i @% 2 == 0)
        System.out.println("1到10的偶數有：" + i);
　}
}
\end{Verbatim}

輸出結果：

\begin{Verbatim}[commandchars=@\[\]]
1到10的偶數有：2
1到10的偶數有：4
1到10的偶數有：6
1到10的偶數有：8
1到10的偶數有：10
\end{Verbatim}


\subsection{while-loop}
\label{java_loop:while-loop}
while-loop 是前測式的迴圈，其語法如下：

\begin{Verbatim}[commandchars=@\[\]]
//控制變數的初始值設定;

while (控制變數的條件判斷) {
  //符合控制變數的條件判斷時，執行的程式碼區塊;
  //....
  //控制變數值的改變;
}
\end{Verbatim}

說明：
\begin{itemize}
\item {} 
while-loop 和 for-loop 同樣由四個部分所組成，分別是「控制變數的初始值設定」、「控制變數的條件判斷」、「符合控制變數的條件判斷時，執行的程式碼區塊」與「控制變數值的改變」。

\item {} 
while-loop 是「前測式迴圈」，因為控制變數的條件判斷位於迴圈一開始的地方，因此 while-loop 執行次數可以為0次，也就是控制變數的條件判斷在一開始便不符合。

\end{itemize}

Example 3：請利用 while-loop 設計一個 Java 程式，讓迴圈執行5次，每次執行時都輸出迴圈執行到第幾次。

\begin{Verbatim}[commandchars=@\[\]]
public class while@_loop {
　　public static void main(String@PYGZlb[]@PYGZrb[] args) {
       int i = 1;
       while (i @textless[]= 5) {
           System.out.println("while迴圈執行第" + i + "次。");
           i++;
       }
　　}
}
\end{Verbatim}

執行結果：

\begin{Verbatim}[commandchars=@\[\]]
while迴圈執行第1次。
while迴圈執行第2次。
while迴圈執行第3次。
while迴圈執行第4次。
while迴圈執行第5次。
\end{Verbatim}

Example 4：請利用 while-loop 設計一個 Java 程式，這個程式一直讓使用者從鍵盤輸入數字，
直到輸入 -1 時為止。這個程式輸出這些數字的和。

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{java.util.Scanner}\PYG{o}{;}
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Sentinel} \PYG{o}{\PYGZob{}}
 \PYG{k+kd}{static} \PYG{n}{Scanner} \PYG{n}{keyboard} \PYG{o}{=} \PYG{k}{new} \PYG{n}{Scanner}\PYG{o}{(}\PYG{n}{System}\PYG{o}{.}\PYG{n+na}{in}\PYG{o}{)}\PYG{o}{;}
 \PYG{k+kd}{static} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{o}{-}\PYG{l+m+mi}{1}\PYG{o}{;}

 \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String}\PYG{o}{[}\PYG{o}{]} \PYG{n}{args}\PYG{o}{)} \PYG{o}{\PYGZob{}}
     \PYG{k+kt}{int} \PYG{n}{total} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{;}
     \PYG{k+kt}{int} \PYG{n}{s} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{;}

      \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{print}\PYG{o}{(}\PYG{l+s}{"Please enter score or enter -1 to stop: "}\PYG{o}{)}\PYG{o}{;}
     \PYG{n}{s} \PYG{o}{=} \PYG{n}{keyboard}\PYG{o}{.}\PYG{n+na}{nextInt}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}\PYG{o}{*}\PYG{o}{*}
     \PYG{k}{while} \PYG{o}{(}\PYG{n}{s} \PYG{o}{!}\PYG{o}{=} \PYG{n}{i}\PYG{o}{)} \PYG{o}{\PYGZob{}}
         \PYG{n}{total} \PYG{o}{=} \PYG{n}{total} \PYG{o}{+} \PYG{n}{s}\PYG{o}{;}
          \PYG{o}{*}\PYG{o}{*}\PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{print}\PYG{o}{(}\PYG{l+s}{"Please enter score or enter -1 to stop: "}\PYG{o}{)}\PYG{o}{;}
         \PYG{n}{s} \PYG{o}{=} \PYG{n}{keyboard}\PYG{o}{.}\PYG{n+na}{nextInt}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
     \PYG{o}{\PYGZcb{}}
     \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"The sum of scores: "}\PYG{o}{+} \PYG{n}{total}\PYG{o}{)}\PYG{o}{;}
 \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

輸出結果：

\begin{Verbatim}[commandchars=@\[\]]
Please enter score or enter -1 to stop: 3
Please enter score or enter -1 to stop: 5
Please enter score or enter -1 to stop: 7
Please enter score or enter -1 to stop: 9
Please enter score or enter -1 to stop: -1
The sum of scores: 24
\end{Verbatim}
\begin{itemize}
\item {} 
這個程式的特性是輸入數字的程式碼，在進入迴圈前及迴圈尾各出現一次。

\item {} 
這種迴圈叫旗標控制迴圈（sentinel-controlled loop）。

\end{itemize}


\subsection{do-while}
\label{java_loop:do-while}
do-while loop 是一種後測式迴圈，其語法如下：

說明：
\begin{itemize}
\item {} 
do-while loop 和 for-loop、while-loop 同樣由四個部分所組成，分別是「控制變數的初始值設定」、「控制變數的條件判斷」、「符合控制變數的條件判斷時，執行的程式碼區塊」與「控制變數值的改變」。

\item {} 
do-while loop 是「後測式迴圈」，因為控制變數的條件判斷位於最後面。

\item {} 
do-while loop 最少會執行 1 次。因為一開始會先執行 do 區塊內的程式碼，之後才會進行 while 之後控制變數的條件判斷。

\item {} 
特別留意在最一行 while 控制變數的條件判斷後面，需加上「;」以表示 do-while loop 的結束。

\end{itemize}

Example 5：請利用 do-while loop 設計一個 Java 程式，
讓迴圈執行5次，每次執行時都輸出迴圈執行第幾次。

\begin{Verbatim}[commandchars=@\[\]]
public class do@_while@_loop {
　　public static void main(String@PYGZlb[]@PYGZrb[] args) {
     **int i = 1;
    do {
        System.out.println("do while迴圈執行第" + i + "次。");
        i++;
    } while (i @textless[]= 5);**
　　}
}
\end{Verbatim}

執行結果：

\begin{Verbatim}[commandchars=@\[\]]
do while迴圈執行第1次。
do while迴圈執行第2次。
do while迴圈執行第3次。
do while迴圈執行第4次。
do while迴圈執行第5次。
\end{Verbatim}

Example 6：請利用 do-while loop 搭配 if 條件判斷來設計一個 Java 程式，將 1 到 10 中間的偶數輸出。

\begin{Verbatim}[commandchars=@\[\]]
public class do@_while@_loop2 {
　　public static void main(String@PYGZlb[]@PYGZrb[] args) {
     **int i = 1;
    do {
        if (i @% 2 == 0)
            System.out.println("1到10的偶數有：" + i);
        i++;
    } while (i @textless[]= 10);**
　　}
}
\end{Verbatim}

執行結果：

\begin{Verbatim}[commandchars=@\[\]]
1到10的偶數有：2
1到10的偶數有：4
1到10的偶數有：6
1到10的偶數有：8
1到10的偶數有：10
\end{Verbatim}


\subsection{breake \& continue}
\label{java_loop:breake-continue}
====breake====
\begin{itemize}
\item {} 
break：可以離開目前的 switch、for、while、do while 的區塊，並跳離至區塊後的下一行程式碼。在 switch 中主要用來離開；而在 for、while 與 do while 迴圈中，主要用於中斷目前迴圈的執行。

\end{itemize}

Example 7：下面是一個使用 break 敘述的 Java 程式，觀察程式碼及程式執行的過程。

執行結果：

\begin{Verbatim}[commandchars=@\[\]]
迴圈執行第1次。
迴圈執行第2次。
迴圈執行第3次。
迴圈執行第4次。
\end{Verbatim}
\begin{itemize}
\item {} 
此迴圈只會執行 4 次，因為當 i==5 時就會執行 break; 述敘而離開迴圈。

\end{itemize}


\subsection{continue}
\label{java_loop:continue}\begin{itemize}
\item {} 
continue：作用與 break 敘述類似，主要使用於 for、while、do while 迴圈，所不同的是 break 敘述會結束迴圈區塊的執行，而continue 只會結束目前執行中區塊的程式碼，並跳回迴圈區塊的開頭繼續下一迴圈，而不是離開迴圈。

\end{itemize}

Example 8：下面是一個使用 continue 敘述的 Java 程式，觀察程式碼及程式執行的過程。

\begin{Verbatim}[commandchars=@\[\]]
public class continue1 {
　　public static void main(String@PYGZlb[]@PYGZrb[] args) {
       for (int i=1; i@textless[]=10; i++) {
           if (i == 5)
               continue;
           System.out.println("迴圈執行第" + i + "次。");
       }
　　}
}
\end{Verbatim}

執行結果：

\begin{Verbatim}[commandchars=@\[\]]
迴圈執行第1次。
迴圈執行第2次。
迴圈執行第3次。
迴圈執行第4次。
迴圈執行第6次。
迴圈執行第7次。
迴圈執行第8次。
迴圈執行第9次。
迴圈執行第10次。
\end{Verbatim}
\begin{itemize}
\item {} 
此迴圈會執行 1 \textasciitilde{} 4 加 6 \textasciitilde{} 9 次，當 i==5 時，會執行 continue; 述敘而跳離此次迴圈，然後從區塊開頭執行下一次迴圈，所以 i==5 並沒有被執行。

\end{itemize}


\subsection{巢狀迴圈}
\label{java_loop:id3}\begin{itemize}
\item {} 
巢狀迴圈（nested loop）是指一個迴圈裡面還存在一個以上的迴圈。

\item {} 
巢狀迴圈執行的總次數為每一個迴圈執行次數的乘積。例如：一個輸出九九乘法表程式的執行次數，就是外層的8次乘以內層的9次，因此得到 8 x 9 = 72 次。

\item {} 
巢狀迴圈裡面的每一個迴圈都不可以與其它迴圈重疊，只能是彼此包含的關係。

\end{itemize}

Example 9：請使用巢狀迴圈設計一個輸出九九乘法表的程式，並計算巢狀迴圈總共執行了幾次。

\begin{Verbatim}[commandchars=@\[\]]
public class NineNineTable {
　　public static void main(String@PYGZlb[]@PYGZrb[] args) {
       int count = 0;
       for (int i=2; i@textless[]=9; i++) {
           for (int j=1; j@textless[]=9; j++) {
               System.out.printf("@%d*@%d=@%2d ", i, j, i*j);
               count++;
           }
           System.out.printf("\n");
       }
       System.out.printf("巢狀迴圈總共執行了@%d次\n", count);
　　}
}
\end{Verbatim}

執行結果：

\begin{Verbatim}[commandchars=@\[\]]
2*1= 2 2*2= 4 2*3= 6 2*4= 8 2*5=10 2*6=12 2*7=14 2*8=16 2*9=18
3*1= 3 3*2= 6 3*3= 9 3*4=12 3*5=15 3*6=18 3*7=21 3*8=24 3*9=27
4*1= 4 4*2= 8 4*3=12 4*4=16 4*5=20 4*6=24 4*7=28 4*8=32 4*9=36
5*1= 5 5*2=10 5*3=15 5*4=20 5*5=25 5*6=30 5*7=35 5*8=40 5*9=45
6*1= 6 6*2=12 6*3=18 6*4=24 6*5=30 6*6=36 6*7=42 6*8=48 6*9=54
7*1= 7 7*2=14 7*3=21 7*4=28 7*5=35 7*6=42 7*7=49 7*8=56 7*9=63
8*1= 8 8*2=16 8*3=24 8*4=32 8*5=40 8*6=48 8*7=56 8*8=64 8*9=72
9*1= 9 9*2=18 9*3=27 9*4=36 9*5=45 9*6=54 9*7=63 9*8=72 9*9=81
巢狀迴圈總共執行了72次
\end{Verbatim}

Example 10：請使用巢狀迴圈設計一個 Java 程式，這個程式持續輸入兩個整數 m, n，利用 while-loop 計算 m 的 n 次方，直到輸入 999 為止。

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{java.util.Scanner}\PYG{o}{;}
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{PowerOf} \PYG{o}{\PYGZob{}}
    \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{n}{Scanner} \PYG{n}{input} \PYG{o}{=} \PYG{k}{new} \PYG{n}{Scanner}\PYG{o}{(}\PYG{n}{System}\PYG{o}{.}\PYG{n+na}{in}\PYG{o}{)}\PYG{o}{;}

    \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String}\PYG{o}{[}\PYG{o}{]} \PYG{n}{args}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{n}\PYG{o}{,} \PYG{n}{m}\PYG{o}{;}

        \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"Input: "}\PYG{o}{)}\PYG{o}{;}
        \PYG{n}{m} \PYG{o}{=} \PYG{n}{input}\PYG{o}{.}\PYG{n+na}{nextInt}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}

        \PYG{k}{while} \PYG{o}{(}\PYG{n}{m} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{999}\PYG{o}{)} \PYG{o}{\PYGZob{}}
            \PYG{n}{n} \PYG{o}{=} \PYG{n}{input}\PYG{o}{.}\PYG{n+na}{nextInt}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}

            \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{print}\PYG{o}{(}\PYG{n}{m} \PYG{o}{+} \PYG{l+s}{"\PYGZca{}"} \PYG{o}{+} \PYG{n}{n} \PYG{o}{+} \PYG{l+s}{"="}\PYG{o}{)}\PYG{o}{;}

            \PYG{k+kt}{int} \PYG{n}{result} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{;}
            \PYG{k}{while} \PYG{o}{(}\PYG{n}{n} \PYG{o}{\textgreater{}} \PYG{l+m+mi}{0}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{n}{result} \PYG{o}{*}\PYG{o}{=} \PYG{n}{m}\PYG{o}{;}
                \PYG{n}{n}\PYG{o}{-}\PYG{o}{-}\PYG{o}{;}
            \PYG{o}{\PYGZcb{}}

            \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{result}\PYG{o}{)}\PYG{o}{;}

            \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"Input: "}\PYG{o}{)}\PYG{o}{;}
            \PYG{n}{m} \PYG{o}{=} \PYG{n}{input}\PYG{o}{.}\PYG{n+na}{nextInt}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
    \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

------Result--------

\begin{Verbatim}[commandchars=@\[\]]
Input:
3
4
3@textasciicircum[]4=81
Input:
4
5
4@textasciicircum[]5=1024
Input:
5
6
5@textasciicircum[]6=15625
Input:
999
\end{Verbatim}

說明：
\begin{itemize}
\item {} 
外層的 while 迴圈控制程式執行到輸入 999 才結束。

\item {} 
內層的 while 迴圈計算 m 的 n 次方。

\end{itemize}


\subsection{for-loop、while-loop 與 do-while-loop 的相互轉換}
\label{java_loop:for-loopwhile-loop-do-while-loop}\begin{itemize}
\item {} 
for-loop、while-loop、do-while-loop可以彼此相互轉換，前面曾經介紹這三種迴圈主要由 4 個部分所組成，我們可以藉由搬動這4個部分的程式碼來完成迴圈的相互轉換。

\item {} 
for-loop -\textgreater{} while-loop 可以遵從下面三個步驟：

\end{itemize}
\begin{enumerate}
\item {} 
將「控制變數的初始值設定」從 for-loop 拉到 while-loop 前面。

\item {} 
將「控制變數的條件判斷」保留在 while-loop 的「控制變數的條件判斷」內。

\item {} 
將「控制變數值的改變」拉到 while-loop 的「符合控制變數的條件判斷時，執行的程式碼區塊」內的最後一行。

\end{enumerate}
\begin{itemize}
\item {} 
while-loop -\textgreater{} do-while-loop ：

\end{itemize}
\begin{enumerate}
\item {} 
將 while-loop 的「控制變數的條件判斷」拉到 do-while-loop 最後一行的「「控制變數的條件判斷」」內即可完成。

\end{enumerate}

Example 11：請分別利用 for 、 while 與 do-while 設計計算 1 加到 100 的程式。

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Loop\PYGZus{}Transfer1} \PYG{o}{\PYGZob{}}
    \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String}\PYG{o}{[}\PYG{o}{]} \PYG{n}{args}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{c+c1}{// for-loop}
        \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"for迴圈1加到100為"} \PYG{o}{+} \PYG{n}{for\PYGZus{}loop}\PYG{o}{(}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}

        \PYG{c+c1}{// while-loop}
        \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"while迴圈1加到100為"} \PYG{o}{+} \PYG{n}{while\PYGZus{}loop}\PYG{o}{(}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}

        \PYG{c+c1}{// do-while-loop}
         \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"do-while迴圈1加到100為"} \PYG{o}{+} \PYG{n}{do\PYGZus{}while\PYGZus{}loop}\PYG{o}{(}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
    \PYG{o}{\PYGZcb{}}

    \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{int} \PYG{n+nf}{for\PYGZus{}loop}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{sum} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{;}
        \PYG{k}{for}\PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{;} \PYG{n}{i}\PYG{o}{\textless{}}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{o}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{o}{)}
            \PYG{n}{sum} \PYG{o}{+}\PYG{o}{=} \PYG{n}{i}\PYG{o}{;}
        \PYG{k}{return} \PYG{n}{sum}\PYG{o}{;}
    \PYG{o}{\PYGZcb{}}

    \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{int} \PYG{n+nf}{while\PYGZus{}loop}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{sum} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{;}
        \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{;}
        \PYG{k}{while} \PYG{o}{(}\PYG{n}{i} \PYG{o}{\textless{}}\PYG{o}{=} \PYG{l+m+mi}{100}\PYG{o}{)} \PYG{o}{\PYGZob{}}
            \PYG{n}{sum} \PYG{o}{+}\PYG{o}{=} \PYG{n}{i}\PYG{o}{;}
            \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n}{sum}\PYG{o}{;}
    \PYG{o}{\PYGZcb{}}

    \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{int} \PYG{n+nf}{do\PYGZus{}while\PYGZus{}loop}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{sum} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{;}
        \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{;}
        \PYG{k}{do} \PYG{o}{\PYGZob{}}
            \PYG{n}{sum} \PYG{o}{+}\PYG{o}{=} \PYG{n}{i}\PYG{o}{;}
            \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}} \PYG{k}{while} \PYG{o}{(}\PYG{n}{i} \PYG{o}{\textless{}}\PYG{o}{=} \PYG{l+m+mi}{100}\PYG{o}{)}\PYG{o}{;}
        \PYG{k}{return} \PYG{n}{sum}\PYG{o}{;}
    \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

執行結果：
\begin{quote}

for迴圈1加到100為5050
while迴圈1加到100為5050
do-while迴圈1加到100為5050
\end{quote}

Example 12：請分別利用 for、while 與 do-while 設計計算 1 到 100 中間 3 的倍數的總合。

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Loop\PYGZus{}Transfer2} \PYG{o}{\PYGZob{}}
    \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String}\PYG{o}{[}\PYG{o}{]} \PYG{n}{args}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{c+c1}{// for-loop}
        \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"for迴圈1到100間3的倍數總合為"} \PYG{o}{+} \PYG{n}{for\PYGZus{}loop}\PYG{o}{(}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}

        \PYG{c+c1}{// while-loop}
        \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"while迴圈1到100間3的倍數總合為"} \PYG{o}{+} \PYG{n}{while\PYGZus{}loop}\PYG{o}{(}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}

        \PYG{c+c1}{// do-while-loop}
        \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"do-while迴圈1到100間3的倍數總合為"} \PYG{o}{+} \PYG{n}{do\PYGZus{}while\PYGZus{}loop}\PYG{o}{(}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
    \PYG{o}{\PYGZcb{}}

    \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{int} \PYG{n+nf}{for\PYGZus{}loop}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{count} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{;}
        \PYG{k}{for} \PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{;} \PYG{n}{i} \PYG{o}{\textless{}}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{o}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{o}{)}
            \PYG{k}{if} \PYG{o}{(}\PYG{n}{i} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{3} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{)}
                \PYG{n}{count} \PYG{o}{+}\PYG{o}{=} \PYG{n}{i}\PYG{o}{;}
        \PYG{k}{return} \PYG{n}{count}\PYG{o}{;}
    \PYG{o}{\PYGZcb{}}

    \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{int} \PYG{n+nf}{while\PYGZus{}loop}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{count} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{;}
        \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{;}
        \PYG{k}{while} \PYG{o}{(}\PYG{n}{i} \PYG{o}{\textless{}}\PYG{o}{=} \PYG{l+m+mi}{100}\PYG{o}{)} \PYG{o}{\PYGZob{}}
            \PYG{k}{if} \PYG{o}{(}\PYG{n}{i} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{3} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{)}
                \PYG{n}{count} \PYG{o}{+}\PYG{o}{=} \PYG{n}{i}\PYG{o}{;}
            \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n}{count}\PYG{o}{;}
    \PYG{o}{\PYGZcb{}}

    \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{int} \PYG{n+nf}{do\PYGZus{}while\PYGZus{}loop}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{count} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{;}
        \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{;}
        \PYG{k}{do} \PYG{o}{\PYGZob{}}
            \PYG{k}{if} \PYG{o}{(}\PYG{n}{i} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{3} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{)}
                \PYG{n}{count} \PYG{o}{+}\PYG{o}{=} \PYG{n}{i}\PYG{o}{;}
            \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}} \PYG{k}{while} \PYG{o}{(}\PYG{n}{i} \PYG{o}{\textless{}}\PYG{o}{=} \PYG{l+m+mi}{100}\PYG{o}{)}\PYG{o}{;}
        \PYG{k}{return} \PYG{n}{count}\PYG{o}{;}
    \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

------Result--------

\begin{Verbatim}[commandchars=@\[\]]
for迴圈1到100間3的倍數總合為1683
while迴圈1到100間3的倍數總合為1683
do-while迴圈1到100間3的倍數總合為1683
\end{Verbatim}


\section{遞迴}
\label{java_loop:id4}\begin{itemize}
\item {} 
遞迴是一個相當獨特，對訓練邏輯思考很有助益的程式設計方式，為了能循序漸進的闡述遞迴程式的撰寫，在本節中，我們將以 String 資料型態當作程式的輸入資料，並以 1 來表示 boolean 的 true；而以 0 來表示 boolean 的 false。\textless{}br\textgreater{}

\item {} 
我們需要使用 Integer.parseInt(\textless{}String Variable\textgreater{}) 將 String 型態的資料轉換為 int 型態的資料。其轉換過後的值如果 == 1，則代表 true；如果 != 1，則代表 fasle。

\end{itemize}

:{[}註{]} Java 的每一個 primitive type 都有一個與之對應的 reference type 或類別，例如：int 與 Integer。parseInt 則是 Integer 的一個類別方法。Java 這麼設計的原因，會在《Java 物件導向程式設計》中的「泛型與 Collection」部分說明。


\subsection{簡易的遞迴程序}
\label{java_loop:id5}
以下是呼叫 and2 的範例：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{and2}\PYG{o}{(}\PYG{l+s}{"11"}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;} \PYG{c+c1}{//=\textgreater{} true}
\PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{and2}\PYG{o}{(}\PYG{l+s}{"10"}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;} \PYG{c+c1}{//=\textgreater{} false}
\PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{and2}\PYG{o}{(}\PYG{l+s}{"01"}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;} \PYG{c+c1}{//=\textgreater{} false}
\PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{and2}\PYG{o}{(}\PYG{l+s}{"00"}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;} \PYG{c+c1}{//=\textgreater{} false}
\end{Verbatim}

and2 的特性是，它的參數中的兩個資料值都要是 1 結果才是 true，要不然結果就是 false。

現在我們試著將 and2 的功能擴充，並將擴充後的方法命名為 allTrue。而 allTrue 可以判斷一個 string 中的值是否都是 true，這個 string 可以有不止兩個資料值。以下是呼叫 allTrue 的範例：

\begin{Verbatim}[commandchars=@\[\]]
System.out.println(allTrue(""));      =@textgreater[] true  輸入參數中沒有一個false，所以結果是true。
System.out.println(allTrue("111"));   =@textgreater[] true
System.out.println(allTrue("1111"));  =@textgreater[] true
System.out.println(allTrue("11010")); =@textgreater[] false
\end{Verbatim}

以下是 allTrue 的寫法：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Recursive} \PYG{o}{\PYGZob{}}
    \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{args}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{allTrue}\PYG{o}{(}\PYG{l+s}{""}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}       \PYG{c+c1}{// =\textgreater{} true  輸入參數中沒有一個false的值，所以結果是true。}
        \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{allTrue}\PYG{o}{(}\PYG{l+s}{"111"}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}    \PYG{c+c1}{// =\textgreater{} true}
        \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{allTrue}\PYG{o}{(}\PYG{l+s}{"1111"}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}   \PYG{c+c1}{// =\textgreater{} true}
        \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{allTrue}\PYG{o}{(}\PYG{l+s}{"11010"}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}  \PYG{c+c1}{// =\textgreater{} false}
    \PYG{o}{\PYGZcb{}}

    \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{boolean} \PYG{n+nf}{allTrue}\PYG{o}{(}\PYG{n}{String} \PYG{n}{str}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{k}{if} \PYG{o}{(}\PYG{n}{str}\PYG{o}{.}\PYG{n+na}{equals}\PYG{o}{(}\PYG{l+s}{""}\PYG{o}{)}\PYG{o}{)}
            \PYG{k}{return} \PYG{k+kc}{true}\PYG{o}{;}
        \PYG{k}{else} \PYG{n+nf}{if} \PYG{o}{(}\PYG{n}{Integer}\PYG{o}{.}\PYG{n+na}{parseInt}\PYG{o}{(}\PYG{n}{str}\PYG{o}{.}\PYG{n+na}{substring}\PYG{o}{(}\PYG{l+m+mi}{0}\PYG{o}{,} \PYG{l+m+mi}{1}\PYG{o}{)}\PYG{o}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{1} \PYG{o}{)}
            \PYG{k}{return} \PYG{n+nf}{allTrue}\PYG{o}{(}\PYG{n}{str}\PYG{o}{.}\PYG{n+na}{substring}\PYG{o}{(}\PYG{l+m+mi}{1}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
        \PYG{k}{else}
            \PYG{k}{return} \PYG{k+kc}{false}\PYG{o}{;}
    \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}
\begin{itemize}
\item {} 
Integer.parseInt()：將 () 裡的 string 由 String 型態轉換為 int 型態，以提供 if 來判斷其為 true(== 1) 或 false(!= 1)。

\item {} 
str.substring(0, 1)：取出 str 字串變數中的第 0 個位置（index）至第 1 個位置（index）間的資料。（例如：''1234''  =\textgreater{}  ``1''）

\item {} 
str.substring(1)：取出 str 字串變數中第 1 個位置以後的資料。（例如：''1234''  =\textgreater{}  ``234''）

\end{itemize}

allTrue(``111'') ; 的執行過程可 trace 如下：

\begin{Verbatim}[commandchars=@\[\]]
   allTrue("111")
=@textgreater[] allTrue("11")
=@textgreater[] allTrue("1")
=@textgreater[] allTrue("")
=@textgreater[] true
\end{Verbatim}

allTrue(``1101'') ; 的執行過程可 trace 如下：

\begin{Verbatim}[commandchars=@\[\]]
   allTrue("1101")
=@textgreater[] allTrue("101")
=@textgreater[] allTrue("01")
=@textgreater[] false
\end{Verbatim}

觀察 allTrue 這個程序以及它的執行過程，我們發現：
\begin{enumerate}
\item {} 
allTrue 內有三個執行的可能（if 條件判斷的三個條件情況）。

\item {} 
其中一行呼叫 allTrue 自己。這個呼叫自己的遞迴呼叫，傳入少了頭一筆資料值的 String(str.substring(1))。另外兩行沒有遞迴呼叫，而程式執行到這兩行之後便傳回 true 或 false，然後結束。

\item {} 
if 條件判斷式，控制程式執行哪個式子。

\item {} 
allTrue 這個程式的輸出入型態是：String -\textgreater{} boolean，也就是傳入一個 String、傳出一個布林值的意思。

\end{enumerate}

一般而言，遞迴程式都有類似的模式：
\begin{enumerate}
\item {} 
有終止條件（termination condition）如：str.equals(``'')、n == 0。

\item {} 
有遞迴呼叫，而遞迴呼叫所傳入的資料一定會趨近終止條件（例如使用 substring(1) 使 string 愈來愈縮短）。

\end{enumerate}

這很合理，因為這樣程式才能結束。

這個單元的練習都是 String -\textgreater{} boolean 型態的程序。
我們還會在後續的單元，陸續的介紹遞迴程式的其他型式。
另外，在撰寫程式的過程中，最簡單的除錯工具是把變數的值印出來。
System.out.println(\textless{}expression\textgreater{}) 與 System.out.println() 是可以顯示一個式子的傳回值與換行的兩個程序：

執行以上的程式碼會列印與傳回以下的內容：

\begin{Verbatim}[commandchars=@\[\]]
str=111
str=11
str=1
str=
true
\end{Verbatim}

前面 4 行與最後 1 行分別顯示了每次呼叫 allTrue 的輸入參數的值與最後的執行結果。


\subsection{累計答案值的遞迴程序}
\label{java_loop:id6}
上一單元我們練習了幾個傳回 true 或 false 的程序。
這些題目的答案不需要經過累計，例如：累加、累乘、或累積成字串的過程。
這個單元我們將練習需要經過累計才能計算出答案的遞迴程序。

假設我們需要撰寫一個能夠計算一個 string 中有幾個 true 的程序。我們將這個程序命名為 countTrue：

\begin{Verbatim}[commandchars=@\[\]]
countTrue("");     =@textgreater[] 0
countTrue("1101"); =@textgreater[] 3
\end{Verbatim}

很顯然的，在程序執行的過程中如果遇到 1(true) 則需要將 1 加入結果之中。寫法如下：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Recursive} \PYG{o}{\PYGZob{}}
    \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{args}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{countTrue}\PYG{o}{(}\PYG{l+s}{""}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}       \PYG{c+c1}{// =\textgreater{} 0  輸入參數中沒有一個false的值，所以結果是0。}
        \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{countTrue}\PYG{o}{(}\PYG{l+s}{"1"}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}      \PYG{c+c1}{// =\textgreater{} 1}
        \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{countTrue}\PYG{o}{(}\PYG{l+s}{"01"}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}     \PYG{c+c1}{// =\textgreater{} 1}
        \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{countTrue}\PYG{o}{(}\PYG{l+s}{"101"}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}    \PYG{c+c1}{// =\textgreater{} 2}
        \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{countTrue}\PYG{o}{(}\PYG{l+s}{"1101"}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}   \PYG{c+c1}{// =\textgreater{} 3}
    \PYG{o}{\PYGZcb{}}

    \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{int} \PYG{n+nf}{countTrue}\PYG{o}{(}\PYG{n}{String} \PYG{n}{str}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{k}{if} \PYG{o}{(}\PYG{n}{str}\PYG{o}{.}\PYG{n+na}{equals}\PYG{o}{(}\PYG{l+s}{""}\PYG{o}{)}\PYG{o}{)}
            \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{o}{;}
        \PYG{k}{else} \PYG{n+nf}{if} \PYG{o}{(}\PYG{n}{Integer}\PYG{o}{.}\PYG{n+na}{parseInt}\PYG{o}{(}\PYG{n}{str}\PYG{o}{.}\PYG{n+na}{substring}\PYG{o}{(}\PYG{l+m+mi}{0}\PYG{o}{,} \PYG{l+m+mi}{1}\PYG{o}{)}\PYG{o}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{)}  \PYG{c+c1}{// 1(true)}
            \PYG{k}{return} \PYG{l+m+mi}{1} \PYG{o}{+} \PYG{n}{countTrue}\PYG{o}{(}\PYG{n}{str}\PYG{o}{.}\PYG{n+na}{substring}\PYG{o}{(}\PYG{l+m+mi}{1}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
        \PYG{k}{else}                                                 \PYG{c+c1}{// 0(false)}
            \PYG{k}{return} \PYG{n+nf}{countTrue}\PYG{o}{(}\PYG{n}{str}\PYG{o}{.}\PYG{n+na}{substring}\PYG{o}{(}\PYG{l+m+mi}{1}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
    \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}
\begin{description}
\item[{我們可以追蹤這個程式是怎麼執行的： ::}] \leavevmode
　 countTrue(``'');         ``''使str.equals(``'')成立因此傳回0
=\textgreater{} 0
\begin{quote}

CountTrue(``1'');        ``1''使(Integer.parseInt(str.substring(0, 1)) == 1)成立因此傳回1
\end{quote}

=\textgreater{} (1 + countTrue(``'');)
=\textgreater{} (1 + 0)
=\textgreater{} 1
\begin{quote}

countTrue(``01'');       ``01''使else成立因此傳回1
\end{quote}

=\textgreater{} countTrue(``1'');
=\textgreater{} 1
\begin{quote}

countTrue(``101'');      ``101''使(Integer.parseInt(str.substring(0, 1)) == 1)成立因此傳回2
\end{quote}

=\textgreater{} (1 + countTrue(``01'');
=\textgreater{} (1 + 1)
=\textgreater{} 2

\end{description}

接下來，我們可以追蹤將一個有四個資料值的 string 傳入 countTrue 的執行狀況：

\begin{Verbatim}[commandchars=@\[\]]
   countTrue("1101");
=@textgreater[] (1 + countTrue("101");)
=@textgreater[] (1 + (1 + countTrue("01");))
=@textgreater[] (1 + (1 + countTrue("1");))
=@textgreater[] (1 + (1 + (1 + countTrue("");)))
=@textgreater[] (1 + (1 + (1 + 0)))
=@textgreater[] 3
\end{Verbatim}

另外，countTrue 的型態是： String -\textgreater{} int 。


\subsection{將遞迴程序轉換成迴圈程序}
\label{java_loop:id7}\begin{enumerate}
\item {} 
階乘（factorial）是一個常見的遞迴程序的範例。如果「!」代表階乘的符號，則

\begin{Verbatim}[commandchars=@\[\]]
0! = 1
N! = N * (N – 1)!
\end{Verbatim}

\item {} 
加總（sum）是計算一個 string 變數內數字和的範例。

\begin{Verbatim}[commandchars=@\[\]]
例如：sum("1234")  =@textgreater[]  10
\end{Verbatim}

\end{enumerate}

在這一個單元，我們將以階乘（factorial）與加總（Sum）兩個程式為範例，說明如何將一個遞迴程式逐步的改寫成迴圈程式。


\subsubsection{內涵式遞迴}
\label{java_loop:id8}
階乘函數可以用 Java 寫成如下的程式碼，我們將之命名為 factorial：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kd}{class}  \PYG{n+nc}{Recursive} \PYG{o}{\PYGZob{}}
    \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{args}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{factorial}\PYG{o}{(}\PYG{l+m+mi}{3}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
    \PYG{o}{\PYGZcb{}}

    \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{int} \PYG{n+nf}{factorial}\PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{n}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{k}{if} \PYG{o}{(}\PYG{n}{n} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{)}
            \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{o}{;}
        \PYG{k}{else}
            \PYG{k}{return} \PYG{n}{n} \PYG{o}{*} \PYG{n}{factorial}\PYG{o}{(}\PYG{n}{n} \PYG{o}{-} \PYG{l+m+mi}{1}\PYG{o}{)}\PYG{o}{;}
    \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

Trace

\begin{Verbatim}[commandchars=@\[\]]
   factorial(3)
=@textgreater[] return n * factorial(n - 1);   // n=3
=@textgreater[] return 3 * factorial(2);
=@textgreater[] return 3 * (n * factorial(n - 1));   // n=2
=@textgreater[] return 3 * (2 * factorial(1));
=@textgreater[] return 3 * (2 * (n * factorial(n - 1)));   // n=1
=@textgreater[] return 3 * (2 * (1 * factorial(0)));
=@textgreater[] return 3 * (2 * (1 * 1));   // n=0
=@textgreater[] return 3 * (2 * (1 * 1));
=@textgreater[] 6
\end{Verbatim}

觀察以上的執行狀況，呼叫 factorial 的遞迴呼叫是內涵(embedded)在乘法算式 (n * ...) 之內。而程式的執行結果是在最後一個遞迴呼叫 factorial(0) 完成後才依序累乘 (3 * (2 * (1 * 1))) 而得的。這種類型的遞迴程序稱為內涵式遞迴（embedded recursion）。

加總涵式 sum 的寫法如下：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Recursive} \PYG{o}{\PYGZob{}}
    \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{args}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{sum}\PYG{o}{(}\PYG{l+s}{"1234"}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
    \PYG{o}{\PYGZcb{}}

    \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{int} \PYG{n+nf}{sum}\PYG{o}{(}\PYG{n}{String} \PYG{n}{str}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{k}{if} \PYG{o}{(}\PYG{n}{str}\PYG{o}{.}\PYG{n+na}{equals}\PYG{o}{(}\PYG{l+s}{""}\PYG{o}{)}\PYG{o}{)}
            \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{o}{;}
        \PYG{k}{else}
            \PYG{k}{return}  \PYG{n}{Integer}\PYG{o}{.}\PYG{n+na}{parseInt}\PYG{o}{(}\PYG{n}{str}\PYG{o}{.}\PYG{n+na}{substring}\PYG{o}{(}\PYG{l+m+mi}{0}\PYG{o}{,} \PYG{l+m+mi}{1}\PYG{o}{)}\PYG{o}{)} \PYG{o}{+} \PYG{n}{sum}\PYG{o}{(}\PYG{n}{str}\PYG{o}{.}\PYG{n+na}{substring}\PYG{o}{(}\PYG{l+m+mi}{1}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
    \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

Trace

\begin{Verbatim}[commandchars=@\[\]]
   Sum("1234")
=@textgreater[] return Integer.parseInt(str.substring(0, 1)) + sum(str.substring(1));   // str="1234"
=@textgreater[] return 1 + sum("234");
=@textgreater[] return 1 + (Integer.parseInt(str.substring(0, 1)) + sum(str.substring(1)));   // str="234"
=@textgreater[] return 1 + (2 + sum("34"));
=@textgreater[] return 1 + (2 + (Integer.parseInt(str.substring(0, 1)) + sum(str.substring(1))));   // str="34"
=@textgreater[] return 1 + (2 + (3 + sum("4")));
=@textgreater[] return 1 + (2 + (3 + (Integer.parseInt(str.substring(0, 1)) + sum(str.substring(1)))));   // str="4"
=@textgreater[] return 1 + (2 + (3 + (4 + sum(""))));
=@textgreater[] return 1 + (2 + (3 + (4 + (Integer.parseInt(str.substring(0, 1)) + sum(str.substring(1)))));   // str=""
=@textgreater[] return 1 + (2 + (3 + (4 + 0)));
=@textgreater[] 10
\end{Verbatim}

觀察以上的執行狀況，呼叫 sum 的遞迴呼叫也是內涵(embedded)在加總算式(Integer.parseInt(str.substring(0, 1)) + ...)之內。而程式的執行結果是在最後一個遞迴呼叫 sum(``'') 完成後才依序累加 (1 + (2 + (3 + (4 + 0)))) 而得的。這是內涵式遞迴的另一個例子。


\subsubsection{尾端式遞迴}
\label{java_loop:id9}
第二種形式的遞迴程序是尾端遞迴（tail recursion）。尾端遞迴的特色是遞迴呼叫沒有內涵在任何一個尚未執行完成的式子內。以下面的例子而言，呼叫 tail-fac 的遞迴呼叫雖然是在 if 之內，但是該 if 的條件判斷式已經執行完畢，所以是尾端遞迴。

Trace

\begin{Verbatim}[commandchars=@\[\]]
   tail-fac(3, 1)
=@textgreater[] tail-fac(2, 3)
=@textgreater[] tail-fac(1, 6)
=@textgreater[] tail-fac(0, 6)
=@textgreater[] 6
\end{Verbatim}

以上程序的執行狀況是「平的」。尾端遞迴在執行的過程中不會像內涵式遞迴累積一層又一層如同樓梯般的式子，原因是前面遞迴呼叫時所產生的區域變數區內的變數值，並不需要被保留，因此下一次遞迴呼叫的區域變數區可以直接的覆蓋上一次遞迴呼叫時所使用的區域變數區。

將內涵式遞迴程序轉換成尾端遞迴程序的技巧是增加傳入的參數。以 fac2 來說我們增加了一個能夠儲存累乘值的參數 m。增加這個參數後便不需要以累積乘法算式的方式來計算階乘的值了。

而尾端遞迴的加總函式 sum，也可以經由增加一個參數及改變遞迴的回傳值得到：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kd}{class}  \PYG{n+nc}{Recursive} \PYG{o}{\PYGZob{}}
    \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{args}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{tail}\PYG{o}{-}\PYG{n}{sum}\PYG{o}{(}\PYG{l+s}{"1234"}\PYG{o}{,} \PYG{l+m+mi}{0}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
    \PYG{o}{\PYGZcb{}}

    \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{int} \PYG{n}{tail}\PYG{o}{-}\PYG{n}{sum}\PYG{o}{(}\PYG{n}{String} \PYG{n}{str}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{n}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{k}{if} \PYG{o}{(}\PYG{n}{str}\PYG{o}{.}\PYG{n+na}{equals}\PYG{o}{(}\PYG{l+s}{""}\PYG{o}{)}\PYG{o}{)}
            \PYG{k}{return} \PYG{n}{n}\PYG{o}{;}
        \PYG{k}{else}
            \PYG{k}{return}  \PYG{n}{tail}\PYG{o}{-}\PYG{n}{sum}\PYG{o}{(}\PYG{n}{str}\PYG{o}{.}\PYG{n+na}{substring}\PYG{o}{(}\PYG{l+m+mi}{1}\PYG{o}{)}\PYG{o}{,} \PYG{o}{(}\PYG{n}{n} \PYG{o}{+} \PYG{n}{Integer}\PYG{o}{.}\PYG{n+na}{parseInt}\PYG{o}{(}\PYG{n}{str}\PYG{o}{.}\PYG{n+na}{substring}\PYG{o}{(}\PYG{l+m+mi}{0}\PYG{o}{,} \PYG{l+m+mi}{1}\PYG{o}{)}\PYG{o}{)}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
    \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

Trace

\begin{Verbatim}[commandchars=@\[\]]
   tail-sum("1234", 0)
=@textgreater[] tail-sum("234", 1)
=@textgreater[] tail-sum("34", 3)
=@textgreater[] tail-sum("4", 6)
=@textgreater[] tail-sum("", 10)
=@textgreater[] 10
\end{Verbatim}


\subsubsection{迴圈}
\label{java_loop:id10}
第三種計算階乘的方式是使用一般程式語言常常使用的「迴圈」。一個內涵式遞迴程序在轉換成尾端式遞迴程序後，便可以改寫成迴圈程式了。\textless{}br\textgreater{}

轉換的方式可以分成下面三個步驟：
\begin{enumerate}
\item {} 
將尾端式遞迴的終止條件內的條件判斷拉到迴圈的條件判斷內，並將它轉換成相反（Not）的條件判斷（加上 ! 或 !=）。

\item {} 
將尾端式遞迴的參數拉到迴圈內並改寫成設值運算式，但是要注意的是設值運算式的前後次序。

\item {} 
將尾端式遞迴的終止條件成立時的回傳值拉到迴圈的後面，讓程序結束後將結果值回傳回去。

\end{enumerate}

使用 whlile-loop 將尾端式遞迴轉換成一般的程式語言常常使用的「迴圈」。

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Recursive} \PYG{o}{\PYGZob{}}
    \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{args}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)}\PYG{o}{\PYGZob{}}
        \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{fac3}\PYG{o}{(}\PYG{l+m+mi}{3}\PYG{o}{,} \PYG{l+m+mi}{1}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
    \PYG{o}{\PYGZcb{}}

    \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{int} \PYG{n+nf}{fac3}\PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{n}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{m}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{k}{while} \PYG{o}{(}\PYG{n}{n} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{)} \PYG{o}{\PYGZob{}}
            \PYG{n}{m} \PYG{o}{=} \PYG{n}{m} \PYG{o}{*} \PYG{n}{n}\PYG{o}{;}
            \PYG{n}{n} \PYG{o}{=} \PYG{n}{n} \PYG{o}{-} \PYG{l+m+mi}{1}\PYG{o}{;}
            \PYG{c+c1}{// 注意：上兩行次序不可顛倒。}
        \PYG{o}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n}{m}\PYG{o}{;}
    \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

Trace

\begin{Verbatim}[commandchars=@\[\]]
   fac3(3, 1)
=@textgreater[] 6
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Recursive} \PYG{o}{\PYGZob{}}
    \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{args}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)}\PYG{o}{\PYGZob{}}
        \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{sum3}\PYG{o}{(}\PYG{l+s}{"1234"}\PYG{o}{,} \PYG{l+m+mi}{0}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
    \PYG{o}{\PYGZcb{}}

    \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{int} \PYG{n+nf}{sum3}\PYG{o}{(}\PYG{n}{String} \PYG{n}{str}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{n}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{k}{while} \PYG{o}{(}\PYG{o}{!}\PYG{n}{str}\PYG{o}{.}\PYG{n+na}{equals}\PYG{o}{(}\PYG{l+s}{""}\PYG{o}{)}\PYG{o}{)} \PYG{o}{\PYGZob{}}
            \PYG{n}{n} \PYG{o}{=} \PYG{n}{n} \PYG{o}{+} \PYG{n}{Integer}\PYG{o}{.}\PYG{n+na}{parseInt}\PYG{o}{(}\PYG{n}{str}\PYG{o}{.}\PYG{n+na}{substring}\PYG{o}{(}\PYG{l+m+mi}{0}\PYG{o}{,} \PYG{l+m+mi}{1}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
            \PYG{n}{str} \PYG{o}{=} \PYG{n}{str}\PYG{o}{.}\PYG{n+na}{substring}\PYG{o}{(}\PYG{l+m+mi}{1}\PYG{o}{)}\PYG{o}{;}
            \PYG{c+c1}{// 注意：上兩行次序不可顛倒}
        \PYG{o}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n}{n}\PYG{o}{;}
    \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

Trace

\begin{Verbatim}[commandchars=@\[\]]
   sum3("1234", 0)
=@textgreater[] 10
\end{Verbatim}

同樣也可以使用 Java 語言的 for Loop 來將尾端式遞迴轉換成一般的程式語言常常使用的「迴圈」。

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Recursive} \PYG{o}{\PYGZob{}}
    \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{args}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)}\PYG{o}{\PYGZob{}}
        \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{fac3}\PYG{o}{(}\PYG{l+m+mi}{3}\PYG{o}{,} \PYG{l+m+mi}{1}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
    \PYG{o}{\PYGZcb{}}

    \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{int} \PYG{n+nf}{fac3}\PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{n}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{m}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{k}{for} \PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{i}\PYG{o}{=}\PYG{n}{m}\PYG{o}{;} \PYG{n}{i}\PYG{o}{\textless{}}\PYG{o}{=}\PYG{n}{n}\PYG{o}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{o}{)}
            \PYG{n}{m} \PYG{o}{=} \PYG{n}{m} \PYG{o}{*} \PYG{n}{i}\PYG{o}{;}
        \PYG{k}{return} \PYG{n}{r}\PYG{o}{;}
    \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

Trace

\begin{Verbatim}[commandchars=@\[\]]
   fac(3, 1)
=@textgreater[] 6
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Recursive} \PYG{o}{\PYGZob{}}
    \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{args}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)}\PYG{o}{\PYGZob{}}
        \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{sum3}\PYG{o}{(}\PYG{l+s}{"1234"}\PYG{o}{,} \PYG{l+m+mi}{0}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
    \PYG{o}{\PYGZcb{}}

    \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{int} \PYG{n+nf}{sum3}\PYG{o}{(}\PYG{n}{String} \PYG{n}{str}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{n}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{k}{for} \PYG{o}{(}\PYG{o}{;} \PYG{o}{!}\PYG{n}{str}\PYG{o}{.}\PYG{n+na}{equals}\PYG{o}{(}\PYG{l+s}{""}\PYG{o}{)}\PYG{o}{;} \PYG{n}{str} \PYG{o}{=} \PYG{n}{str}\PYG{o}{.}\PYG{n+na}{substring}\PYG{o}{(}\PYG{l+m+mi}{1}\PYG{o}{)}\PYG{o}{)}
            \PYG{n}{n} \PYG{o}{=} \PYG{n}{n} \PYG{o}{+} \PYG{n}{Integer}\PYG{o}{.}\PYG{n+na}{parseInt}\PYG{o}{(}\PYG{n}{str}\PYG{o}{.}\PYG{n+na}{substring}\PYG{o}{(}\PYG{l+m+mi}{0}\PYG{o}{,} \PYG{l+m+mi}{1}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
        \PYG{k}{return} \PYG{n}{n}\PYG{o}{;}
    \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

Trace

\begin{Verbatim}[commandchars=@\[\]]
   sum3("1234", 0)
=@textgreater[] 10
\end{Verbatim}


\chapter{實例、實例變數與實例方法}
\label{java_object::doc}\label{java_object:id1}
Java 是一個物件導向程式語言。
物件導向的基本觀念是讓程式可以描述、
建構及處理真實世界中所看到的物件並設計它們之間的層次關係。
例如：Exam 可以有 EnglishExam、ChineseExam 兩個副屬的種類。
而一次 EnglishExam 又可以有任意數量的考生應考，
其中每一份考卷中都可以有考生姓名與成績的資料。
這時 Exam、EnglishExam 及 ChineseExam 便很適合設計成類別，
而一份英文考試的考卷便可以用 EnglishExam 這個類別所生成的實例（instance or object）來代表。

一個類別可以使用 \textbf{new} 指令來產生實例。
一個 Java 的程式可以由許多個有層次關係的類別構成，
這個層次關係描述這些類別間的 \textbf{繼承關係} 。
這一類的例子在真實世界中不勝枚舉，
舉例來說：如果「哺乳類」是一個類別，
那麼「人類」則可以是「哺乳類」的一個 \textbf{「子類別」} （subclass or subtype），
相對的「哺乳類」也可以是「人類」的 \textbf{「父類別」} （superclass or supertype）。
而某一個人「張三」便是「人類」的一個 \textbf{「實例」} 。

以「張三」這個實例來說，
他的身高、體重、性別等資料都可以存放在這個實例的「實例變數」中，
而「張三」能「跑」能「跳」，則可以是它的「實例方法」。
簡單的說：「類別（class）」可以用 new 來產生「實例（instance）」，
而「實例」可以包含「實例變數」與「實例方法」。其中「實例變數」負責資料的儲存，而「實例方法」則負責資料的處理：

Image:image001.jpg

註：Java 原文將「實例變數」稱為 non-static field；而將「實例方法」稱為 non-static method。為了與中文的譯名一致，這份講義將以 instance variable 與 instance method 稱之。同樣的，這份講義亦將以 class method 代替原文的 static method，以 class variable 代替原文的 static variable。


\section{何謂實例（Instance）}
\label{java_object:instance}
實例（instance）是由 new 所產生的某個類別的實作，
也稱為物件（object）。
一個 class 可以生成多個實例，
而且每個實例都擁有一份自己的實例變數。
以下圖為例：class A 宣告了三個實例變數 x，y 與 z，
而每個實例都為這三個實例變數配置了記憶體以儲存他們的值。

Image:newImage005.jpg

「實例變數」及「實例方法」與用於設計結構化程式的「類別變數」及「類別方法」的主要差異是：
\begin{enumerate}
\item {} 
類別變數或類別方法以 static 起始，他們在程式開始執行時即實質的存在，所以不需要產生實例，即可使用。

\item {} 
實例變數或實例方法沒有 static 起始，他們一定要等到實例產生之後才有實質的存在，因此需要實例，才可以使用。

\end{enumerate}

在後續的圖例中，我們將使用「淡的顏色」來表示「沒有記憶體、沒有實質存在的變數或方法」，並以「鮮明的顏色」來表示「有記憶體、有實質存在的變數或方法」以區別它們的差異：

Image:Picture.jpg

以下是一個藉由呼叫實例方法將實例變數的值傳回並輸出的範例：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{class} \PYG{n+nc}{Book} \PYG{o}{\PYGZob{}}
  \PYG{n}{String} \PYG{n}{name} \PYG{o}{=} \PYG{l+s}{"Sun"}\PYG{o}{;}
  \PYG{n}{String} \PYG{n+nf}{getName}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{name}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}

\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Ex2} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{argv}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{n}{Book} \PYG{n}{b1} \PYG{o}{=} \PYG{k}{new} \PYG{n}{Book}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
    \PYG{n}{Book} \PYG{n}{b2} \PYG{o}{=} \PYG{k}{new} \PYG{n}{Book}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
    \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"Name of b1:"} \PYG{o}{+} \PYG{n}{b1}\PYG{o}{.}\PYG{n+na}{getName}\PYG{o}{(}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
    \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"Name of b2:"} \PYG{o}{+} \PYG{n}{b2}\PYG{o}{.}\PYG{n+na}{getName}\PYG{o}{(}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

執行結果：

\begin{Verbatim}[commandchars=@\[\]]
Name of b1:Sun
Name of b2:Sun
\end{Verbatim}

Media:Ex2.swf\textbar{}觀看執行過程及詳細解說{]}{]}


\section{Class Method 與 Instance Method 的差異}
\label{java_object:class-method-instance-method}
接下來的這個範例，說明了類別方法與實例方法的差異：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{class} \PYG{n+nc}{A} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{static} \PYG{n}{String} \PYG{n+nf}{c1}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{k}{return} \PYG{l+s}{"class method不需new就可使用"}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{n}{String} \PYG{n+nf}{c2}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{k}{return} \PYG{l+s}{"instance method需new才可使用"}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Ex3} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{argv}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"=呼叫class method="}\PYG{o}{)}\PYG{o}{;}
    \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{A}\PYG{o}{.}\PYG{n+na}{c1}\PYG{o}{(}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
    \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"=呼叫instance method="}\PYG{o}{)}\PYG{o}{;}
    \PYG{c+c1}{//System.out.println(A.c2()); =\textgreater{}error}
    \PYG{n}{A} \PYG{n}{a} \PYG{o}{=} \PYG{k}{new} \PYG{n}{A}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
    \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{a}\PYG{o}{.}\PYG{n+na}{c2}\PYG{o}{(}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

執行結果：

\begin{Verbatim}[commandchars=@\[\]]
=呼叫類別方法=
class method不需new就可使用
=呼叫實例方法=
instance method需new才可使用
\end{Verbatim}

Media:Ex3.swf\textbar{}觀看執行過程及詳細解說{]}{]}


\section{Class Variable 與 Instance Variable 的差異}
\label{java_object:class-variable-instance-variable}
這個範例繼續說明了類別變數與實例變數之間的差異:
\begin{quote}
\begin{description}
\item[{class A \{}] \leavevmode
static int a = 0;
int b = 5;
int getA() \{
\begin{quote}

return a;
\end{quote}

\}
void setA(int value) \{
\begin{quote}

a = value;
\end{quote}

\}
int getB() \{
\begin{quote}

return b;
\end{quote}

\}
void setB(int value) \{
\begin{quote}

b = value;
\end{quote}

\}

\end{description}

\}
\begin{description}
\item[{public class Ex4 \{}] \leavevmode\begin{description}
\item[{public static void main(String argv{[}{]}) \{}] \leavevmode
A obj1 = new A();
A obj2 = new A();
obj1.setA(1);
obj1.setB(20);
obj2.setA(2);
obj2.setB(30);
System.out.println(``a of obj1:'' + obj1.getA());
System.out.println(``a of obj2:'' + obj2.getA());
System.out.println(``b of obj1:'' + obj1.getB());
System.out.println(``b of obj2:'' + obj2.getB());

\end{description}

\}

\end{description}

\}
\end{quote}

執行結果：

\begin{Verbatim}[commandchars=@\[\]]
a of obj1:2
a of obj2:2
b of obj1:20
b of obj2:30
\end{Verbatim}

Media:Ex4.swf\textbar{}觀看執行過程

由於 a 是類別變數，只有一個儲存值，而這個值是共享的；
b 則是實例變數，所以每個實例都有一個 b 的儲存值，而它們的值也可以不一樣。

類別變數、區域變數與實例變數的不同之處，透過它們在 Java 程式內的 \textbf{可見範圍（scope）} 與佔用記憶體
的 \textbf{起始時間與釋放時間（extent）} 的不同，可以更明確的區分出來：
\begin{enumerate}
\item {} 
\textbf{類別變數} ：每一個 class 都有一個命名空間（name space），
因此兩個 class 若有同名的變數、方法也不用擔心彼此衝突。
這便好像將一個程式的記憶體劃分成好幾個區域，
而每一個 class 都配屬了一個區域。
\textbf{隸屬於某一 class 的類別變數} 的有效時間是從程式開始執行，
一直到程式結束：

\end{enumerate}
\begin{itemize}
\item {} 
extent：從程式開始執行，一直到程式結束；

\item {} 
scope：以 public、private、protect 宣告類別變數的可見範圍。

\end{itemize}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
\textbf{區域變數} ：於方法執行時才存在，方法執行完畢後便消失。
這種變數的值是存放在記憶體中稱為堆疊（stack）的一塊區域上。

\end{enumerate}
\begin{itemize}
\item {} 
extent：從方法執行時開始，到方法結束時為止。

\item {} 
scope：該變數所屬，由 \{ \} 區隔的區塊（block）中。

\end{itemize}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
\textbf{實例變數} ：實例變數是用來的儲存實例中資料的變數，
實例（instance）的另一個名稱是物件（object）。
例如在一個處理學生資料的程式中，某一學生的資料，
可以存放在 name、id、score 等幾個 \textbf{隸屬於這個物件的實例變數} 中。
實例是存放在記憶體中稱為堆積堆（heap）的一塊區域上。

\end{enumerate}
\begin{itemize}
\item {} 
extent：從一個實例被造（new），直到它的記憶體被回收（garbage collect）時為止。

\item {} 
scope：以 public、private、protect 宣告實例變數的可見範圍。

\end{itemize}


\section{實例方法中的this是什麼？}
\label{java_object:this}
這個單元將會以數個範例，將一個類別方法，轉換成作用相同的實例方法，
以更深入的闡述在實例方法中常常用到的this這個保留字的意義。

在下面的範例中 ee 是一個用 new 生成的 EnglishExam 物件，
這個物件的三個實例變數分別被設值成 3, 4, 5，然後傳入 englishScore 這個類別方法中：
\begin{quote}
\begin{description}
\item[{class EnglishExam \{}] \leavevmode
public int vocab, grammar, listen;
public static int englishScore(int v, int g, int l) \{
\begin{quote}

return v + g + l;
\end{quote}

\}

\end{description}

\}
\begin{description}
\item[{public class Demo \{}] \leavevmode\begin{description}
\item[{public static void main(String argv{[}{]}) \{}] \leavevmode
EnglishExam ee = new EnglishExam();
ee.vocab = 3;
ee.grammar = 4;
ee.listen = 5;
System.out.print(``The score of the exam is '');
System.out.println(EnglishExam.englishScore(ee.vocab, ee.grammar, ee.listen));

\end{description}

\}

\end{description}

\}
\end{quote}

執行結果：

\begin{Verbatim}[commandchars=@\[\]]
The score of the exam is 12
\end{Verbatim}

englishScore 雖然是一個類別方方法，然而傳入這個方法的三個參數，
實際上是 ee 的三個實例變數的值。
那何必這麼麻煩？直接將 ee 傳入 englishScore 不是更簡潔嗎？以下即是將上例改寫後的版本：
\begin{quote}
\begin{description}
\item[{class EnglishExam \{}] \leavevmode\begin{description}
\item[{public int vocab, grammar, listen;}] \leavevmode
public static int score(EnglishExam THIS) \{
return THIS.vocab + THIS.grammar + THIS.listen;

\end{description}

\}

\end{description}

\}
\begin{description}
\item[{public class Demo \{}] \leavevmode\begin{description}
\item[{public static void main(String argv{[}{]}) \{}] \leavevmode
EnglishExam ee = new EnglishExam();
ee.vocab = 3;
ee.grammar = 4;
ee.listen = 5;
System.out.print(``The score of the exam is '');
System.out.println(EnglishExam.score(ee));

\end{description}

\}

\end{description}

\}
\end{quote}

這個範例直接將 ee 傳入 score（原名是 englishScoer）中，
而 score 仍然是一個類別方法。在這個例子中我們使用：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{EnglishExam}\PYG{o}{.}\PYG{n}{score}\PYG{p}{(}\PYG{n}{ee}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

來呼叫score這個方法。如果我們將以上的呼叫改寫成：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{ee}\PYG{o}{.}\PYG{n}{score}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

並將 score 這個類別方法，改寫成實例方法:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{class} \PYG{n+nc}{EnglishExam} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n}{vocab}\PYG{o}{,} \PYG{n}{grammar}\PYG{o}{,} \PYG{n}{listen}\PYG{o}{;}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n+nf}{score}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{vocab} \PYG{o}{+} \PYG{n}{grammar} \PYG{o}{+} \PYG{n}{listen}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}

\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Demo} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{argv}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{n}{EnglishExam} \PYG{n}{ee} \PYG{o}{=} \PYG{k}{new} \PYG{n}{EnglishExam}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
    \PYG{n}{ee}\PYG{o}{.}\PYG{n+na}{vocab} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{o}{;} \PYG{n}{ee}\PYG{o}{.}\PYG{n+na}{grammar} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{o}{;} \PYG{n}{ee}\PYG{o}{.}\PYG{n+na}{listen} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{o}{;}
    \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{print}\PYG{o}{(}\PYG{l+s}{"The score of the exam is "}\PYG{o}{)}\PYG{o}{;}
    \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{ee}\PYG{o}{.}\PYG{n+na}{score}\PYG{o}{(}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

那麼執行的結果仍然是：

\begin{Verbatim}[commandchars=@\[\]]
The score of the exam is 12
\end{Verbatim}

由此可見，一個 instance method 其實有一個隱藏的參數。
以上例而言是 ee，而任何在 score 方法中所用到的變數，
如果不是區域變數或是類別變數，便會被當成是該隱藏性參數（ee）的實例變數。

如果我們需要支援 ChineseExam，那麼上面的程式可以進一步改寫如下：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{class} \PYG{n+nc}{EnglishExam} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n}{vocab}\PYG{o}{,} \PYG{n}{grammar}\PYG{o}{,} \PYG{n}{listen}\PYG{o}{;}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n+nf}{score}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{vocab} \PYG{o}{+} \PYG{n}{grammar} \PYG{o}{+} \PYG{n}{listen}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\PYG{k+kd}{class} \PYG{n+nc}{ChineseExam} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n}{word}\PYG{o}{,} \PYG{n}{sentence}\PYG{o}{,} \PYG{n}{composition}\PYG{o}{;}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n+nf}{score}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{word} \PYG{o}{+} \PYG{n}{sentence} \PYG{o}{+} \PYG{n}{composition}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Demo} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{argv}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{n}{EnglishExam} \PYG{n}{ee} \PYG{o}{=} \PYG{k}{new} \PYG{n}{EnglishExam}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
    \PYG{n}{ee}\PYG{o}{.}\PYG{n+na}{vocab} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{o}{;} \PYG{n}{ee}\PYG{o}{.}\PYG{n+na}{grammar} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{o}{;} \PYG{n}{ee}\PYG{o}{.}\PYG{n+na}{listen} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{o}{;}
    \PYG{n}{ChineseExam} \PYG{n}{cc} \PYG{o}{=} \PYG{k}{new} \PYG{n}{ChineseExam}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
    \PYG{n}{cc}\PYG{o}{.}\PYG{n+na}{word} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{;} \PYG{n}{cc}\PYG{o}{.}\PYG{n+na}{sentence} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{o}{;} \PYG{n}{cc}\PYG{o}{.}\PYG{n+na}{composition} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{o}{;}
    \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{print}\PYG{o}{(}\PYG{l+s}{"The score of the English exam is "}\PYG{o}{)}\PYG{o}{;}
    \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{ee}\PYG{o}{.}\PYG{n+na}{score}\PYG{o}{(}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
    \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{print}\PYG{o}{(}\PYG{l+s}{"The score of the Chinese exam is "}\PYG{o}{)}\PYG{o}{;}
    \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{cc}\PYG{o}{.}\PYG{n+na}{score}\PYG{o}{(}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

前面所提到的隱藏參數，可以使用 this 這個保留字來抓到。因此，上例也可以改寫成：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{class} \PYG{n+nc}{EnglishExam} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n}{vocab}\PYG{o}{,} \PYG{n}{grammar}\PYG{o}{,} \PYG{n}{listen}\PYG{o}{;}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n+nf}{score}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{k}{return} \PYG{k}{this}\PYG{o}{.}\PYG{n+na}{vocab} \PYG{o}{+} \PYG{k}{this}\PYG{o}{.}\PYG{n+na}{grammar} \PYG{o}{+} \PYG{k}{this}\PYG{o}{.}\PYG{n+na}{listen}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\PYG{k+kd}{class} \PYG{n+nc}{ChineseExam} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n}{word}\PYG{o}{,} \PYG{n}{sentence}\PYG{o}{,} \PYG{n}{composition}\PYG{o}{;}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n+nf}{score}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{k}{return} \PYG{k}{this}\PYG{o}{.}\PYG{n+na}{word} \PYG{o}{+} \PYG{k}{this}\PYG{o}{.}\PYG{n+na}{sentence} \PYG{o}{+} \PYG{k}{this}\PYG{o}{.}\PYG{n+na}{composition}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Demo} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{argv}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{n}{EnglishExam} \PYG{n}{ee} \PYG{o}{=} \PYG{k}{new} \PYG{n}{EnglishExam}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
    \PYG{n}{ee}\PYG{o}{.}\PYG{n+na}{vocab} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{o}{;} \PYG{n}{ee}\PYG{o}{.}\PYG{n+na}{grammar} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{o}{;} \PYG{n}{ee}\PYG{o}{.}\PYG{n+na}{listen} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{o}{;}
    \PYG{n}{ChineseExam} \PYG{n}{cc} \PYG{o}{=} \PYG{k}{new} \PYG{n}{ChineseExam}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
    \PYG{n}{cc}\PYG{o}{.}\PYG{n+na}{word} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{;} \PYG{n}{cc}\PYG{o}{.}\PYG{n+na}{sentence} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{o}{;} \PYG{n}{cc}\PYG{o}{.}\PYG{n+na}{composition} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{o}{;}
    \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{print}\PYG{o}{(}\PYG{l+s}{"The score of the English exam is "}\PYG{o}{)}\PYG{o}{;}
    \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{ee}\PYG{o}{.}\PYG{n+na}{score}\PYG{o}{(}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
    \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{print}\PYG{o}{(}\PYG{l+s}{"The score of the Chinese exam is "}\PYG{o}{)}\PYG{o}{;}
    \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{cc}\PYG{o}{.}\PYG{n+na}{score}\PYG{o}{(}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

this 的值是當使用一個實例呼叫一個實例方法（例如：ee.score()）時所傳入的隱藏性參數，
而這個隱藏性參數便是那個實例（即：ee）的地址。
因此，如果你在一個實例方法內更改一個實例變數的值時，那個實例變數的值便永遠被更改。

Java 可以使用 this 也可以不使用 this 來存取實例的變數或方法。
在後續的單元，我們為了說明的需要，有時會使用 this，有時不使用 this，來存取實例變數或呼叫實例方法。

實例方法也可以有其他參數，例如，以下便是將權重傳入並計算分數的例子：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{class} \PYG{n+nc}{EnglishExam} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n}{vocab}\PYG{o}{,} \PYG{n}{grammar}\PYG{o}{,} \PYG{n}{listen}\PYG{o}{;}
  \PYG{k+kd}{public} \PYG{k+kt}{double} \PYG{n+nf}{score}\PYG{o}{(}\PYG{k+kt}{double} \PYG{n}{wb}\PYG{o}{,} \PYG{k+kt}{double} \PYG{n}{wg}\PYG{o}{,} \PYG{k+kt}{double} \PYG{n}{wl}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{wb} \PYG{o}{*} \PYG{n}{vocab} \PYG{o}{+} \PYG{n}{wg} \PYG{o}{*} \PYG{n}{grammar} \PYG{o}{+} \PYG{n}{wl} \PYG{o}{*} \PYG{n}{listen}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Demo} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{argv}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{n}{EnglishExam} \PYG{n}{ee} \PYG{o}{=} \PYG{k}{new} \PYG{n}{EnglishExam}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
    \PYG{n}{ee}\PYG{o}{.}\PYG{n+na}{vocab} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{o}{;} \PYG{n}{ee}\PYG{o}{.}\PYG{n+na}{grammar} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{o}{;} \PYG{n}{ee}\PYG{o}{.}\PYG{n+na}{listen} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{o}{;}
    \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{print}\PYG{o}{(}\PYG{l+s}{"The score of the English exam is "}\PYG{o}{)}\PYG{o}{;}
    \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{ee}\PYG{o}{.}\PYG{n+na}{score}\PYG{o}{(}\PYG{l+m+mf}{0.2}\PYG{o}{,} \PYG{l+m+mf}{0.3}\PYG{o}{,} \PYG{l+m+mf}{0.5}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

在前面的單元中我們曾經使用 int, double 等型態的變數，
這種變數稱為 primitive type。
而 ee 的型態則是 EnglishExam，這種型態稱為 reference type。
一個 reference type 變數的初值是 null，代表沒有任何實例的地址被設成它的值。
Java 的字串屬於 String 類別，而字串也是 reference type 的一種。
一個變數如果是 primitive type，則它的地址中所存放的是數值本身。
如果一個變數是 reference type，則這個變數的地址內所存放的是一個指向一個實例的地址。
這個被指向的實例是放在 Java 自動化記憶體管理區內，
如果這個實例沒有被任何其他變數直接或間接的透過其他實例指到，
那麼 Java 的 garbage collector 便會在執行記憶體回收動作時將該實例的記憶體自動回收。

由於 Java 是一個「傳值呼叫」（call-by-value）的程式語言，
所以當一個方法被呼叫時，是變數的值被傳入方法中。
由於存放在 reference type 變數中的值，
實際上是地址，所以是地址被傳入被呼叫的方法內。
因此便會發生在程式執行中，同時有數個變數指向同一個被 reference 的實例。
而其中任何一個方法更改了那個實例的實例變數的值時，
其他使用這個實例的方法也會看到被改變的新值。


\chapter{實例的產生與封裝}
\label{java_encap::doc}\label{java_encap:id1}
在前面的章節中，我們曾經使用 new 來產生一個 EnglishExam 的實例，
然後個別的將這個實例的實例變數初始化。例如：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{EnglishExam} \PYG{n}{ee} \PYG{o}{=} \PYG{k}{new} \PYG{n}{EnglishExam}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
\PYG{n}{ee}\PYG{o}{.}\PYG{n+na}{vocab} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{o}{;}
\PYG{n}{ee}\PYG{o}{.}\PYG{n+na}{grammar} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{o}{;}
\PYG{n}{ee}\PYG{o}{.}\PYG{n+na}{listen} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{o}{;}
\end{Verbatim}

另一個達到同樣目的的方式是在類別內直接的初始化實例變數的值。例如：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{class} \PYG{n+nc}{EnglishExam} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n}{vocab} \PYG{o}{=} \PYG{l+m+mi}{6}\PYG{o}{,}
    \PYG{n}{grammar} \PYG{o}{=} \PYG{l+m+mi}{7}\PYG{o}{,}
    \PYG{n}{listen} \PYG{o}{=} \PYG{l+m+mi}{8}\PYG{o}{;}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n+nf}{score}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{vocab} \PYG{o}{+} \PYG{n}{grammar} \PYG{o}{+} \PYG{n}{listen}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

如果一個實例變數沒有初始化，那麼它的值是便會根據它的型態，
而設定成該型態的 default value。

Java 也支援使用一個類別的 \textbf{constructor（建構子）} 將實例變數的值初始化。
建構子與 class 同名，並且不需要定義 return type。
呼叫建構子之後會製造一個物件並將那個物件回傳。例如：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{class} \PYG{n+nc}{EnglishExam} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n}{vocab}\PYG{o}{,} \PYG{n}{grammar}\PYG{o}{,} \PYG{n}{listen}\PYG{o}{;}
  \PYG{n}{EnglishExam}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{n}{vocab} \PYG{o}{=} \PYG{l+m+mi}{6}\PYG{o}{;}
    \PYG{n}{grammar} \PYG{o}{=} \PYG{l+m+mi}{7}\PYG{o}{;}
    \PYG{n}{listen} \PYG{o}{=} \PYG{l+m+mi}{8}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n+nf}{score}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{vocab} \PYG{o}{+} \PYG{n}{grammar} \PYG{o}{+} \PYG{n}{listen}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}

\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Exem} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{args}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{n}{EnglishExam} \PYG{n}{ee} \PYG{o}{=} \PYG{k}{new} \PYG{n}{EnglishExam}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
    \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"The score of the exam is: "} \PYG{o}{+} \PYG{n}{ee}\PYG{o}{.}\PYG{n+na}{score}\PYG{o}{(}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

執行結果:

\begin{Verbatim}[commandchars=@\[\]]
The score of the exam is: 21
\end{Verbatim}

建構子也可以使用傳入的參數，將實例變數的值初始化。例如：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{class} \PYG{n+nc}{EnglishExam} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n}{vocab}\PYG{o}{,} \PYG{n}{grammar}\PYG{o}{,} \PYG{n}{listen}\PYG{o}{;}
  \PYG{n}{EnglishExam}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{n}{vocab} \PYG{o}{=} \PYG{l+m+mi}{6}\PYG{o}{;} \PYG{n}{grammar} \PYG{o}{=} \PYG{l+m+mi}{7}\PYG{o}{;} \PYG{n}{listen} \PYG{o}{=} \PYG{l+m+mi}{8}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{n}{EnglishExam}\PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{v}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{g}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{l}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{n}{vocab} \PYG{o}{=} \PYG{n}{v}\PYG{o}{;} \PYG{n}{grammar} \PYG{o}{=} \PYG{n}{g}\PYG{o}{;} \PYG{n}{listen} \PYG{o}{=} \PYG{n}{l}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n+nf}{score}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{vocab} \PYG{o}{+} \PYG{n}{grammar} \PYG{o}{+} \PYG{n}{listen}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}

\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Exam} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{args}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{n}{EnglishExam} \PYG{n}{ee} \PYG{o}{=} \PYG{k}{new} \PYG{n}{EnglishExam}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
    \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"The score of the first exam is: "} \PYG{o}{+} \PYG{n}{ee}\PYG{o}{.}\PYG{n+na}{score}\PYG{o}{(}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
    \PYG{n}{ee} \PYG{o}{=} \PYG{k}{new} \PYG{n}{EnglishExam}\PYG{o}{(}\PYG{l+m+mi}{7}\PYG{o}{,} \PYG{l+m+mi}{8}\PYG{o}{,} \PYG{l+m+mi}{9}\PYG{o}{)}\PYG{o}{;}
    \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"The score of the second exam is: "} \PYG{o}{+} \PYG{n}{ee}\PYG{o}{.}\PYG{n+na}{score}\PYG{o}{(}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

這時的執行結果是:

The score of the first exam is: 21
The score of the second exam is: 24

以上的程式有一個沒有參數的建構子，及一個三個參數的建構子。
如果一個類別內沒有定義建構子，那麼 Java 會自動提供一個沒有參數的建構子給這個類別。

Media:Ex9.swf\textbar{}觀看一個建構子範例的執行與解說


\section{Getter, Setter 及 Data Abstraction}
\label{java_encap:getter-setter-data-abstraction}
假設有一個 Exam 類別，
而這個類別有一個 minute 的實例變數，
而 e 則是一個 Exam 的實例。
那麼使用 e.minute 便可以直接的取用它的值，
然而 minute 卻必須宣告成 public。
另一個存取實例變數的方式是使用 getter 及 setter 方法，
這時程式設計師可以將 minute 宣告成 private，
並選擇性的將 getter 及 setter 設定成所需要的存取權限。
例如：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Exam} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{private} \PYG{k+kt}{int} \PYG{n}{minutes}\PYG{o}{;}
  \PYG{k+kd}{public} \PYG{n+nf}{Exam}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{n}{minutes} \PYG{o}{=} \PYG{l+m+mi}{80}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n+nf}{getMinutes}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{minutes}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

這時在其他的類別中若有一個 Exam 的實例 e，
便可以使用 getMinutes 取出 e.minutes 的值：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{e}\PYG{o}{.}\PYG{n}{getMinutes}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

使用 getter 方法的好處之一是，
能夠很容易的在取用實例變數的值時，
增加協助偵錯的程式碼：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Exam} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{private} \PYG{k+kt}{int} \PYG{n}{minutes}\PYG{o}{;}
  \PYG{k+kd}{public} \PYG{n+nf}{Exam}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{n}{minutes} \PYG{o}{=} \PYG{l+m+mi}{80}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n+nf}{getMinutes}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"Accessing minutes..."}\PYG{o}{)}\PYG{o}{;}
    \PYG{k}{return} \PYG{n}{minutes}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

setter 方法的作用也類似：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Exam} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{private} \PYG{k+kt}{int} \PYG{n}{minutes}\PYG{o}{;}
    \PYG{k+kd}{public} \PYG{n+nf}{Exam}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{n}{minutes} \PYG{o}{=} \PYG{l+m+mi}{80}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n+nf}{getMinutes}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{minutes}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{public} \PYG{k+kt}{void} \PYG{n+nf}{setMinutes}\PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{m}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"Setting minutes..."}\PYG{o}{)}\PYG{o}{;}
    \PYG{n}{minutes} \PYG{o}{=} \PYG{n}{m}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

然而 setter 方法不需要傳回值。因此 setMinutes 的傳回值的型態是void。

getter 與 setter 方法的另一個功用是，模擬不必真實的存在，
但是卻可以透過運算而得到的實例變數。例如：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Exam} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{private} \PYG{k+kt}{int} \PYG{n}{minutes}\PYG{o}{;}
  \PYG{k+kd}{public} \PYG{n+nf}{Exam}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{n}{minutes} \PYG{o}{=} \PYG{l+m+mi}{80}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n+nf}{getMinutes}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{minutes}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{public} \PYG{k+kt}{void} \PYG{n+nf}{setMinutes}\PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{m}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{n}{minutes} \PYG{o}{=} \PYG{n}{m}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n+nf}{getHours}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{minutes}\PYG{o}{/} \PYG{l+m+mf}{60.0}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{public} \PYG{k+kt}{void} \PYG{n+nf}{setHours}\PYG{o}{(}\PYG{k+kt}{double} \PYG{n}{h}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{n}{minutes} \PYG{o}{=} \PYG{o}{(}\PYG{k+kt}{int}\PYG{o}{)}\PYG{o}{(}\PYG{n}{h} \PYG{o}{*} \PYG{l+m+mi}{60}\PYG{o}{)}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

使用以上的 getHours 及 setHours 使得 Exam 好像多了 hours
這個其實並不存在的實例變數一般。

使用 getter 及 setter 方法，
可以在改變實例內資料的儲存方式後，
不用修改其他使用此資料的程式碼，
讓程式易於維護。
例如：hours 比 minutes 更常用時，
便可以將上面的範例，
更改成以 hours 來儲存，
以增加程式的效率：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Exam} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{private} \PYG{k+kt}{double} \PYG{n}{hours}\PYG{o}{;}
  \PYG{k+kd}{public} \PYG{n+nf}{Exam}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{n}{hours} \PYG{o}{=} \PYG{l+m+mf}{1.5}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n+nf}{getMinutes}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{k}{return} \PYG{o}{(}\PYG{k+kt}{int}\PYG{o}{)}\PYG{o}{(}\PYG{n}{hours} \PYG{o}{*} \PYG{l+m+mi}{60}\PYG{o}{)}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{public} \PYG{k+kt}{void} \PYG{n+nf}{setMinutes}\PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{m}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{n}{hours} \PYG{o}{=} \PYG{n}{m} \PYG{o}{/} \PYG{l+m+mf}{60.0}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{public} \PYG{k+kt}{double} \PYG{n+nf}{getHours}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{hours}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{public} \PYG{k+kt}{void} \PYG{n+nf}{setHours}\PYG{o}{(}\PYG{k+kt}{double} \PYG{n}{h}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{n}{hours} \PYG{o}{=} \PYG{n}{h}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

這時程式碼雖然做了更改，但是並不影響程式的其他部份。
如果沒有使用 getter 與 setter，類似的更動，
便需要將程式碼中所有存取 minutes 的地方全部做修改。例如：

\begin{Verbatim}[commandchars=@\[\]]
x.minutes           需要更改成     (int)(x.hours * 60)
(x.minutes / 60.0)  則需要更改成   x.hours
\end{Verbatim}

使用 getter 及 setter 方法，
間接的存取實例變數的程式設計方式稱為「資料抽象化」(data abstraction)。
應用資料抽象化的方式寫程式，有以下的好處：
\begin{enumerate}
\item {} 
程式碼容易再利用

\item {} 
程式碼容易瞭解

\item {} 
易於增加類別的功能

\item {} 
易於改進資料的儲存方式

\end{enumerate}


\chapter{繼承、抽象類別}
\label{java_abstract::doc}\label{java_abstract:id1}
假設我們要將前面的 EnglishExam 及 ChineseExam 增加一個 minutes 的實例變數。
那麼一個不好的方式是將這個實例變數分別的放入這兩個類別中：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{class} \PYG{n+nc}{EnglishExam} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n}{minutes}\PYG{o}{;}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n}{vocab}\PYG{o}{,} \PYG{n}{grammar}\PYG{o}{,} \PYG{n}{listen}\PYG{o}{;}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n+nf}{getMinutes}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{minutes}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n+nf}{score}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{vocab} \PYG{o}{+} \PYG{n}{grammar} \PYG{o}{+} \PYG{n}{listen}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\PYG{k+kd}{class} \PYG{n+nc}{ChineseExam} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n}{minutes}\PYG{o}{;}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n}{word}\PYG{o}{,} \PYG{n}{sentence}\PYG{o}{,} \PYG{n}{composition}\PYG{o}{;}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n+nf}{getMinutes}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{minutes}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n+nf}{score}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{word} \PYG{o}{+} \PYG{n}{sentence} \PYG{o}{+} \PYG{n}{composition}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Demo} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{argv}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{n}{EnglishExam} \PYG{n}{ee} \PYG{o}{=} \PYG{k}{new} \PYG{n}{EnglishExam}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
    \PYG{n}{ee}\PYG{o}{.}\PYG{n+na}{minutes} \PYG{o}{=} \PYG{l+m+mi}{75}\PYG{o}{;}
    \PYG{n}{ee}\PYG{o}{.}\PYG{n+na}{vocab} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{o}{;} \PYG{n}{ee}\PYG{o}{.}\PYG{n+na}{grammar} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{o}{;} \PYG{n}{ee}\PYG{o}{.}\PYG{n+na}{listen} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{o}{;}
    \PYG{n}{ChineseExam} \PYG{n}{cc} \PYG{o}{=} \PYG{k}{new} \PYG{n}{ChineseExam}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
    \PYG{n}{ee}\PYG{o}{.}\PYG{n+na}{minutes} \PYG{o}{=} \PYG{l+m+mi}{75}\PYG{o}{;}
    \PYG{n}{cc}\PYG{o}{.}\PYG{n+na}{word} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{;} \PYG{n}{cc}\PYG{o}{.}\PYG{n+na}{sentence} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{o}{;} \PYG{n}{cc}\PYG{o}{.}\PYG{n+na}{composition} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{o}{;}
    \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{print}\PYG{o}{(}\PYG{l+s}{"The score of the English exam is "}\PYG{o}{)}\PYG{o}{;}
    \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{ee}\PYG{o}{.}\PYG{n+na}{score}\PYG{o}{(}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
    \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"English exam takes "} \PYG{o}{+} \PYG{n}{ee}\PYG{o}{.}\PYG{n+na}{getMinutes}\PYG{o}{(}\PYG{o}{)} \PYG{o}{+} \PYG{l+s}{"minutes."}\PYG{o}{)}\PYG{o}{;}
    \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{print}\PYG{o}{(}\PYG{l+s}{"The score of the Chinese exam is "}\PYG{o}{)}\PYG{o}{;}
    \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{cc}\PYG{o}{.}\PYG{n+na}{score}\PYG{o}{(}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
    \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"Chinese exam takes "} \PYG{o}{+} \PYG{n}{cc}\PYG{o}{.}\PYG{n+na}{getMinutes}\PYG{o}{(}\PYG{o}{)} \PYG{o}{+} \PYG{l+s}{"minutes."}\PYG{o}{)}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

不好的原因是 EnglishExam 及 ChineseExam 中有許多 \textbf{重複的程式碼} 。
而這些重複的程式碼會增加開發的成本及維護的負擔。
所幸 Java 容許我們將類別設計成階層式的結構，
而這個階層的結構可以自然的將不同類別間的繼承關係表達出來。
因此，我們可以設計一個 Exam 類別，並將 minutes 宣告在 Exam 內；
再由 EnglishExam 及 ChineseExam 繼承 Exam 即可。
Java 使用 \textbf{extends} 這個保留字讓一個類別繼承另一個類別。

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{class} \PYG{n+nc}{Exam} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n}{minutes}\PYG{o}{;}
  \PYG{k+kd}{public} \PYG{n+nf}{Exam}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"Calling Exam()..."}\PYG{o}{)}\PYG{o}{;}
        \PYG{n}{minutes} \PYG{o}{=} \PYG{l+m+mi}{75}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n+nf}{getMinutes}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{minutes}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}

\PYG{k+kd}{class} \PYG{n+nc}{EnglishExam} \PYG{k+kd}{extends} \PYG{n}{Exam} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n}{vocab}\PYG{o}{,} \PYG{n}{grammar}\PYG{o}{,} \PYG{n}{listen}\PYG{o}{;}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n+nf}{score}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{vocab} \PYG{o}{+} \PYG{n}{grammar} \PYG{o}{+} \PYG{n}{listen}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}

\PYG{k+kd}{class} \PYG{n+nc}{ChineseExam} \PYG{k+kd}{extends} \PYG{n}{Exam} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n}{word}\PYG{o}{,} \PYG{n}{sentence}\PYG{o}{,} \PYG{n}{composition}\PYG{o}{;}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n+nf}{score}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{word} \PYG{o}{+} \PYG{n}{sentence} \PYG{o}{+} \PYG{n}{composition}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}

\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Demo} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{argv}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{n}{EnglishExam} \PYG{n}{ee} \PYG{o}{=} \PYG{k}{new} \PYG{n}{EnglishExam}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
        \PYG{n}{ee}\PYG{o}{.}\PYG{n+na}{vocab} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{o}{;} \PYG{n}{ee}\PYG{o}{.}\PYG{n+na}{grammar} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{o}{;} \PYG{n}{ee}\PYG{o}{.}\PYG{n+na}{listen} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{o}{;}
        \PYG{n}{ChineseExam} \PYG{n}{cc} \PYG{o}{=} \PYG{k}{new} \PYG{n}{ChineseExam}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
        \PYG{n}{cc}\PYG{o}{.}\PYG{n+na}{word} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{;} \PYG{n}{cc}\PYG{o}{.}\PYG{n+na}{sentence} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{o}{;} \PYG{n}{cc}\PYG{o}{.}\PYG{n+na}{composition} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{o}{;}
        \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{print}\PYG{o}{(}\PYG{l+s}{"The score of the English exam is "}\PYG{o}{)}\PYG{o}{;}
        \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{ee}\PYG{o}{.}\PYG{n+na}{score}\PYG{o}{(}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
        \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"English exam takes "} \PYG{o}{+} \PYG{n}{ee}\PYG{o}{.}\PYG{n+na}{getMinutes}\PYG{o}{(}\PYG{o}{)} \PYG{o}{+} \PYG{l+s}{"minutes."}\PYG{o}{)}\PYG{o}{;}
        \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{print}\PYG{o}{(}\PYG{l+s}{"The score of the Chinese exam is "}\PYG{o}{)}\PYG{o}{;}
        \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{cc}\PYG{o}{.}\PYG{n+na}{score}\PYG{o}{(}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
        \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"Chinese exam takes "} \PYG{o}{+} \PYG{n}{cc}\PYG{o}{.}\PYG{n+na}{getMinutes}\PYG{o}{(}\PYG{o}{)} \PYG{o}{+} \PYG{l+s}{"minutes."}\PYG{o}{)}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

這時 Exam 是 EnglishExam 及 ChineseExam 的父類別，
而 EnglishExam 及 ChineseExam 是 Exam 的子類別。
Exam 也有一個父類別，這個類別是 Java 內建的 Object 類別。
一個 Java 程式內所有的類別都直接或間接的繼承了 Object 類別。Exam 也可以寫成：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{class} \PYG{n+nc}{Exam} \PYG{k+kd}{extends} \PYG{n}{Object} \PYG{o}{\PYGZob{}}
  \PYG{c+c1}{// ...}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

除了減少重複不必要的程式碼以外，類別的繼承還有以下兩個好處：
\begin{enumerate}
\item {} 
讓父類別的程式碼可以在完全除錯後，才被子類別繼承。這樣可以讓程式的偵錯更為容易。

\item {} 
可以購買軟體廠商已經開發好的類別，再透過繼承擴充其功能。

\end{enumerate}

一個子類別的實例，含有自己類別的實例變數與方法，以及所有父類別的實例變數與方法。例如：ee 這個實例便有自己定義的 vocab, grammar, listen 及繼承而來的 minutes 四個實例變數及 score 及 getMinutes 兩個方法。

通常將實例變數與實例方法放置於父類別時，需要滿足以下兩個條件：
\begin{enumerate}
\item {} 
可以減少重複的程式碼。

\item {} 
父類別的實例變數或實例方法對子類別有用處。例如：Exam 內的 minutes 便對 ChineseExam 及 EnglishExam 有用。

\end{enumerate}

當類別間有繼承關係時，建構子的呼叫順序是先執行父類別的建構子。例如：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{class} \PYG{n+nc}{Exam} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n}{minutes}\PYG{o}{;}
  \PYG{k+kd}{public} \PYG{n+nf}{Exam}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"Calling Exam()..."}\PYG{o}{)}\PYG{o}{;}
        \PYG{n}{minutes} \PYG{o}{=} \PYG{l+m+mi}{75}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n+nf}{getMinutes}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{minutes}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}

\PYG{k+kd}{class} \PYG{n+nc}{EnglishExam} \PYG{k+kd}{extends} \PYG{n}{Exam} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n}{vocab}\PYG{o}{,} \PYG{n}{grammar}\PYG{o}{,} \PYG{n}{listen}\PYG{o}{;}
  \PYG{k+kd}{public} \PYG{n+nf}{EnglishExam}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"Calling EnglishExam()..."}\PYG{o}{)}\PYG{o}{;}
        \PYG{n}{vocab} \PYG{o}{=} \PYG{l+m+mi}{7}\PYG{o}{;} \PYG{n}{grammar} \PYG{o}{=} \PYG{l+m+mi}{7}\PYG{o}{;} \PYG{n}{listen} \PYG{o}{=} \PYG{l+m+mi}{7}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n+nf}{score}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{vocab} \PYG{o}{+} \PYG{n}{grammar} \PYG{o}{+} \PYG{n}{listen}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}

\PYG{k+kd}{class} \PYG{n+nc}{ChineseExam} \PYG{k+kd}{extends} \PYG{n}{Exam}\PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n}{word}\PYG{o}{,} \PYG{n}{sentence}\PYG{o}{,} \PYG{n}{composition}\PYG{o}{;}
  \PYG{k+kd}{public} \PYG{n+nf}{ChineseExam}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"Calling ChineseExam()..."}\PYG{o}{)}\PYG{o}{;}
        \PYG{n}{word} \PYG{o}{=} \PYG{l+m+mi}{7}\PYG{o}{;} \PYG{n}{sentence} \PYG{o}{=} \PYG{l+m+mi}{7}\PYG{o}{;} \PYG{n}{composition} \PYG{o}{=} \PYG{l+m+mi}{7}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n+nf}{score}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{word} \PYG{o}{+} \PYG{n}{sentence} \PYG{o}{+} \PYG{n}{composition}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}

\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Demo} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{argv}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{n}{EnglishExam} \PYG{n}{ee} \PYG{o}{=} \PYG{k}{new} \PYG{n}{EnglishExam}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
        \PYG{n}{ChineseExam} \PYG{n}{cc} \PYG{o}{=} \PYG{k}{new} \PYG{n}{ChineseExam}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

會得到以下的執行結果：

\begin{Verbatim}[commandchars=@\[\]]
Calling Exam()...
Calling EnglishExam()...
Calling Exam()...
Calling ChineseExam()...
\end{Verbatim}

如果我們需要將 EnglishExam 更加的細分。
例如：增加一個 GREEnglishExam 類別，而這個類別的特性是 listen 實例變數的值是 0：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{class} \PYG{n+nc}{Exam} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n}{minutes}\PYG{o}{;}
  \PYG{k+kd}{public} \PYG{n+nf}{Exam}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{n}{minutes} \PYG{o}{=} \PYG{l+m+mi}{75}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n+nf}{getMinutes}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{minutes}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}

\PYG{k+kd}{class} \PYG{n+nc}{EnglishExam} \PYG{k+kd}{extends} \PYG{n}{Exam} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n}{vocab}\PYG{o}{,} \PYG{n}{grammar}\PYG{o}{,} \PYG{n}{listen}\PYG{o}{;}
  \PYG{k+kd}{public} \PYG{n+nf}{EnglishExam}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{n}{vocab} \PYG{o}{=} \PYG{l+m+mi}{7}\PYG{o}{;} \PYG{n}{grammar} \PYG{o}{=} \PYG{l+m+mi}{7}\PYG{o}{;} \PYG{n}{listen} \PYG{o}{=} \PYG{l+m+mi}{7}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n+nf}{score}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{vocab} \PYG{o}{+} \PYG{n}{grammar} \PYG{o}{+} \PYG{n}{listen}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}

\PYG{k+kd}{class} \PYG{n+nc}{GREEnglishExam} \PYG{k+kd}{extends} \PYG{n}{EnglishExam} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n+nf}{score}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{vocab} \PYG{o}{+} \PYG{n}{grammar} \PYG{o}{+} \PYG{l+m+mi}{0}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}

\PYG{k+kd}{class} \PYG{n+nc}{ChineseExam} \PYG{k+kd}{extends} \PYG{n}{Exam}\PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n}{word}\PYG{o}{,} \PYG{n}{sentence}\PYG{o}{,} \PYG{n}{composition}\PYG{o}{;}
  \PYG{k+kd}{public} \PYG{n+nf}{ChineseExam}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{n}{word} \PYG{o}{=} \PYG{l+m+mi}{7}\PYG{o}{;} \PYG{n}{sentence} \PYG{o}{=} \PYG{l+m+mi}{7}\PYG{o}{;} \PYG{n}{composition} \PYG{o}{=} \PYG{l+m+mi}{7}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n+nf}{score}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{word} \PYG{o}{+} \PYG{n}{sentence} \PYG{o}{+} \PYG{n}{composition}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}

\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Demo} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{argv}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{n}{EnglishExam} \PYG{n}{ee} \PYG{o}{=} \PYG{k}{new} \PYG{n}{EnglishExam}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
        \PYG{n}{GREEnglishExam} \PYG{n}{gre} \PYG{o}{=} \PYG{k}{new} \PYG{n}{GREEnglishExam}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
        \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"English exam score is "} \PYG{o}{+} \PYG{n}{ee}\PYG{o}{.}\PYG{n+na}{score}\PYG{o}{(}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
        \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"GRE English exam score is "} \PYG{o}{+} \PYG{n}{gre}\PYG{o}{.}\PYG{n+na}{score}\PYG{o}{(}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

這時執行的結果會得到：

\begin{Verbatim}[commandchars=@\[\]]
English exam score is 21
GRE English exam score is 14
\end{Verbatim}

呼叫 gre.score() 得到 14 的原因是，
GREEnglishExam 的 score 方法遮蔽了 EnglishExam 的 score 方法，
而名稱相同的方法有以下兩種關係：
\begin{enumerate}
\item {} 
Overloading：是指參數輸入的個數或類別不同，但是卻同名的方法。

\item {} 
Shadowing：這是指數個方法同名，而參數的個數與型態也相同，
但是卻分別的定義在不同的類別的方法。

\end{enumerate}

以上例而言 gre.score() 會呼叫 GREEnglishExam 的 score 方法，
而 ee.score() 則會呼叫 EnglishExam 的 score 方法。
在執行時呼叫幾個同名的方法的哪一個，是根據實例所屬的類別，
例如：gre 的類別是 GREEnglishExam 所以 gre.score()
會呼叫 GREEnglishExam 的 score 方法。如果 GREEnglishExam 沒有定義被呼叫的方法，例如：gre.getMinutes()，這時則會呼叫其父類別的方法，如果父類別中也沒有定義，則會呼叫祖父類別的方法，依此類推。所以 gre.getMinutes()會呼叫到 Exam 的 getMinutes 方法。


\section{private 與 protected 變數與方法}
\label{java_abstract:private-protected}
在討論 getter, setter 方法時，我們談到資料抽象化的好處。
但是如果那個實例變數本身（例如：minutes）仍然是定義成 public 那麼將失去強制性，
也就是其他的程式設計師仍然可以繞過 getter 與 setter 方法而直接的存取 minutes。

private 與 protected 兩個保留字可以設定某個變數或方法的存取範圍。
private 變數或方法的存取範圍為自己的類別內，
而 protected 變數或方法則包括自己的類別、子類別及所屬的 package 內。
至於一個 package 則是由數個為了完成某種功能的類別所組合而成。
例如：一個類別 C 若屬於一個 package p，則 C 的程式碼必須以

\begin{Verbatim}[commandchars=@\[\]]
package p;
\end{Verbatim}

起始，而且也必須存放在一個命名為 p 的目錄中。一個 Java 的檔案，
如果要使用 C 或 p 所提供的功能，則可以用下兩種方式，
輸入 C 或 p 內所有非 private 的名字：

\begin{Verbatim}[commandchars=@\[\]]
import p.C;
import p.*;
\end{Verbatim}

一個 package 也可以使用

\begin{Verbatim}[commandchars=@\[\]]
jar vcf p.jar p
\end{Verbatim}

指令將其中的 .class 檔包裹起來，放在 jdk...jrelibext 的目錄中供其他程式使用。

private 與 protected 的變數與方法可以有許多交替使用的可能。例如：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{class} \PYG{n+nc}{Exam} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{n+nf}{Exam}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{n}{minutes} \PYG{o}{=} \PYG{l+m+mi}{75}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n+nf}{getMinutes}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{minutes}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{public} \PYG{k+kt}{void} \PYG{n+nf}{setMinutes}\PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{m}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{n}{minutes} \PYG{o}{=} \PYG{n}{m}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{private} \PYG{k+kt}{int} \PYG{n}{minutes}\PYG{o}{;}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

以上的範例將 minutes 宣告為 private 而將 getMinutes, setMinutes 宣告為 public。
這時只有 Exam 能直接存取 minutes，
而程式中所有其他的類別都可以透過 getMinutes, setMinutes 間接的存取 minutes。
Java 的習慣是將 private 的變數或方法宣告在 public 的變數或方法的下方。
一個類別的 public 變數或方法，
形成了這個類別對其他類別的 public interface 或公開的介面。

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{class} \PYG{n+nc}{Exam} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{n+nf}{Exam}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{n}{minutes} \PYG{o}{=} \PYG{l+m+mi}{75}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n+nf}{getMinutes}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{minutes}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{private} \PYG{k+kt}{int} \PYG{n}{minutes}\PYG{o}{;}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

而這個範例，則讓實例在初始化時便將 minutes 設值為75，
由於沒有 setMinutes 而 minutes 又是 private，
所以其他類別的程式碼將無法更動 minutes 的值。

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{class} \PYG{n+nc}{Exam} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{n+nf}{Exam}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{n}{minutes} \PYG{o}{=} \PYG{l+m+mi}{75}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n+nf}{getMinutes}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{minutes}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{protected} \PYG{k+kt}{int} \PYG{n}{minutes}\PYG{o}{;}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

這個範例則容許 Exam 的子類別及與 Exam 位於同樣 package 內的類別直接存取 minutes。

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{class} \PYG{n+nc}{Exam} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{n+nf}{Exam}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{n}{minutes} \PYG{o}{=} \PYG{l+m+mi}{75}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{protected} \PYG{k+kt}{int} \PYG{n+nf}{getMinutes}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{minutes}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{protected} \PYG{k+kt}{void} \PYG{n+nf}{setMinutes}\PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{m}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{n}{minutes} \PYG{o}{=} \PYG{n}{m}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{private} \PYG{k+kt}{int} \PYG{n}{minutes}\PYG{o}{;}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

而這個範例則只有 Exam 能直接存取 minutes，
同時也只有 Exam 的子類別及位於相同 package 中的類別能夠透過 getMinutes 及 setMinutes 間接的存取 minutes。


\section{建構子之間的呼叫}
\label{java_abstract:id2}
如果在建構一個 EnglishExam 實例時要同時傳入四個參數值給 vocab, grammar, listen, minutes 四個實例變數，並將其初始化。而且也要能夠只傳入三個參數值給 vocab, grammar, listen，
那麼一種寫這些建構子的方式是：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{class} \PYG{n+nc}{EnglishExam} \PYG{k+kd}{extends} \PYG{n}{Exam} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n}{vocab}\PYG{o}{,} \PYG{n}{grammar}\PYG{o}{,} \PYG{n}{listen}\PYG{o}{;}
  \PYG{k+kd}{public} \PYG{n+nf}{EnglishExam}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
       \PYG{n}{vocab} \PYG{o}{=} \PYG{l+m+mi}{6}\PYG{o}{;} \PYG{n}{grammar} \PYG{o}{=} \PYG{l+m+mi}{6}\PYG{o}{;} \PYG{n}{listen} \PYG{o}{=} \PYG{l+m+mi}{6}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{public} \PYG{n+nf}{EnglishExam}\PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{v}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{g}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{l}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{n}{vocab} \PYG{o}{=} \PYG{n}{v}\PYG{o}{;} \PYG{n}{grammar} \PYG{o}{=} \PYG{n}{g}\PYG{o}{;} \PYG{n}{listen} \PYG{o}{=} \PYG{n}{l}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{public} \PYG{n+nf}{EnglishExam}\PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{v}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{g}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{l}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{m}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{n}{vocab} \PYG{o}{=} \PYG{n}{v}\PYG{o}{;} \PYG{n}{grammar} \PYG{o}{=} \PYG{n}{g}\PYG{o}{;}  \PYG{n}{listen} \PYG{o}{=} \PYG{n}{l}\PYG{o}{;}
        \PYG{n}{minutes} \PYG{o}{=} \PYG{n}{m}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n+nf}{score}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{vocab} \PYG{o}{+} \PYG{n}{grammar} \PYG{o}{+} \PYG{n}{listen}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

這個寫法有一個缺點就是

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{vocab} \PYG{o}{=} \PYG{n}{v}\PYG{p}{;} \PYG{n}{grammar} \PYG{o}{=} \PYG{n}{g}\PYG{p}{;} \PYG{n}{listen} \PYG{o}{=} \PYG{n}{l}\PYG{p}{;}
\end{Verbatim}

出現兩次。避免這些重複程式碼的方法是使用 this(v, g, l) 去呼叫那個三個參數的建構子：

\begin{Verbatim}[commandchars=@\[\]]
.. code-block:: java
\end{Verbatim}
\begin{quote}
\begin{description}
\item[{class EnglishExam extends Exam \{}] \leavevmode
public int vocab, grammar, listen;
public EnglishExam() \{
\begin{quote}

vocab = 6; grammar = 6; listen = 6;
\end{quote}

\}
public EnglishExam(int v, int g, int l) \{
\begin{quote}

vocab = v; grammar = g; listen = l;
\end{quote}

\}
public EnglishExam(int v, int g, int l, int m) \{
\begin{quote}

this(v, g, l);
minutes = m;
\end{quote}

\}
public int score() \{
\begin{quote}

return vocab + grammar + listen;
\end{quote}

\}

\end{description}

\}
\end{quote}

在建構子中使用 this(...) 指的是呼叫另一個，在相同的類別中，參數的個數與型態皆相同的建構子。要注意的是在建構子中使用 this(...)，一定要寫在建構子的第一行。

另一種可能是當 EnglishExam 與 ChineseExam 都需要呼叫一個參數的建構子將 minutes 初始化。一種不好的寫法是：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{class} \PYG{n+nc}{EnglishExam} \PYG{k+kd}{extends} \PYG{n}{Exam} \PYG{o}{\PYGZob{}}
  \PYG{c+c1}{// ...}
  \PYG{k+kd}{public} \PYG{n+nf}{EnglishExam}\PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{m}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{n}{minutes} \PYG{o}{=} \PYG{n}{m}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{c+c1}{// ...}
\PYG{o}{\PYGZcb{}}
\PYG{k+kd}{class} \PYG{n+nc}{ChineseExam} \PYG{k+kd}{extends} \PYG{n}{Exam} \PYG{o}{\PYGZob{}}
  \PYG{c+c1}{// ...}
  \PYG{k+kd}{public} \PYG{n+nf}{ChineseExam}\PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{m}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{n}{minutes} \PYG{o}{=} \PYG{n}{m}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{c+c1}{// ...}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

這時的

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{minutes} \PYG{o}{=} \PYG{n}{m}\PYG{p}{;}
\end{Verbatim}

也是同樣的重複在兩個類別中。改良的寫法是使用 super(m) 去呼叫定義在 Exam 類別內的一個參數的建構子：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{class} \PYG{n+nc}{Exam} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n+nf}{getMinutes}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{minutes}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{public} \PYG{n+nf}{Exam}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{n}{minutes} \PYG{o}{=} \PYG{l+m+mi}{75}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{public} \PYG{n+nf}{Exam}\PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{m}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{n}{minutes} \PYG{o}{=} \PYG{n}{m}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{private} \PYG{k+kt}{int} \PYG{n}{minutes}\PYG{o}{;}
\PYG{o}{\PYGZcb{}}
\PYG{k+kd}{class} \PYG{n+nc}{EnglishExam} \PYG{k+kd}{extends} \PYG{n}{Exam} \PYG{o}{\PYGZob{}}
  \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
  \PYG{k+kd}{public} \PYG{n+nf}{EnglishExam}\PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{m}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{super}\PYG{o}{(}\PYG{n}{m}\PYG{o}{)}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{\PYGZcb{}}
\PYG{k+kd}{class} \PYG{n+nc}{ChineseExam} \PYG{k+kd}{extends} \PYG{n}{Exam} \PYG{o}{\PYGZob{}}
  \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
  \PYG{k+kd}{public} \PYG{n+nf}{ChineseExam}\PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{m}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{super}\PYG{o}{(}\PYG{n}{m}\PYG{o}{)}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}


\section{實例方法間的呼叫}
\label{java_abstract:id3}
如果你需要擴充 Exam、EnglishExam 與 ChineseExam，使它們能夠產出一份，
包括考試時間、分數的考試資料。例如：

\begin{Verbatim}[commandchars=@\[\]]
Chinese exam score: 88 Exam time: 75 minutes
English exam score: 76 Exam time: 60 minutes
\end{Verbatim}

第一種完成這個程式的寫法是為 EnglishExam 與 ChineseExam 都提供一個 report 方法：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{class} \PYG{n+nc}{Exam} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n}{minutes}\PYG{o}{;}
  \PYG{n}{Exam}\PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{m}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{n}{minutes} \PYG{o}{=} \PYG{n}{m}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n+nf}{getMinutes}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{minutes}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}

\PYG{k+kd}{class} \PYG{n+nc}{EnglishExam} \PYG{k+kd}{extends} \PYG{n}{Exam} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n}{vocab}\PYG{o}{,} \PYG{n}{grammar}\PYG{o}{,} \PYG{n}{listen}\PYG{o}{;}
  \PYG{n}{EnglishExam}\PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{v}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{g}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{l}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{super}\PYG{o}{(}\PYG{l+m+mi}{60}\PYG{o}{)}\PYG{o}{;}
        \PYG{n}{vocab} \PYG{o}{=} \PYG{n}{v}\PYG{o}{;}
        \PYG{n}{grammar} \PYG{o}{=} \PYG{n}{g}\PYG{o}{;}
        \PYG{n}{listen} \PYG{o}{=} \PYG{n}{l}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n+nf}{score}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{vocab} \PYG{o}{+} \PYG{n}{grammar} \PYG{o}{+} \PYG{n}{listen}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{public} \PYG{k+kt}{void} \PYG{n+nf}{report}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"English exam score: "} \PYG{o}{+} \PYG{n}{score}\PYG{o}{(}\PYG{o}{)} \PYG{o}{+}
                               \PYG{l+s}{" Exam time: "} \PYG{o}{+} \PYG{n}{getMinutes}\PYG{o}{(}\PYG{o}{)} \PYG{o}{+} \PYG{l+s}{" minutes"}\PYG{o}{)}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}

\PYG{k+kd}{class} \PYG{n+nc}{ChineseExam} \PYG{k+kd}{extends} \PYG{n}{Exam}\PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n}{word}\PYG{o}{,} \PYG{n}{sentence}\PYG{o}{,} \PYG{n}{composition}\PYG{o}{;}
  \PYG{n}{ChineseExam}\PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{w}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{s}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{c}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{super}\PYG{o}{(}\PYG{l+m+mi}{75}\PYG{o}{)}\PYG{o}{;}
        \PYG{n}{word} \PYG{o}{=} \PYG{n}{w}\PYG{o}{;}
        \PYG{n}{sentence} \PYG{o}{=} \PYG{n}{s}\PYG{o}{;}
        \PYG{n}{composition} \PYG{o}{=} \PYG{n}{c}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n+nf}{score}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{word} \PYG{o}{+} \PYG{n}{sentence} \PYG{o}{+} \PYG{n}{composition}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{public} \PYG{k+kt}{void} \PYG{n+nf}{report}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"Chinese exam score: "} \PYG{o}{+} \PYG{n}{score}\PYG{o}{(}\PYG{o}{)} \PYG{o}{+}
                               \PYG{l+s}{" Exam time: "} \PYG{o}{+} \PYG{n}{getMinutes}\PYG{o}{(}\PYG{o}{)} \PYG{o}{+} \PYG{l+s}{" minutes"}\PYG{o}{)}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}

\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Demo} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{argv}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{n}{ChineseExam} \PYG{n}{cc} \PYG{o}{=} \PYG{k}{new} \PYG{n}{ChineseExam}\PYG{o}{(}\PYG{l+m+mi}{35}\PYG{o}{,} \PYG{l+m+mi}{35}\PYG{o}{,} \PYG{l+m+mi}{18}\PYG{o}{)}\PYG{o}{;}
        \PYG{n}{cc}\PYG{o}{.}\PYG{n+na}{report}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
        \PYG{n}{EnglishExam} \PYG{n}{ee} \PYG{o}{=} \PYG{k}{new} \PYG{n}{EnglishExam}\PYG{o}{(}\PYG{l+m+mi}{30}\PYG{o}{,} \PYG{l+m+mi}{20}\PYG{o}{,} \PYG{l+m+mi}{26}\PYG{o}{)}\PYG{o}{;}
        \PYG{n}{ee}\PYG{o}{.}\PYG{n+na}{report}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

你也可以使用 this 來呼叫方法，所上例中的 report 可以改寫如下:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kt}{void} \PYG{n+nf}{report}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
  \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"English exam score: "} \PYG{o}{+} \PYG{k}{this}\PYG{o}{.}\PYG{n+na}{score}\PYG{o}{(}\PYG{o}{)} \PYG{o}{+}
                 \PYG{l+s}{" Exam time: "} \PYG{o}{+} \PYG{k}{this}\PYG{o}{.}\PYG{n+na}{getMinutes}\PYG{o}{(}\PYG{o}{)} \PYG{o}{+} \PYG{l+s}{" minutes"}\PYG{o}{)}\PYG{o}{;}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

由於 getMinutes 方法是 Exam 提供給它的子類別的方法。
所以也可以用 super 來呼叫這個方法：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kt}{void} \PYG{n+nf}{report}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
  \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"English exam score: "} \PYG{o}{+} \PYG{k}{this}\PYG{o}{.}\PYG{n+na}{score}\PYG{o}{(}\PYG{o}{)} \PYG{o}{+}
                 \PYG{l+s}{" Exam time: "} \PYG{o}{+} \PYG{k+kd}{super}\PYG{o}{.}\PYG{n+na}{getMinutes}\PYG{o}{(}\PYG{o}{)} \PYG{o}{+} \PYG{l+s}{" minutes"}\PYG{o}{)}\PYG{o}{;}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

super 與 this 這兩個保留字，
同時用在建構子中與方法的呼叫，但是意義完全不同。
用於建構子中的呼叫時，super 與 this 是用來呼叫其他的建構子；
用於方法的呼叫時，super 是指呼叫自己或祖先中同名且參數一致的方法；
而 this 甚至有可能呼叫到子孫類別中同名且參數一致的方法。
由於 this 是在方法呼叫時才傳入的隱藏性參數，
指的是實例本身，並不一定是指 this 這個字所在的類別，
所以要看 this 呼叫時的實例為何，才能知道是那個方法被呼叫。

另一個寫這個程式的方式是將 report 拆開並分別放在父類別與子類別中：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{class} \PYG{n+nc}{Exam} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n}{minutes}\PYG{o}{;}
  \PYG{n}{Exam}\PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{m}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{n}{minutes} \PYG{o}{=} \PYG{n}{m}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n+nf}{getMinutes}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{minutes}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{public} \PYG{k+kt}{void} \PYG{n+nf}{report}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{" Exam time: "} \PYG{o}{+} \PYG{k}{this}\PYG{o}{.}\PYG{n+na}{getMinutes}\PYG{o}{(}\PYG{o}{)} \PYG{o}{+} \PYG{l+s}{" minutes"}\PYG{o}{)}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}

\PYG{k+kd}{class} \PYG{n+nc}{EnglishExam} \PYG{k+kd}{extends} \PYG{n}{Exam} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n}{vocab}\PYG{o}{,} \PYG{n}{grammar}\PYG{o}{,} \PYG{n}{listen}\PYG{o}{;}
  \PYG{n}{EnglishExam}\PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{v}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{g}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{l}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{super}\PYG{o}{(}\PYG{l+m+mi}{60}\PYG{o}{)}\PYG{o}{;}
        \PYG{n}{vocab} \PYG{o}{=} \PYG{n}{v}\PYG{o}{;}
        \PYG{n}{grammar} \PYG{o}{=} \PYG{n}{g}\PYG{o}{;}
        \PYG{n}{listen} \PYG{o}{=} \PYG{n}{l}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n+nf}{score}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{vocab} \PYG{o}{+} \PYG{n}{grammar} \PYG{o}{+} \PYG{n}{listen}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{public} \PYG{k+kt}{void} \PYG{n+nf}{report}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"English exam score: "} \PYG{o}{+} \PYG{k}{this}\PYG{o}{.}\PYG{n+na}{score}\PYG{o}{(}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
        \PYG{k+kd}{super}\PYG{o}{.}\PYG{n+na}{report}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}

\PYG{k+kd}{class} \PYG{n+nc}{ChineseExam} \PYG{k+kd}{extends} \PYG{n}{Exam}\PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n}{word}\PYG{o}{,} \PYG{n}{sentence}\PYG{o}{,} \PYG{n}{composition}\PYG{o}{;}
  \PYG{n}{ChineseExam}\PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{w}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{s}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{c}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{super}\PYG{o}{(}\PYG{l+m+mi}{75}\PYG{o}{)}\PYG{o}{;}
        \PYG{n}{word} \PYG{o}{=} \PYG{n}{w}\PYG{o}{;}
        \PYG{n}{sentence} \PYG{o}{=} \PYG{n}{s}\PYG{o}{;}
        \PYG{n}{composition} \PYG{o}{=} \PYG{n}{c}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n+nf}{score}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{word} \PYG{o}{+} \PYG{n}{sentence} \PYG{o}{+} \PYG{n}{composition}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{public} \PYG{k+kt}{void} \PYG{n+nf}{report}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"Chinese exam score: "} \PYG{o}{+} \PYG{k}{this}\PYG{o}{.}\PYG{n+na}{score}\PYG{o}{(}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
        \PYG{k+kd}{super}\PYG{o}{.}\PYG{n+na}{report}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}

\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Demo} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{argv}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{n}{ChineseExam} \PYG{n}{cc} \PYG{o}{=} \PYG{k}{new} \PYG{n}{ChineseExam}\PYG{o}{(}\PYG{l+m+mi}{35}\PYG{o}{,} \PYG{l+m+mi}{35}\PYG{o}{,} \PYG{l+m+mi}{18}\PYG{o}{)}\PYG{o}{;}
        \PYG{n}{cc}\PYG{o}{.}\PYG{n+na}{report}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
        \PYG{n}{EnglishExam} \PYG{n}{ee} \PYG{o}{=} \PYG{k}{new} \PYG{n}{EnglishExam}\PYG{o}{(}\PYG{l+m+mi}{30}\PYG{o}{,} \PYG{l+m+mi}{20}\PYG{o}{,} \PYG{l+m+mi}{26}\PYG{o}{)}\PYG{o}{;}
        \PYG{n}{ee}\PYG{o}{.}\PYG{n+na}{report}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

當使用 super 呼叫一個方法（report）時，
Java 會忽略定義在目前類別（EnglishExam 或 ChineseExam）的同名的 report 方法，
而會從目前類別的父類別（Exam）開始往上搜尋，
找到後，便呼叫那個方法。以上例而言，就是定義在 Exam 中的 report 方法。


\section{抽象類別}
\label{java_abstract:id4}
還有一個寫這個程式的方式是使用抽象類別（abstract class）。
抽象類別的功用是為它的子類別們提供共用的變數與方法。
在抽象類別中可以宣告抽象方法（abstract method），
抽象方法沒有程式碼的具體定義，它只有方法的名稱及型態的宣告。
在一個抽象類別中宣告一個抽象方法，
便必需要在這個抽象類別的直接子類別（direct subclass）定義與這個抽象方法同名、
同型態的方法，要不然會發生編譯錯誤。

如果要在 Exam 的子類別強迫定義 score 方法，
並且只用 Exam 的 report 印出 score、time 及 examName 的資料。
那麼這個程式可以改寫成以下這個沒有重複程式碼的版本：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{abstract} \PYG{k+kd}{class} \PYG{n+nc}{Exam} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{private} \PYG{k+kt}{int} \PYG{n}{minutes}\PYG{o}{;}
  \PYG{k+kd}{private} \PYG{n}{String} \PYG{n}{examName}\PYG{o}{;}
  \PYG{n}{Exam}\PYG{o}{(}\PYG{n}{String} \PYG{n}{n}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{m}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{n}{examName} \PYG{o}{=} \PYG{n}{n}\PYG{o}{;}
        \PYG{n}{minutes} \PYG{o}{=} \PYG{n}{m}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n+nf}{getMinutes}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{minutes}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{public} \PYG{n}{String} \PYG{n+nf}{getExamName}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{examName}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{public} \PYG{k+kt}{void} \PYG{n+nf}{report}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{k}{this}\PYG{o}{.}\PYG{n+na}{getExamName}\PYG{o}{(}\PYG{o}{)} \PYG{o}{+} \PYG{l+s}{"score: "} \PYG{o}{+}
        \PYG{k}{this}\PYG{o}{.}\PYG{n+na}{score}\PYG{o}{(}\PYG{o}{)} \PYG{o}{+} \PYG{l+s}{" Exam time: "} \PYG{o}{+} \PYG{k}{this}\PYG{o}{.}\PYG{n+na}{getMinutes}\PYG{o}{(}\PYG{o}{)} \PYG{o}{+} \PYG{l+s}{" minutes"}\PYG{o}{)}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{abstract} \PYG{k+kt}{int} \PYG{n+nf}{score}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
\PYG{o}{\PYGZcb{}}

\PYG{k+kd}{class} \PYG{n+nc}{EnglishExam} \PYG{k+kd}{extends} \PYG{n}{Exam} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n}{vocab}\PYG{o}{,} \PYG{n}{grammar}\PYG{o}{,} \PYG{n}{listen}\PYG{o}{;}
  \PYG{n}{EnglishExam}\PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{v}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{g}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{l}\PYG{o}{,} \PYG{n}{String} \PYG{n}{n}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{super}\PYG{o}{(}\PYG{n}{n}\PYG{o}{,} \PYG{l+m+mi}{60}\PYG{o}{)}\PYG{o}{;}
        \PYG{n}{vocab} \PYG{o}{=} \PYG{n}{v}\PYG{o}{;}
        \PYG{n}{grammar} \PYG{o}{=} \PYG{n}{g}\PYG{o}{;}
        \PYG{n}{listen} \PYG{o}{=} \PYG{n}{l}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n+nf}{score}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{vocab} \PYG{o}{+} \PYG{n}{grammar} \PYG{o}{+} \PYG{n}{listen}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}

\PYG{k+kd}{class} \PYG{n+nc}{ChineseExam} \PYG{k+kd}{extends} \PYG{n}{Exam} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n}{word}\PYG{o}{,} \PYG{n}{sentence}\PYG{o}{,} \PYG{n}{composition}\PYG{o}{;}
  \PYG{n}{ChineseExam}\PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{w}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{s}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{c}\PYG{o}{,} \PYG{n}{String} \PYG{n}{n}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{super}\PYG{o}{(}\PYG{n}{n}\PYG{o}{,} \PYG{l+m+mi}{75}\PYG{o}{)}\PYG{o}{;}
        \PYG{n}{word} \PYG{o}{=} \PYG{n}{w}\PYG{o}{;}
        \PYG{n}{sentence} \PYG{o}{=} \PYG{n}{s}\PYG{o}{;}
        \PYG{n}{composition} \PYG{o}{=} \PYG{n}{c}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
  \PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n+nf}{score}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{word} \PYG{o}{+} \PYG{n}{sentence} \PYG{o}{+} \PYG{n}{composition}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}

\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Demo} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{argv}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{n}{Exam} \PYG{n}{ex}\PYG{o}{;}
        \PYG{n}{ex} \PYG{o}{=} \PYG{k}{new} \PYG{n}{ChineseExam}\PYG{o}{(}\PYG{l+m+mi}{35}\PYG{o}{,} \PYG{l+m+mi}{35}\PYG{o}{,} \PYG{l+m+mi}{18}\PYG{o}{,} \PYG{l+s}{"Chinese exam"}\PYG{o}{)}\PYG{o}{;}
        \PYG{n}{ex}\PYG{o}{.}\PYG{n+na}{report}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
        \PYG{n}{ex} \PYG{o}{=} \PYG{k}{new} \PYG{n}{EnglishExam}\PYG{o}{(}\PYG{l+m+mi}{30}\PYG{o}{,} \PYG{l+m+mi}{20}\PYG{o}{,} \PYG{l+m+mi}{26}\PYG{o}{,} \PYG{l+s}{"English exam"}\PYG{o}{)}\PYG{o}{;}
        \PYG{n}{ex}\PYG{o}{.}\PYG{n+na}{report}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

在 Exam 類別內的 report 方法所用到的 this 可以有兩種可能的實例與之對應：
ChineseExam 的實例與 EnglishExam 的實例。
而呼叫在 main 中的 ex.report() 會繼續呼叫到 this.score()，
這時實際上被呼叫的 score 方法有兩種可能：
\begin{enumerate}
\item {} 
呼叫到定義在 ChineseExam 中的 score，如果 ex 的值是一個 ChineseExam 的實例。

\item {} 
呼叫到定義在 EnglishExam 中的 score，如果 ex 的值是一個 EnglishExam 的實例。

\end{enumerate}

因此 this 的意義不是指出現 this 這個字的類別（Exam），
而是指用於呼叫方法（score）的實例，
這個實例就是 this。
以上例而言是 ex，而 ex 的值可以是一個 ChineseExam 的實例，
也可以是一個 EnglishExam 的實例，
而 ChineseExam 與 EnglishExam 都是 Exam 的子類別，
所以 this.score() 實際上 \textbf{可能呼叫到自己的子孫所定義的方法} 。

一個抽象類別的主要功用是為它的子類別提供共用的變數與方法。
抽象類別內可以宣告抽象方法。
但是抽象類別不能產生實例，所以以下的程式碼會產生編譯錯誤：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Exam} \PYG{n}{ex} \PYG{o}{=} \PYG{k}{new} \PYG{n}{Exam}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
\end{Verbatim}

抽象類別的抽象方法強制其直接子類別必須定義同名、同型態的實體方法，
而 Java 的編譯器可以檢查這個規定是否被達成，
因此可以減輕程式設計師自行檢查某個類別是否符合設計需求的負擔。

雖然抽象類別不能產生實例，但是卻可以用於宣告實例變數的型態。例如：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Demo} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{argv}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{n}{Exam} \PYG{n}{ex}\PYG{o}{;}
        \PYG{n}{ex} \PYG{o}{=} \PYG{k}{new} \PYG{n}{ChineseExam}\PYG{o}{(}\PYG{l+m+mi}{35}\PYG{o}{,} \PYG{l+m+mi}{35}\PYG{o}{,} \PYG{l+m+mi}{18}\PYG{o}{,} \PYG{l+s}{"Chinese exam"}\PYG{o}{)}\PYG{o}{;}
        \PYG{n}{ex}\PYG{o}{.}\PYG{n+na}{report}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
        \PYG{n}{ex} \PYG{o}{=} \PYG{k}{new} \PYG{n}{EnglishExam}\PYG{o}{(}\PYG{l+m+mi}{30}\PYG{o}{,} \PYG{l+m+mi}{20}\PYG{o}{,} \PYG{l+m+mi}{26}\PYG{o}{,} \PYG{l+s}{"English exam"}\PYG{o}{)}\PYG{o}{;}
        \PYG{n}{ex}\PYG{o}{.}\PYG{n+na}{report}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

ex 這個變數的型態是 Exam，因為 ChineseExam 與 EnglishExam 都是一種 Exam，
所以 ex 可以儲存 ChineseExam 的實例，
也可以儲存 EnglishExam 的實例，
因為 ChineseExam 與 EnglishExam 不但是 Exam 的子類別，
也是 Exam 的 \textbf{子型態（subtype）} 。
這便是 ChineseExam 與 Exam 有 \textbf{is-a} 的關係，
也就是一個 ChineseExam 是一個（is-a）Exam；
而一個 EnglishExam 也是一個 Exam。

但是型態被宣告為 Exam 的變數，只能用於呼叫宣告在 Exam 內的方法。
假設 ChineseExam 內有一個 getWord 的方法，
但是在 Exam 中沒有這個方法，
那麼 ex.getWord() 將會產生編譯錯誤，
因為 ex 實例的型態沒有這個方法。

如果確實有需要呼叫 getWord 方法，則可使用轉型的方式進行呼叫。例如：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Demo} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{argv}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{n}{Exam} \PYG{n}{ex}\PYG{o}{;}
        \PYG{n}{ex} \PYG{o}{=} \PYG{k}{new} \PYG{n}{ChineseExam}\PYG{o}{(}\PYG{l+m+mi}{35}\PYG{o}{,} \PYG{l+m+mi}{35}\PYG{o}{,} \PYG{l+m+mi}{18}\PYG{o}{,} \PYG{l+s}{"Chinese exam"}\PYG{o}{)}\PYG{o}{;}
        \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"Word score: "} \PYG{o}{+} \PYG{o}{(}\PYG{n}{ChineseExam}\PYG{o}{)}\PYG{n}{ex}\PYG{o}{.}\PYG{n+na}{getWord}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

抽象類別有一個特性，它不可能是在一個類別繼承結構的最下層。
如果需要，程式設計師可以宣告一個最下層的類別為 final，
一個 final 的類別不能被其他類別繼承。


\section{物件導向程式的設計原則}
\label{java_abstract:id5}
如同前面的範例所展示的，一個問題可能有好幾種不同的解法。
到底哪一種方法比較好？在什麼狀況用哪種解法呢？
以下是設計物件導向程式的幾個參考原則：
\begin{enumerate}
\item {} 
類別的結構與實際一致。

\item {} 
高層次的類別歸納一般化的屬性（general properties），例如：Exam或生物；而低層次類別的屬性則比較特殊化（specialize），例如：EnglishExam或人類。

\item {} 
沒有重複的程式碼。

\item {} 
直接存取常用的資訊，避免反覆的透過計算得到。

\item {} 
將其他類別不需要用的或不需要知道的變數與方法以 private 或 protected 隱藏起來。

\item {} 
is-a 與 has-a 的適當設計：
以前例而言，ChineseExam 與 EnglishExam 都是一種（is-a）Exam。
所以這時將它們設計成父類別與子類別的關係便很正確。
但是，一個考生（a Student）的資料卻不能因為所有的 Exam 都有考生，
而將 Student 設計成 EnglishExam 與 ChineseExam 的父類別。
然而，將 Student 設計成一個單一的類別，
並在 Exam 中宣告一個能夠存放考生實例的實例變數，卻很恰當。
因為一份考卷 has-a 考生。
這種在類別中宣告實例變數，以儲存其他類別所產生的實例，
稱為（ \textbf{has-a} ）的關係。

\end{enumerate}


\section{圖形與動畫的範例}
\label{java_abstract:id6}
到目前為止，我們已經闡述了四種呼叫 Java 方法的方式，這四種方式是：
\begin{enumerate}
\item {} 
呼叫類別方法

\item {} 
以實例來呼叫實例方法

\item {} 
以 this 來呼叫實例方法

\item {} 
以 super 來呼叫實例方法

\end{enumerate}

在這四種方式中最單純的是呼叫類別方法，
因為呼叫一個類別方法可以藉由看靜態（static）的程式碼即可確定是哪一個類別方法被呼叫到。

以 super 來呼叫實例方法也很單純，
其判斷的方式是以程式碼的繼承關係來決定。
例如在 C 類別中呼叫 super.m() 則可以從 C 的父類別開始依序向上（祖先們）搜尋，
而搜尋到的第一個 m 即為被呼叫的方法。

「以實例來呼叫實例方法」及「以 this 來呼叫實例方法」則不能單單的看靜態的程式碼，
而必須要依照程式在動態執行時所使用的實例是哪一個類別的實例才能決定。
為了能明確說明，Java 決定哪一個實例方法被執行的的機制
（這個機制稱為動態搜尋或 dynamic lookup），
在這一節我們使用了幾個能夠動態顯現的圖形與動畫，
並將實例以一層包含一層的方式及將類別以樹狀階層圖的方式對照，
來明確的解說程式執行時的實例或 this 到底是哪一個類別的實例，以決定是那個方法被執行。

如果一個程式有以下幾個類別：

\begin{Verbatim}[commandchars=@\[\]]
Class A{}
Class B extends A{}
Class C extends A{}
Class D extends B{}
Class E extends B{}
\end{Verbatim}

那麼它們之間的繼承與所產生的實例有以下的關係。
其中繼承是以樹狀階層圖表示，而實例則以對應的多層次的同心圓來表示，
同心圓的最內層對應最 super 的類別，而同心圓的最外層則對應這個實例所屬的類別：

Image:inheritance.jpg

以下是另一個圖形與動畫的範例。
這個範例說明了父類別之物件不可以使用子類別之方法，
但子類別之物件可以使用父類別之方法。程式碼如下：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{class} \PYG{n+nc}{Make\PYGZus{}counter} \PYG{o}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{count}\PYG{o}{;}
        \PYG{k+kt}{void} \PYG{n+nf}{add1}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{n}{count} \PYG{o}{=} \PYG{n}{count} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
        \PYG{k+kt}{void} \PYG{n+nf}{add3}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{n}{add1}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{add1}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{add1}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
        \PYG{k+kt}{int} \PYG{n+nf}{getCount}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{k}{return} \PYG{n}{count}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}

\PYG{k+kd}{class} \PYG{n+nc}{Make\PYGZus{}counter2} \PYG{k+kd}{extends} \PYG{n}{Make\PYGZus{}counter} \PYG{o}{\PYGZob{}}
        \PYG{k+kt}{void} \PYG{n+nf}{add2}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{n}{add1}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{add1}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}

\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Ex6} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{argv}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{n}{Make\PYGZus{}counter2} \PYG{n}{c2} \PYG{o}{=} \PYG{k}{new} \PYG{n}{Make\PYGZus{}counter2}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{c2}\PYG{o}{.}\PYG{n+na}{add2}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{c2}\PYG{o}{.}\PYG{n+na}{add3}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"count:"} \PYG{o}{+} \PYG{n}{c2}\PYG{o}{.}\PYG{n+na}{getCount}\PYG{o}{(}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{Make\PYGZus{}counter} \PYG{n}{c1} \PYG{o}{=} \PYG{k}{new} \PYG{n}{Make\PYGZus{}counter}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
                \PYG{c+c1}{// c1.add2(); =\textgreater{} error}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

執行結果：

\begin{Verbatim}[commandchars=@\[\]]
count:5
\end{Verbatim}

Media:Ex6.swf\textbar{}觀看執行動畫


\section{Super, this, abstract class的動畫範例}
\label{java_abstract:super-this-abstract-class}
以下的這個範例使用有層次的實例與動畫，說明this, super的特性:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{class} \PYG{n+nc}{Father} \PYG{o}{\PYGZob{}}
        \PYG{n}{String} \PYG{n}{a} \PYG{o}{=} \PYG{l+s}{"father"}\PYG{o}{;}
\PYG{o}{\PYGZcb{}}
\PYG{k+kd}{class} \PYG{n+nc}{Son} \PYG{k+kd}{extends} \PYG{n}{Father} \PYG{o}{\PYGZob{}}
        \PYG{n}{String} \PYG{n}{a} \PYG{o}{=} \PYG{l+s}{"son"}\PYG{o}{;}
        \PYG{n}{String} \PYG{n+nf}{get\PYGZus{}null}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{k}{return} \PYG{n}{a}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
        \PYG{n}{String} \PYG{n+nf}{get\PYGZus{}this}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{k}{return} \PYG{k}{this}\PYG{o}{.}\PYG{n+na}{a}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
        \PYG{n}{String} \PYG{n+nf}{get\PYGZus{}super}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{k}{return} \PYG{k+kd}{super}\PYG{o}{.}\PYG{n+na}{a}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Ex7} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{argv}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{n}{Son} \PYG{n}{s} \PYG{o}{=} \PYG{k}{new} \PYG{n}{Son}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"a:"} \PYG{o}{+} \PYG{n}{s}\PYG{o}{.}\PYG{n+na}{get\PYGZus{}null}\PYG{o}{(}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"this.a:"} \PYG{o}{+} \PYG{n}{s}\PYG{o}{.}\PYG{n+na}{get\PYGZus{}this}\PYG{o}{(}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"super.a:"} \PYG{o}{+} \PYG{n}{s}\PYG{o}{.}\PYG{n+na}{get\PYGZus{}super}\PYG{o}{(}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

執行結果:

\begin{Verbatim}[commandchars=@\[\]]
a:son
this.a:son
super.a:father
\end{Verbatim}

這個範例中的 s 是一個 Son 的實例，而 Son 的父類別是 Father，
因此 s 實例有兩層，外層是宣告於 Son 中的實例變數與方法，
而內層是宣告於 Father 的實例變數與方法。
get\_this 方法中的 this 即是 s；
而 get\_super 中的 super 指的是 s 的內層相對於 Father 的部分。

Media:Ex7.swf\textbar{}觀看執行動畫

以下這個範例說明類別間有同名而且型態也相同的方法（overwrite）的特性:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{class} \PYG{n+nc}{GrandParent} \PYG{o}{\PYGZob{}}
        \PYG{n}{String} \PYG{n+nf}{eyes}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{k}{return} \PYG{l+s}{"blue"}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\PYG{k+kd}{class} \PYG{n+nc}{Parent} \PYG{k+kd}{extends} \PYG{n}{GrandParent} \PYG{o}{\PYGZob{}}
        \PYG{n}{String} \PYG{n+nf}{eyes}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{k}{return} \PYG{l+s}{"green"}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Ex8} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{args}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{n}{GrandParent} \PYG{n}{gail} \PYG{o}{=} \PYG{k}{new} \PYG{n}{GrandParent}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{Parent} \PYG{n}{sue} \PYG{o}{=} \PYG{k}{new} \PYG{n}{Parent}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"當子類別擁有與父類別同方法名稱時稱為overwrite"}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"gail.eyes():"} \PYG{o}{+} \PYG{n}{gail}\PYG{o}{.}\PYG{n+na}{eyes}\PYG{o}{(}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"sue.eyes():"} \PYG{o}{+} \PYG{n}{sue}\PYG{o}{.}\PYG{n+na}{eyes}\PYG{o}{(}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

執行結果:
\begin{quote}

當子類別擁有與父類別同方法名稱時稱為overwrite
gail.eyes():blue
sue.eyes():green
\end{quote}

GrandParent 由於沒有父類別（除了 Object 以外），
所以 gail 的實例只有一層；然而，sue 的實例卻有兩層，
外層對應 Parent，內層對應 GrandParent。

Media:Ex8.swf\textbar{}觀看執行動畫

以下這個範例將透過宣告在數個不同類別的實例方法的呼叫，
更深入的闡釋 super 與 this 的特性:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{class} \PYG{n+nc}{A} \PYG{o}{\PYGZob{}}
        \PYG{n}{String} \PYG{n+nf}{color}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{k}{return} \PYG{l+s}{"blue"}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
        \PYG{n}{String} \PYG{n+nf}{getColor}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{k}{return} \PYG{k}{this}\PYG{o}{.}\PYG{n+na}{color}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\PYG{k+kd}{class} \PYG{n+nc}{B} \PYG{k+kd}{extends} \PYG{n}{A} \PYG{o}{\PYGZob{}}
        \PYG{n}{String} \PYG{n+nf}{color}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{k}{return} \PYG{l+s}{"green"}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
        \PYG{n}{String} \PYG{n+nf}{getColor1}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{k}{return} \PYG{k}{this}\PYG{o}{.}\PYG{n+na}{color}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
        \PYG{n}{String} \PYG{n+nf}{getColor2}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{k}{return} \PYG{k+kd}{super}\PYG{o}{.}\PYG{n+na}{color}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\PYG{k+kd}{class} \PYG{n+nc}{C} \PYG{k+kd}{extends} \PYG{n}{B} \PYG{o}{\PYGZob{}}
        \PYG{n}{String} \PYG{n+nf}{color}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{k}{return} \PYG{l+s}{"red"}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
        \PYG{n}{String} \PYG{n+nf}{getColor3}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{k}{return} \PYG{k}{this}\PYG{o}{.}\PYG{n+na}{color}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
        \PYG{n}{String} \PYG{n+nf}{getColor4}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{k}{return} \PYG{k+kd}{super}\PYG{o}{.}\PYG{n+na}{color}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Ex10} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{args}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{n}{A} \PYG{n}{a} \PYG{o}{=} \PYG{k}{new} \PYG{n}{A}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{B} \PYG{n}{b} \PYG{o}{=} \PYG{k}{new} \PYG{n}{B}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{C} \PYG{n}{c} \PYG{o}{=} \PYG{k}{new} \PYG{n}{C}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"a.color():"} \PYG{o}{+} \PYG{n}{a}\PYG{o}{.}\PYG{n+na}{color}\PYG{o}{(}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"a.getColor():"} \PYG{o}{+} \PYG{n}{a}\PYG{o}{.}\PYG{n+na}{getColor}\PYG{o}{(}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"b.color():"} \PYG{o}{+} \PYG{n}{b}\PYG{o}{.}\PYG{n+na}{color}\PYG{o}{(}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"b.getColor1():"} \PYG{o}{+} \PYG{n}{b}\PYG{o}{.}\PYG{n+na}{getColor1}\PYG{o}{(}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"b.getColor2():"} \PYG{o}{+} \PYG{n}{b}\PYG{o}{.}\PYG{n+na}{getColor2}\PYG{o}{(}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"c.color():"} \PYG{o}{+} \PYG{n}{c}\PYG{o}{.}\PYG{n+na}{color}\PYG{o}{(}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"c.getColor():"} \PYG{o}{+} \PYG{n}{c}\PYG{o}{.}\PYG{n+na}{getColor}\PYG{o}{(}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"c.getColor1():"} \PYG{o}{+} \PYG{n}{c}\PYG{o}{.}\PYG{n+na}{getColor1}\PYG{o}{(}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"c.getColor2():"} \PYG{o}{+} \PYG{n}{c}\PYG{o}{.}\PYG{n+na}{getColor2}\PYG{o}{(}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"c.getColor3():"} \PYG{o}{+} \PYG{n}{c}\PYG{o}{.}\PYG{n+na}{getColor3}\PYG{o}{(}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"c.getColor4():"} \PYG{o}{+} \PYG{n}{c}\PYG{o}{.}\PYG{n+na}{getColor4}\PYG{o}{(}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

執行結果:

\begin{Verbatim}[commandchars=@\[\]]
a.color():blue
a.getColor():blue
b.color():green
b.getColor1():green
b.getColor2():blue
c.color():red
c.getColor():red
c.getColor1():red
c.getColor2():blue
c.getColor3():red
c.getColor4():green
\end{Verbatim}

這個程式最讓人訝異的是呼叫 c.getColor() 的結果是 red。
因為 c.getColor 會呼叫宣告在 A 之內的 getColor；
而 getColor 內的 this 指的是 c，不是 A；而 c 的 getColor 會傳回 red。

Media:Ex10.swf\textbar{}觀看執行動畫

以下的範例將使用「寵物(Pet)」類別及「狗(Dog)」及「貓(Cat)」兩個子類別。
狗及貓都擁有「聲音(sound)」這個方法，
但狗跟貓的叫聲卻是不同的，此時我們可以利用抽象類別來實作這個例子。

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{abstract} \PYG{k+kd}{class} \PYG{n+nc}{Pet} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{abstract} \PYG{n}{String} \PYG{n+nf}{sound}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
\PYG{o}{\PYGZcb{}}
\PYG{k+kd}{class} \PYG{n+nc}{Dog} \PYG{k+kd}{extends} \PYG{n}{Pet} \PYG{o}{\PYGZob{}}
        \PYG{n}{String} \PYG{n+nf}{sound}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{k}{return} \PYG{l+s}{"汪汪"}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\PYG{k+kd}{class} \PYG{n+nc}{Cat} \PYG{k+kd}{extends} \PYG{n}{Pet} \PYG{o}{\PYGZob{}}
        \PYG{n}{String} \PYG{n+nf}{sound}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{k}{return} \PYG{l+s}{"喵喵"}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Ex11} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{args}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{n}{Dog} \PYG{n}{d} \PYG{o}{=} \PYG{k}{new} \PYG{n}{Dog}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{Cat} \PYG{n}{c} \PYG{o}{=} \PYG{k}{new} \PYG{n}{Cat}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"d.sound():"} \PYG{o}{+} \PYG{n}{d}\PYG{o}{.}\PYG{n+na}{sound}\PYG{o}{(}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"c.sound():"} \PYG{o}{+} \PYG{n}{c}\PYG{o}{.}\PYG{n+na}{sound}\PYG{o}{(}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

執行結果:

\begin{Verbatim}[commandchars=@\[\]]
d.sound():汪汪
c.sound():喵喵
\end{Verbatim}

上例中 d 與 c 兩個變數若宣告成 Pet 型態，則答案仍然會一樣。

Media:Ex11.swf\textbar{}觀看執行動畫

以下這個範例是一個整合了 abstract class, super, this, array 的應用。
這個範例的特色是宣告了 Area 這個 abstract class 及 getArea 這個抽象方法，
讓 Square 及 Triangle 來繼承，
而 whichBig 這個方法則可以比較任何兩個 Area 實例
（Square 及 Triangle 的實例都是 Area 的實例），
何者的面積較大。此外，在 main 中的 a 陣列，
也可以存放任何的 Area 的實例，
因此 a 可以存放 Square 的實例，
也可以存放 Triangle 的實例：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{abstract} \PYG{k+kd}{class} \PYG{n+nc}{Area} \PYG{o}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{high}\PYG{o}{,} \PYG{n}{weight}\PYG{o}{;}
        \PYG{n}{Area}\PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{a}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{b}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{n}{high} \PYG{o}{=} \PYG{n}{a}\PYG{o}{;}
                \PYG{n}{weight} \PYG{o}{=} \PYG{n}{b}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
        \PYG{k+kd}{abstract} \PYG{k+kt}{int} \PYG{n+nf}{getArea}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
        \PYG{k+kt}{boolean} \PYG{n+nf}{whichBig}\PYG{o}{(}\PYG{n}{Area} \PYG{n}{p}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{k}{return} \PYG{o}{(}\PYG{k}{this}\PYG{o}{.}\PYG{n+na}{getArea}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\textgreater{}} \PYG{n}{p}\PYG{o}{.}\PYG{n+na}{getArea}\PYG{o}{(}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\PYG{k+kd}{class} \PYG{n+nc}{Square} \PYG{k+kd}{extends} \PYG{n}{Area} \PYG{o}{\PYGZob{}}
        \PYG{n}{Square}\PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{a}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{b}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{k+kd}{super}\PYG{o}{(}\PYG{n}{a}\PYG{o}{,} \PYG{n}{b}\PYG{o}{)}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
        \PYG{k+kt}{int} \PYG{n+nf}{getArea}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{k}{return} \PYG{n}{high} \PYG{o}{*} \PYG{n}{weight}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\PYG{k+kd}{class} \PYG{n+nc}{Triangle} \PYG{k+kd}{extends} \PYG{n}{Area} \PYG{o}{\PYGZob{}}
        \PYG{n}{Triangle}\PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{a}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{b}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{k+kd}{super}\PYG{o}{(}\PYG{n}{a}\PYG{o}{,} \PYG{n}{b}\PYG{o}{)}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
        \PYG{k+kt}{int} \PYG{n+nf}{getArea}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{k}{return} \PYG{o}{(}\PYG{n}{high} \PYG{o}{*} \PYG{n}{weight}\PYG{o}{)} \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Ex12} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{args}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{k+kt}{int} \PYG{n}{total} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{;}
                \PYG{n}{Area}\PYG{o}{[}\PYG{o}{]} \PYG{n}{a} \PYG{o}{=} \PYG{o}{\PYGZob{}} \PYG{k}{new} \PYG{n}{Square}\PYG{o}{(}\PYG{l+m+mi}{6}\PYG{o}{,} \PYG{l+m+mi}{6}\PYG{o}{)}\PYG{o}{,} \PYG{k}{new} \PYG{n}{Triangle}\PYG{o}{(}\PYG{l+m+mi}{10}\PYG{o}{,} \PYG{l+m+mi}{10}\PYG{o}{)} \PYG{o}{\PYGZcb{}}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"Is a[0] bigger than a[1]?"} \PYG{o}{+} \PYG{n}{a}\PYG{o}{[}\PYG{l+m+mi}{0}\PYG{o}{]}\PYG{o}{.}\PYG{n+na}{whichBig}\PYG{o}{(}\PYG{n}{a}\PYG{o}{[}\PYG{l+m+mi}{1}\PYG{o}{]}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
                \PYG{k}{for} \PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{;} \PYG{n}{i} \PYG{o}{\&}\PYG{n}{lt}\PYG{o}{;} \PYG{n}{a}\PYG{o}{.}\PYG{n+na}{length}\PYG{o}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                        \PYG{n}{total} \PYG{o}{=} \PYG{n}{total} \PYG{o}{+} \PYG{n}{a}\PYG{o}{[}\PYG{n}{i}\PYG{o}{]}\PYG{o}{.}\PYG{n+na}{getArea}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
                \PYG{o}{\PYGZcb{}}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"total:"} \PYG{o}{+} \PYG{n}{total}\PYG{o}{)}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

執行結果:

\begin{Verbatim}[commandchars=@\[\]]
Is a@PYGZlb[]0@PYGZrb[] bigger than a@PYGZlb[]1@PYGZrb[]?false
total:86
\end{Verbatim}

Media:Ex13new.swf\textbar{}觀看執行動畫及詳細解說


\chapter{介面}
\label{java_interface::doc}\label{java_interface:id1}
前一個單元，介紹了以抽象類別內的抽象方法，
來將需求強制加在抽象類別的直接子類別上。
這種功能提供了程式設計師必需先想、先設計，
然後才開始寫程式的好習慣。
這個功能還提供了程式設計師以下的可能：
\begin{enumerate}
\item {} 
將額外的註解放入抽象方法中，讓程式碼有更容易瞭解；

\item {} 
可以將一個類別交給其他人來寫；

\item {} 
如果某個程式設計師忘了按照需求定義抽象方法所強制的名稱與類別，
編譯器可以自動產生錯誤信息。

\end{enumerate}

除了抽象類別能宣告抽象方法之外，
Java 還提供了 \textbf{介面（interface）} 來宣告抽象方法。
不同於抽象類別：
\begin{enumerate}
\item {} 
介面只提供抽象方法或常數宣告，而不能定義變數或一般的方法。

\item {} 
一個子類別只能繼承一個父類別，但卻可以 \textbf{實作（implements）} 許多個介面。
因此，介面模擬了 \textbf{多重繼承（multiple inheritance）} 的功能，
但是卻可以避免一個類別繼承了多個父類別，
但卻可能同時繼承了多個同名的變數或方法而造成混淆。

\end{enumerate}

假設在設計 Exam 這個程式時，
你已經想過要提供一個 score 方法給 ChineseExam 與 EnglishExam。
這時你可以先將 ScoreInterface 設計如下：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kd}{interface} \PYG{n+nc}{ScoreInterface} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kd}{abstract} \PYG{k+kt}{int} \PYG{n+nf}{score}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

而 ChineseExam 與 EnglishExam 則 implements 這個 interface:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{class} \PYG{n+nc}{ChineseExam} \PYG{k+kd}{extends} \PYG{n}{Exam} \PYG{k+kd}{implements} \PYG{n}{ScoreInterface} \PYG{o}{\PYGZob{}}
  \PYG{c+c1}{//...}
\PYG{o}{\PYGZcb{}}
\PYG{k+kd}{class} \PYG{n+nc}{EnglishExam} \PYG{k+kd}{extends} \PYG{n}{Exam} \PYG{k+kd}{implements} \PYG{n}{ScoreInterface} \PYG{o}{\PYGZob{}}
  \PYG{c+c1}{//...}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

這時 ChineseExam 與 EnglishExam 便必須提供 score 方法，
而且要有同樣的輸出入參數的型態，要不然 Java 的編譯器便會產生錯誤信息。
因此使用 interface 的一大好處是讓 Java 的編譯器，
也可以幫助維持程式的一致性；
而不用透過人工，這個容易出錯的方式來維持。

Interface 也可以成為一個變數的型態，
而所宣告的變數可以用來呼叫這個 interface 內宣告的方法。例如：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// ...}

\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Demo} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{argv}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{n}{ScoreInterface} \PYG{n}{ex}\PYG{o}{;}
        \PYG{n}{ex} \PYG{o}{=} \PYG{k}{new} \PYG{n}{ChineseExam}\PYG{o}{(}\PYG{l+m+mi}{35}\PYG{o}{,} \PYG{l+m+mi}{35}\PYG{o}{,} \PYG{l+m+mi}{18}\PYG{o}{,} \PYG{l+s}{"Chinese exam"}\PYG{o}{)}\PYG{o}{;}
        \PYG{n}{ex}\PYG{o}{.}\PYG{n+na}{score}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
        \PYG{n}{ex} \PYG{o}{=} \PYG{k}{new} \PYG{n}{EnglishExam}\PYG{o}{(}\PYG{l+m+mi}{30}\PYG{o}{,} \PYG{l+m+mi}{20}\PYG{o}{,} \PYG{l+m+mi}{26}\PYG{o}{,} \PYG{l+s}{"English exam"}\PYG{o}{)}\PYG{o}{;}
        \PYG{n}{ex}\PYG{o}{.}\PYG{n+na}{score}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

然而，如果上例的 ChineseExam 與 EnglishExam 類別中定義了 report 方法，
而 ScoreInterface 中卻沒有宣告。
這時下列的程式碼便會在編譯時產生型態錯誤：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// ...}

\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Demo} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{argv}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{n}{ScoreInterface} \PYG{n}{ex}\PYG{o}{;}
        \PYG{n}{ex} \PYG{o}{=} \PYG{k}{new} \PYG{n}{ChineseExam}\PYG{o}{(}\PYG{l+m+mi}{35}\PYG{o}{,} \PYG{l+m+mi}{35}\PYG{o}{,} \PYG{l+m+mi}{18}\PYG{o}{,} \PYG{l+s}{"Chinese exam"}\PYG{o}{)}\PYG{o}{;}
        \PYG{n}{ex}\PYG{o}{.}\PYG{n+na}{report}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
        \PYG{n}{ex} \PYG{o}{=} \PYG{k}{new} \PYG{n}{EnglishExam}\PYG{o}{(}\PYG{l+m+mi}{30}\PYG{o}{,} \PYG{l+m+mi}{20}\PYG{o}{,} \PYG{l+m+mi}{26}\PYG{o}{,} \PYG{l+s}{"English exam"}\PYG{o}{)}\PYG{o}{;}
        \PYG{n}{ex}\PYG{o}{.}\PYG{n+na}{report}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

改正的方式是透過轉型：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// ...}

\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Demo} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{argv}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{n}{ScoreInterface} \PYG{n}{ex}\PYG{o}{;}
        \PYG{n}{ex} \PYG{o}{=} \PYG{k}{new} \PYG{n}{ChineseExam}\PYG{o}{(}\PYG{l+m+mi}{35}\PYG{o}{,} \PYG{l+m+mi}{35}\PYG{o}{,} \PYG{l+m+mi}{18}\PYG{o}{,} \PYG{l+s}{"Chinese exam"}\PYG{o}{)}\PYG{o}{;}
        \PYG{o}{(}\PYG{o}{(}\PYG{n}{ChineseExam}\PYG{o}{)}\PYG{n}{ex}\PYG{o}{)}\PYG{o}{.}\PYG{n+na}{report}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
        \PYG{n}{ex} \PYG{o}{=} \PYG{k}{new} \PYG{n}{EnglishExam}\PYG{o}{(}\PYG{l+m+mi}{30}\PYG{o}{,} \PYG{l+m+mi}{20}\PYG{o}{,} \PYG{l+m+mi}{26}\PYG{o}{,} \PYG{l+s}{"English exam"}\PYG{o}{)}\PYG{o}{;}
        \PYG{o}{(}\PYG{o}{(}\PYG{n}{EnglishExam}\PYG{o}{)}\PYG{n}{ex}\PYG{o}{)}\PYG{o}{.}\PYG{n+na}{report}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}



\renewcommand{\indexname}{Index}
\printindex
\end{document}
