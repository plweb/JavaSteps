% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[a4paper,12pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage[cm-default]{fontspec}
\usepackage{xunicode}
\usepackage{xcolor}
\usepackage{fontspec}
\usepackage{titlesec}
\usepackage{fancyvrb,relsize}
\usepackage[slantfont,boldfont]{xeCJK}
\XeTeXlinebreaklocale "zh"
\XeTeXlinebreakskip = 0pt plus 1pt
\setmainfont[BoldFont=Apple LiGothic Medium]{Apple LiSung Light}
\setCJKmainfont[BoldFont=Apple LiGothic Medium]{Apple LiSung Light}
\setromanfont[BoldFont=Apple LiGothic Medium]{Apple LiSung Light}
\setmonofont{Monaco}
\renewcommand{\baselinestretch}{1.25}
\DefineVerbatimEnvironment{Verbatim}{Verbatim}{numbers=left, fontsize=\relsize{-1}}


\title{程式碼實作學習\\Java Steps: Learning Java Step by Step}
\date{September 23, 2011}
\release{1.0}
\author{董少桓、林彥宏}
\newcommand{\sphinxlogo}{\includegraphics{logo.eps}\par}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\def\PYG@tok@gd{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\def\PYG@tok@gu{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\def\PYG@tok@gt{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.25,0.82}{##1}}}
\def\PYG@tok@gs{\let\PYG@bf=\textbf}
\def\PYG@tok@gr{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\def\PYG@tok@cm{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@vg{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@m{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mh{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@cs{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\colorbox[rgb]{1.00,0.94,0.94}{##1}}}
\def\PYG@tok@ge{\let\PYG@it=\textit}
\def\PYG@tok@vc{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@il{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@go{\def\PYG@tc##1{\textcolor[rgb]{0.19,0.19,0.19}{##1}}}
\def\PYG@tok@cp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@gi{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\def\PYG@tok@gh{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\def\PYG@tok@ni{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\def\PYG@tok@nl{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\def\PYG@tok@nn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@no{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\def\PYG@tok@na{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@nb{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@nd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\def\PYG@tok@ne{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nf{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\def\PYG@tok@si{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\def\PYG@tok@s2{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@vi{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@nt{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\def\PYG@tok@nv{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@s1{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@gp{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@sh{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@ow{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@sx{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@bp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c1{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@kc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@mf{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@err{\def\PYG@bc##1{\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{##1}}}
\def\PYG@tok@kd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@ss{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\def\PYG@tok@sr{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\def\PYG@tok@mo{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mi{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@kn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@o{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\def\PYG@tok@kr{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@s{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@kp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@w{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\def\PYG@tok@kt{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\def\PYG@tok@sc{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sb{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@k{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@se{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sd{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}



\chapter{簡介}
\label{java_intro::doc}\label{java_intro:java-steps}\label{java_intro:id1}

\section{Java 程式語言的特色}
\label{java_intro:java}
Java 程式語言起源於 1991 年，
Green Team 軟體開發團隊用它來開發 Star 7 機器上的應用程式，
當時設計此語言的 James Gosling 因為看見窗外的「橡樹（oak）」，
決定將新語言命名為 Oak 。
但是由於工程師們喜歡邊喝咖啡邊討論，
隨後又將名稱改為 Java（一種咖啡的名稱），
這個名稱就一直沿用到現在。

Java 原本是為了控制冰箱、冷氣、微波爐等家電用品而設計的程式語言。
由於家電用品相當多樣，因此 Java 選用了一個與傳統的程式語言不一樣的執行模式：
\begin{itemize}
\item {} 
傳統的程式語言在編譯後會產生 machince code（機器碼），
然後直接在硬體上執行；

\item {} 
Java 在編譯後則會產生 Byte Code 並間接的在 Java Virtual Machine（JVM）上執行。
這個 JVM（Java虛擬機器）其實是一個軟體，其功用是解譯並執行 Byte Code，而 JVM 仍然是在硬體上執行。

\end{itemize}

因為 JVM 是軟體，所以 Java 也有跨平台的特性：
只要為不同的處理器或作業系統設計其專屬的 JVM，
Java 的程式便可以不需改寫的在這些處理器或作業系統上執行。
這便是「Write once, runs everywhere或一次編譯、到處執行」的由來。

Java 也支援物件導向程式設計（Object-Oriented Programming），
所謂「物件」，簡單的說有「屬性」也有「方法」，
例如冷氣機的「屬性」可以包括：「開關」及「溫度」；
而「方法」則可以包括：「開機」、「關機」及「設定溫度」等。
為了讓程式設計師，可以比較容易的使用物件撰寫模擬、控制與
應用電腦本身（如滑鼠與鍵盤等也是物件）和我們生活周遭的物件的程式，
因此便有研究人員發明了支援物件導向程式設計的語言。

Java 的設計搭上了全球資訊網的順風車，
原因是 Java 的設計團隊可以寫一個能夠在瀏覽器中執行的 JVM，
而讓 Java 的程式可以透過網路下載至瀏覽器中執行。
這個「網路」＋「物件導向」的特性讓 Java 瞬間爆紅。

除了跨平台、物件導向、可透過網路動態的載入及執行程式等功能之外，
Java 還支援多執行緒、例外狀態處理與自動記憶體回收的功能：
\begin{itemize}
\item {} 
多執行緒讓一個程式可以執行數個工作；

\item {} 
例外狀態處理讓處理例外的程式碼也能夠物件化；

\item {} 
自動記憶體回收則讓程式設計師免除了使用低階的指標（pointers）來設計資料結構及管理記憶體的負擔。
這個特色成了 C 語言程式設計師的福音，因為它可以為程式設計師減少許多不容易 debug 的錯誤。

\end{itemize}


\section{安裝JDK}
\label{java_intro:jdk}
在編譯與執行 Java 程式前，你的電腦必須先安裝 JDK（Java Development Kit）：
\begin{itemize}
\item {} 
可以從這裡下載新版的JDK \href{http://java.sun.com/javase/downloads/index.jsp}{http://java.sun.com/javase/downloads/index.jsp}

\end{itemize}

在安裝完成後，也需要完成 path 及 classpath 的設定：

\begin{Verbatim}[commandchars=@\[\]]
path=C:\Program Files\Java\jdk1.6.0\bin;....
classpath=.;C:\Program Files\Java\jdk1.6.0\lib;....
\end{Verbatim}

請注意：以上路徑中的 jdk1.6.0 會因版本的不同而異。
此外，在設定 classpath 時要特別注意在 ＝ 號的右邊要輸入這個 \textbf{「.」} 。
這個點的意義是目前的目錄（current directory），也是執行 Java 程式時用來搜尋執行檔的目錄。


\section{編譯及執行Java程式}
\label{java_intro:id2}
有兩種方式可以編譯及執行一個 Java 程式。
第一種是使用程式開發環境（program development environment），
例如： \href{http://eclipse.org/}{Eclipse} ；
另一種則是使用一般的程式編輯器。
以下是使用「記事本」寫 Java 程式時所需要進行的三個步驟：
\begin{enumerate}
\item {} 
使用「記事本」輸入以下的程式並將檔案命名為 EnglishExam.java
（注意：附檔名必須是 .java 而不是 .txt，
\textbf{而這個檔案的主檔名必須與 public class 後面的 EnglishExam 相同} ）：

\end{enumerate}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{EnglishExam} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{argv}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"Your score is 97."}\PYG{o}{)}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
執行「命令提示字元」並將目錄切換至儲存 EnglishExam.java 的目錄，然後執行：

\begin{Verbatim}[commandchars=@\[\]]
javac EnglishExam.java
\end{Verbatim}

執行這個 javac 指令就是執行 Java 的編譯器（compiler），
其結果是在同樣的目錄產生一個 EnglishExam.class 的 byte code 檔。

\item {} 
上面的步驟如果有編譯錯誤則繼續修改程式。如果沒有編譯錯誤則可以執行：

\begin{Verbatim}[commandchars=@\[\]]
java EnglishExam
\end{Verbatim}

執行後 Your score is 97。便會顯示在螢幕上。

\end{enumerate}

在開發 Java 程式的過程中，有可能發生編譯錯誤（compile-time error）。
這時便需要再次的使用編輯器修改錯誤，直到沒有任何的編譯錯誤為止。
編譯完畢之後，在程式執行時也有可能發生 run-time error。
同樣的，這時也需要使用編輯器修改、編譯、執行、除錯，直到沒有錯誤為止。

一般的 Java 程式都是由一或多個類別（class）所組成，
\textbf{其中的一個類別至少要有一個命名為 public static void main 的方法（method），
而這個程式就是由 main 開始執行} 。
（透過網路瀏覽器執行的 Java applet 不適用此規則。）

上例中的 public class EnglishExam 是指定 EnglishExam 這個類別是 public 是公用的，
也就是可以被程式中其他的類別引用。而 public static void main(String argv{[}{]}) 的意義是：
\begin{enumerate}
\item {} 
public：指定 main 為一個可以被其他類別使用的 public method；

\item {} 
static：指定 main 為一個類別方法（static method），一個類別方法隸屬於一個 class；

\item {} 
void：代表 main 執行完畢後回傳的型態，因為 main 沒有回傳任何數值，因此它的回傳型態是 void；

\item {} 
String argv{[}{]}：指這個方法的輸入參數是 argv{[}{]} 而 String 則是它的型態。
main 的輸入參數 String argv{[}{]} 可以在執行一個 Java 程式時將字串（String）資料輸入這個程式。
例如在編譯以下的程式之後：

\end{enumerate}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{HelloJava} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{argv}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"Hello "} \PYG{o}{+} \PYG{n}{argv}\PYG{o}{[}\PYG{l+m+mi}{0}\PYG{o}{]} \PYG{o}{+} \PYG{n}{argv}\PYG{o}{[}\PYG{l+m+mi}{1}\PYG{o}{]}\PYG{o}{)}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

以「命令提示字元」執行：

\begin{Verbatim}[commandchars=@\[\]]
java HelloJava Basic C++
\end{Verbatim}

便會呼叫 System.out.println 並輸出：

\begin{Verbatim}[commandchars=@\[\]]
Hello Basic C++
\end{Verbatim}

這個程式的 argv{[}{]} 代表 argv 這個變數是一個陣列，
而 argv{[}0{]}、argv{[}1{]} 則取用 argv 內第0、1個儲存格的內容。

Java 程式中 \textbf{用大刮號 \{ \} 標示的 Block（區塊）} 是用來組織程式層次關係的語法。

例如上例的程式就有兩個區塊，一組用來標示 class 的區塊，
另一組則用來標示 main 的區域。區塊中可以包含其他的區塊，
在撰寫程式時也應注意要把區塊的內容往右縮排。
一組用來標示類別的區塊內，可以有數個變數與方法。
而一組用來標示方法的區塊內可以有一或多句以「；」結束的程式碼。這些程式碼共同構成了這個方法的 body。

為 Java 程式中使用的名字命名，有一個不成文的規定：
\textbf{類別名稱的第一個字母要用大寫} 。
\textbf{方法或變數的第一個字母則是小寫} ，
若有數個字合併時則 \textbf{後續的字的第一個字母也習慣用大寫} 。

\href{http://v2.plweb.org/webstart.groovy?mode=student\&course\_id=158\&lesson\_id=2\&class\_id=2011100006}{動手練習：修正程式碼的錯誤}


\chapter{Java 的變數、方法與型態}
\label{java_basis:java}\label{java_basis::doc}
一個電腦程式基本上是由兩部分組成：
\begin{enumerate}
\item {} 
資料：這部分的程式碼要為所處理的資料命名、指定其型態、並存放於記憶體中；

\item {} 
處理：這部分的程式碼要使用撰寫在方法（method）中的運算式、條件判斷式、迴圈，來存取資料、計算結果、然後輸出。

\end{enumerate}

這兩部分的內容（程式碼），不但是機器要知道如何執行，更要讓人（程式設計師）容易寫，也容易讀。
而讓程式碼易寫、易讀的最基本的方法，就像收拾家中的衣櫃一般：按照種類與性質，分別放置整齊。

Java語言整理程式碼的最基本的單元稱做「類別」。一個類別可以有儲存資料的「變數」與負責處理資料的「方法」。

「類別」可以提供兩種整理程式碼的方式：一種是以程式的邏輯結構當作分類的方式（俗稱的結構化程式設計）；
另一種則是以物件的種類來歸類。而有的時候，一個類別也可以同時提供這兩種方式。

以程式的邏輯結構（例如將迴圈的邏輯放入一個方法中，或將一個判斷分數高低的邏輯放入一個方法中）來分類時，
所使用到的變數稱為類別變數或static field，而所用到的方法稱為類別方法或static method。稱做static（靜態）的原因是，這類的變數與方法是在程式開始執行時便在記憶體中產生了，而且它們的壽命一直到程式結束時才結束。

以物件來歸類的話，則是將類別內的程式碼，看成是產生這種類別的物件的「規格」。
由於只是規格，所以只有在使用這個類別製造物件時，所對應的記憶體才會產生。
而這種在程式執行時「動態」產生的物件實例中的變數與方法，
稱為實例變數（instance variable），與實例方法（instance method）。

類別方法或實例方法，也需要自己有儲存資料的地方，而在類別方法或實例方法中儲存資料的變數，
都叫區域變數（local variable），意思是在一個方法所屬的區域內才可以使用的變數。

Java如何分區呢？主要是使用大刮號，例如：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZob{}}
        \PYG{o}{\PYGZob{}}
                \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
        \PYG{o}{\PYGZcb{}}
        \PYG{o}{\PYGZob{}}
                \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
        \PYG{o}{\PYGZcb{}}
        \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

程式語言的句子與一般說話的語言一樣是由基本的字詞（names）組合而成。
Java 為這些字詞命名的規定是一個字詞可以包含一個或多個英文字母、數字、\_ 及 \$ 所組成的字元，而第一個字元不可以是數字。

Java 語言有 public, class, void, if, while, for 等
\href{http://download-llnw.oracle.com/javase/tutorial/java/nutsandbolts/\_keywords.html}{保留字} 。
除了開始認識這些保留字的意義與用法之外，程式設計師所要學習的第一件事，
就是為儲存資料的 \textbf{變數} 與執行處理的 \textbf{方法} 命名。

\textbf{變數（variable）} 是程式中的一種字詞。
一個變數有一個 \textbf{名字（name）} 、一個 \textbf{資料值（value）} 、
一塊儲存資料值的 \textbf{記憶體} 以及這個資料值的 \textbf{型態（type）} （如 int、double 等）。
由於一個變數的型態，定義了這個變數的值所需要的記憶體的大小，
所以一個 Java 程式在編譯時，就可以知道如何為這些變數，在執行時，
配置適當大小的記憶體空間，以存放這些變數的值。

整的來說，Java 有三種變數：
\begin{enumerate}
\item {} 
\textbf{區域變數（local variable）} ：宣告在方法內或參數部分的變數；

\item {} 
\textbf{類別變數（class variable or static field）} ：在一個類別中以 static 宣告的變數；

\item {} 
\textbf{實例變數（instance variable or non-static field）} ：在一個類別中沒有使用 static 宣告的變數。

\end{enumerate}

Java 也有兩種方法：
\begin{enumerate}
\item {} 
\textbf{類別方法（class method or static method）} ：
這種方法以 static 宣告。呼叫的方式是 C.m(...)，其中 C 是類別名稱，m 是方法名稱，...則是0至多個傳入的參數。

\item {} 
\textbf{實例方法（instance method or non-static method）} ：
這種方法不以 static 宣告，隸屬於一個類別所產生的實例。呼叫的方式是 o.m(...)，
其中 o 是這個類別或其子類別的實例，而 m 是其方法名稱，...則是0至多個傳入的參數。

\end{enumerate}

Java 之所以有種類這麼多的變數與方法，
是因為 Java 同時支援結構化（例如：C 與 Basic）與物件導向兩種普遍使用的程式設計方式。
撰寫結構化程式時需要使用類別變數與類別方法。類別變數在概念上與結構化程式語言的全域變數（global variable）一致；
而類別方法在概念上則與結構化程式語言的函式（function）或程序（procedure）一致。
實例變數、實例方法，則屬物件導向程式設計的功能。一般的 Java 程式可以同時使用結構化與物件導向並存的方式設計程式。

這份講義介紹 Java 結構化程式設計的語法及語意，
另一份講義《Java 物件導向程式設計》則介紹 Java 物件導向程式設計的功能。

此外，Java 變數的型態也有兩大類：
\begin{enumerate}
\item {} 
\textbf{primitive type} ，包括： \href{http://download-llnw.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html}{int、double、boolean、char} 等。

\item {} \begin{description}
\item[{\textbf{reference type} ，包括：}] \leavevmode\begin{enumerate}
\item {} 
類別型態：經由類別（class）的宣告而得到。如果 Car 是一個類別，而 aCar 是一個這個類別的變數，則 Car 便是 aCar 的型態（type）。之所以稱為 reference type，是因為 aCar 這個變數在記憶體中的位置，實際上是存著指向（reference）一個 Car 實例的地址。

\item {} 
介面型態：經由介面（interface）的宣告而得到。

\item {} 
陣列（array）型態。

\item {} 
enum 型態：一種特別的類別宣告方式，用於宣告月份、一週的七天等。

\end{enumerate}

\end{description}

\end{enumerate}


\chapter{區域變數與基本資料型態}
\label{java_vartype::doc}\label{java_vartype:id1}
區域變數是一個方法的參數或是宣告在一個方法的區塊中。
以下是宣告區域變數的幾個範例，其中 int 代表整數，而 double 代表倍精準浮點數，
宣告的意義是告訴編譯器一個變數的型態是什麼：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{EnglishExam} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{argv}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{c+c1}{// argv 是傳入參數，同時也是一種區域變數}

                \PYG{c+c1}{// 宣告三個區域變數}
                \PYG{k+kt}{int} \PYG{n}{vocabulary}\PYG{o}{;}
                \PYG{k+kt}{int} \PYG{n}{grammar}\PYG{o}{;}
                \PYG{k+kt}{int} \PYG{n}{listening}\PYG{o}{;}
                \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

多個變數的宣告，可以合併在一行：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{EnglishExam} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{argv}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{c+c1}{// 將以上三個區域變數，合併在一行}
                \PYG{k+kt}{int} \PYG{n}{vocabulary}\PYG{o}{,} \PYG{n}{grammar}\PYG{o}{,} \PYG{n}{listening}\PYG{o}{;}
                \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

宣告變數時，也可以同時指定數值：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{EnglishExam} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{argv}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{c+c1}{// 在宣告時也將數值存入這三個區域變數中}
                \PYG{k+kt}{int} \PYG{n}{vocabulary} \PYG{o}{=} \PYG{l+m+mi}{24}\PYG{o}{;}
                \PYG{k+kt}{int} \PYG{n}{grammar} \PYG{o}{=} \PYG{l+m+mi}{26}\PYG{o}{;}
                \PYG{k+kt}{int} \PYG{n}{listening} \PYG{o}{=} \PYG{l+m+mi}{33}\PYG{o}{;}
                \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{EnglishExam} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{argv}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{c+c1}{// 也可以這樣寫：}
                \PYG{k+kt}{double} \PYG{n}{vocabulary} \PYG{o}{=} \PYG{l+m+mf}{22.5}\PYG{o}{,} \PYG{n}{grammar} \PYG{o}{=} \PYG{l+m+mf}{25.4}\PYG{o}{,} \PYG{n}{listening} \PYG{o}{=} \PYG{l+m+mf}{32.0}\PYG{o}{;}
                \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

有了變數之後，可以使用設值運算符號（=），將數值存入區域變數中，
如果一個區域變數尚未被存入數值，則其預設值（default value）會被存入，而數字的預設值是 0。例如：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{EnglishExam} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{argv}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{k+kt}{int} \PYG{n}{vocabulary}\PYG{o}{,} \PYG{n}{grammar}\PYG{o}{,} \PYG{n}{listening}\PYG{o}{;}
                \PYG{k+kt}{int} \PYG{n}{score}\PYG{o}{;}

                \PYG{n}{vocabulary} \PYG{o}{=} \PYG{l+m+mi}{22}\PYG{o}{;}
                \PYG{n}{grammar} \PYG{o}{=} \PYG{l+m+mi}{26}\PYG{o}{;}
                \PYG{n}{score} \PYG{o}{=} \PYG{n}{vocabulary} \PYG{o}{+} \PYG{n}{grammar} \PYG{o}{+} \PYG{n}{listening}\PYG{o}{;}

                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{print}\PYG{o}{(}\PYG{l+s}{"The score of the exam is "}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{score}\PYG{o}{)}\PYG{o}{;}
                \PYG{c+c1}{// listening 的預設值是0, 所以印出 48}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

以上程式碼執行的結果為：

\begin{Verbatim}[commandchars=@\[\]]
The score of the exam is 48
\end{Verbatim}

Java的註解是以 \textbf{//} 或 \textbf{/* */} 表示，例如：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// 這是註解}
\PYG{c+cm}{/*}
\PYG{c+cm}{   這也是註解}
\PYG{c+cm}{   這還是註解}
\PYG{c+cm}{*/}
\end{Verbatim}


\chapter{螢幕輸出及鍵盤輸入}
\label{java_stdio::doc}\label{java_stdio:id1}
螢幕輸出有幾種方式。
第一種是前面章節已經使用過的 System.out.print 及 System.out.println。
這兩種方法的的差別是前者沒有換行，而後者有換行。
如果有數個資料需要一起印出時，則可以使用 + 進行串接。例如：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Show} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{argv}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{k+kt}{int} \PYG{n}{design}\PYG{o}{,} \PYG{n}{acting}\PYG{o}{;}

                \PYG{n}{design} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{o}{;}
                \PYG{n}{acting} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(} \PYG{l+s}{"Design is "} \PYG{o}{+} \PYG{n}{design} \PYG{o}{+} \PYG{l+s}{"and acting is "} \PYG{o}{+} \PYG{n}{acting} \PYG{o}{)}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

第二種方式是在 J2SDK5 之後才支援 \footnote{
System.out.printf(), \href{http://www.java2s.com/Code/JavaAPI/java.lang/System.out.printf.htm}{http://www.java2s.com/Code/JavaAPI/java.lang/System.out.printf.htm}
} 。
這個方式與 C 語言的 printf 功能類似。例如：

\begin{Verbatim}[commandchars=@\[\]]
System.out.printf("Today is @%s, @%d.\n", "January", 18);
// @%s 的位置替換成 January 這個 String
// @%d 的位置替換成 18 這個整數
// \n 表示換行符號
\end{Verbatim}

顯示：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Today} \PYG{o+ow}{is} \PYG{n}{January}\PYG{p}{,} \PYG{l+m+mi}{18}
\end{Verbatim}

例如：

\begin{Verbatim}[commandchars=@\[\]]
double score = 92.345
System.out.printf("My score is @%.2f.\n", score);
// @%.2f 的意義是小數點以下取兩位，並四捨五入。
System.out.printf("My score is @%6.2f.@%n", score);
// @%6.2f 的意義是：包括小數點共6位，小數點以下取兩位，
// 並四捨五入。所以9的左邊多空一格。
\end{Verbatim}

顯示：

\begin{Verbatim}[commandchars=@\[\]]
My score is 92.35.
My score is  92.35.
\end{Verbatim}

鍵盤輸入則可以透過 \footnote{
java.util.Scanner, \href{http://www.java2s.com/Code/JavaAPI/java.util/Scanner.htm}{http://www.java2s.com/Code/JavaAPI/java.util/Scanner.htm}
} 。例如：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// 使用時先載入 Scanner 所屬的 package}
\PYG{k+kn}{import} \PYG{n+nn}{java.util.*}\PYG{o}{;}  \PYG{c+c1}{// * 的意義是 java.util 內所有的類別}

\PYG{c+c1}{// 定義物件：}
\PYG{n}{Scanner} \PYG{n}{scanner} \PYG{o}{=} \PYG{k}{new} \PYG{n}{Scanner}\PYG{o}{(}\PYG{n}{System}\PYG{o}{.}\PYG{n+na}{in}\PYG{o}{)}\PYG{o}{;}

\PYG{c+c1}{// 輸入字串：}
\PYG{n}{String} \PYG{n}{name} \PYG{o}{=} \PYG{n}{scanner}\PYG{o}{.}\PYG{n+na}{nextLine}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}

\PYG{c+c1}{// 輸入整數：}
\PYG{k+kt}{int} \PYG{n}{score} \PYG{o}{=} \PYG{n}{scanner}\PYG{o}{.}\PYG{n+na}{nextInt}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}

\PYG{c+c1}{// 輸入double}
\PYG{k+kt}{double} \PYG{n}{height} \PYG{o}{=} \PYG{n}{scanner}\PYG{o}{.}\PYG{n+na}{nextDouble}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}

\PYG{c+c1}{// 輸入float}
\PYG{k+kt}{float} \PYG{n}{weight} \PYG{o}{=} \PYG{n}{scanner}\PYG{o}{.}\PYG{n+na}{nextFloat}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
\end{Verbatim}

以下是一個完整的範例：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{java.util.*}\PYG{o}{;}

\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{EnglishExam} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{argv}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{k+kt}{int} \PYG{n}{vocab}\PYG{o}{,} \PYG{n}{grammar}\PYG{o}{,} \PYG{n}{listen}\PYG{o}{,} \PYG{n}{score}\PYG{o}{;}

                \PYG{n}{Scanner} \PYG{n}{scanner} \PYG{o}{=} \PYG{k}{new} \PYG{n}{Scanner}\PYG{o}{(}\PYG{n}{System}\PYG{o}{.}\PYG{n+na}{in}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{String} \PYG{n}{name} \PYG{o}{=} \PYG{n}{scanner}\PYG{o}{.}\PYG{n+na}{nextLine}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{vocab} \PYG{o}{=} \PYG{n}{scanner}\PYG{o}{.}\PYG{n+na}{nextInt}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{grammar} \PYG{o}{=} \PYG{n}{scanner}\PYG{o}{.}\PYG{n+na}{nextInt}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{listen} \PYG{o}{=} \PYG{n}{scanner}\PYG{o}{.}\PYG{n+na}{nextInt}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{score} \PYG{o}{=} \PYG{n}{vocab} \PYG{o}{+} \PYG{n}{grammar} \PYG{o}{+} \PYG{n}{listen}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{printf}\PYG{o}{(}\PYG{l+s}{"The total score of \PYGZpc{}s is \PYGZpc{}d.\PYGZpc{}n"}\PYG{o}{,} \PYG{n}{name}\PYG{o}{,} \PYG{n}{score}\PYG{o}{)}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}


\chapter{算術運算式}
\label{java_expr::doc}\label{java_expr:id1}
使用算術運算式要注意的是運算的優先次序。
例如：先乘除、後加減。如果不記得運算的優先次序，那麼最簡便的方法是使用（）也就是指定內層的刮號先執行。
以下是算術運算式的幾個範例：

使用算術運算式另一項要注意的是型態的轉換，也就是在一個算術式中同時有整數與浮點數時，
Java 會將整數先轉換成浮點數然後再進行運算。

例如：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{o}{(}\PYG{l+m+mi}{3} \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{o}{)} \PYG{o}{/}  \PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{o}{*}  \PYG{c+c1}{// 兩個整數相除，結果仍是整數，小數部分捨棄。傳回 2}
\PYG{k+kt}{double} \PYG{n}{f}\PYG{o}{;}
\PYG{n}{f} \PYG{o}{=} \PYG{o}{(}\PYG{l+m+mi}{3} \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{o}{)} \PYG{o}{/}  \PYG{o}{*}\PYG{o}{*}\PYG{l+m+mf}{3.0}\PYG{o}{*}\PYG{o}{*}    \PYG{c+c1}{// 7 轉型成浮點數，然後與浮點數 3.0 相除。傳回 2.333...}
\PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{i}\PYG{o}{)}\PYG{o}{;}
\PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{f}\PYG{o}{)}\PYG{o}{;}
\end{Verbatim}

印出：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{2}
\PYG{l+m+mf}{2.3333333333333335}
\end{Verbatim}

如果需要指定轉換的型態，則可以使用以下的方式：

至於 i、f 的原來的值還是不變。

如同一般的算術運算式，設值運算式（=）也會傳回值。例如：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{3}         \PYG{c+c1}{// 傳回 3}
\PYG{n}{y} \PYG{o}{=} \PYG{o}{(}\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{o}{)}   \PYG{c+c1}{// 因為 x = 3 傳回3, 所以 y 的值也設成 3}
\end{Verbatim}

自動將資料範圍較小的型態轉為資料範圍較大的型態，稱為自動轉型 (promotion)。
Java 資料型態範圍之大小次序為：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{byte} \PYG{o}{\textless{}} \PYG{n}{short} \PYG{o}{\textless{}} \PYG{n+nb}{int} \PYG{o}{\textless{}} \PYG{n+nb}{long} \PYG{o}{\textless{}} \PYG{n+nb}{float} \PYG{o}{\textless{}} \PYG{n}{double}
\end{Verbatim}

以下的例子會出現 possible loss of precision 的錯誤：

這個錯誤是因為a會自動轉型成較大的 long 再跟 b 相加，
但是 int 型態的 c 放不下 long 的資料。
此時就要透過強制轉型(casting)，將 a 轉型成 int：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n}{c} \PYG{o}{=} \PYG{o}{(}\PYG{k+kt}{int}\PYG{o}{)}\PYG{o}{(}\PYG{n}{a} \PYG{o}{+} \PYG{n}{b}\PYG{o}{)}\PYG{o}{;}
\end{Verbatim}

當資料型態由小轉為大時，會自動轉型；
當資料型態由大轉為小時，則需強迫轉型。


\chapter{類別變數與類別方法}
\label{java_static::doc}\label{java_static:id1}
非物件導向程式語言（例如：C），程式設計師主要是使用函式（function、
全域變數與區域變數將一個大的程式分割成幾個小的部份，以簡化程式的撰寫。
這些觀念在 Java 中仍然可以使用，而使用的方式是透過類別變數與類別方法。

舉例而言，如果要為英文檢定考試寫一個計算成績的程式，
那麼這個程式應該有一個計算成績的方法。例如：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{EnglishExam} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{int} \PYG{n+nf}{englishScore}\PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{v}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{g}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{l}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{k}{return} \PYG{n}{v} \PYG{o}{+} \PYG{n}{g} \PYG{o}{+} \PYG{n}{l}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{argv}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{print}\PYG{o}{(}\PYG{l+s}{"The score of the exam is "}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{englishScore}\PYG{o}{(}\PYG{l+m+mi}{24}\PYG{o}{,} \PYG{l+m+mi}{27}\PYG{o}{,} \PYG{l+m+mi}{32}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

執行結果：

\begin{Verbatim}[commandchars=@\[\]]
The score of the exam is 83
\end{Verbatim}

public static int englishScore(int v, int g, int l) 定義了 englishScore 這個類別方法，
這個方法有三個命名為 v, g, l 的輸入參數，它們的型態都是 int。
這個方法的輸出型態也是 int，也就是會使用 return 傳出一個 int 的值 (v + g + l)。
Java 使用 static 這個保留字來定義類別方法。因為這種方法是靜態的，
也就是在程式執行時，呼叫這個方法的程式碼，一定都會執行相同的方法。

在 main 中的 System.out.println(englishScore(24, 27, 32))
將 24, 27, 32 傳入 englishScore 中，並依序成為 v, g, l 三個輸入參數的值，
而這三個數相加的結果 83 會繼續的傳入 System.out.println，然後顯示在螢幕上。
一個方法的輸入參數也是那個方法的區域變數。所以 v, g, l 三個輸入參數也是 englishScore 的區域變數。

除了直接將數值傳入方法中以外，還可以將變數或其他也有傳回值的式子，寫在方法呼叫中傳入的位置。例如：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{EnglishExam} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{int} \PYG{n+nf}{englishScore}\PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{v}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{g}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{l}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{k}{return} \PYG{n}{v} \PYG{o}{+} \PYG{n}{g} \PYG{o}{+} \PYG{n}{l}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{argv}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{k+kt}{int} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{o}{,} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{print}\PYG{o}{(}\PYG{l+s}{"The score of the exam is "}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{englishScore}\PYG{o}{(} \PYG{o}{*}\PYG{o}{*}\PYG{n}{a}\PYG{o}{,} \PYG{n}{b}\PYG{o}{,} \PYG{n}{a} \PYG{o}{+} \PYG{n}{b}\PYG{o}{*}\PYG{o}{*} \PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

執行結果：

\begin{Verbatim}[commandchars=@\[\]]
The score of the exam is 14
\end{Verbatim}

Java 會在得到 a, b, a + b 的數值後，才將 3, 4, 7 傳入 englishScore 中。
也就是先得到數值再傳入，然後 v, g, l 便使用傳入的數值生成三個區域變數。
這個特性稱為  \textbf{call-by-value 或傳值呼叫} 。
v, g, l 三個參數之所以也是區域變數，因為這三個變數的可見範圍（scope）只包含 englishScore 的區塊。

如果一個方法沒有傳回值，那麼這個方法的輸出型態便是 void。例如：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{EnglishExam} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static}  \PYG{o}{*}\PYG{o}{*}\PYG{k+kt}{void} \PYG{n}{displayScore}\PYG{o}{*}\PYG{o}{*} \PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{v}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{g}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{l}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{print}\PYG{o}{(}\PYG{l+s}{"The score of the exam is "}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{v} \PYG{o}{+} \PYG{n}{g} \PYG{o}{+} \PYG{n}{l}\PYG{o}{)}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}

        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{argv}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{n}{displayScore}\PYG{o}{(}\PYG{l+m+mi}{24}\PYG{o}{,} \PYG{l+m+mi}{27}\PYG{o}{,} \PYG{l+m+mi}{32}\PYG{o}{)}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

執行結果：

\begin{Verbatim}[commandchars=@\[\]]
The score of the exam is 83
\end{Verbatim}

displayScore 這個方法將字串顯示在螢幕上，不需要傳回值，
因此它的輸出型態是宣告成 void，而 main 的輸出型態也是 void。

不同的類別中也可以定義同名的方法。這個功能稱做  \textbf{overloading} 。
而Java 是以 \textbf{類別名稱.方法名稱(0或多個參數)；} 呼叫宣告在不同類別的類別方法。例如：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Exam} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{argv}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{k+kt}{int} \PYG{n}{voc} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{o}{,} \PYG{n}{grammar} \PYG{o}{=} \PYG{l+m+mi}{7}\PYG{o}{,} \PYG{n}{listen} \PYG{o}{=} \PYG{l+m+mi}{8}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{print}\PYG{o}{(}\PYG{l+s}{"The score of the english exam is "}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{EnglishExam}\PYG{o}{.}\PYG{n+na}{displayScore}\PYG{o}{(}\PYG{n}{voc}\PYG{o}{,} \PYG{n}{grammar}\PYG{o}{,} \PYG{n}{listen}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{print}\PYG{o}{(}\PYG{l+s}{"The score of simple english exam is "}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{SimpleEnglishExam}\PYG{o}{.}\PYG{n+na}{displayScore}\PYG{o}{(}\PYG{n}{voc}\PYG{o}{,} \PYG{n}{grammar}\PYG{o}{,} \PYG{n}{listen}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}

\PYG{k+kd}{class} \PYG{n+nc}{EnglishExam} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{int} \PYG{n+nf}{displayScore}\PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{v}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{g}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{l}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{k}{return} \PYG{n}{v} \PYG{o}{+} \PYG{n}{g} \PYG{o}{+} \PYG{n}{l}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}

\PYG{k+kd}{class} \PYG{n+nc}{SimpleEnglishExam} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{int} \PYG{n+nf}{displayScore}\PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{v}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{g}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{l}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{k}{return} \PYG{n}{v} \PYG{o}{+} \PYG{n}{g} \PYG{o}{+} \PYG{l+m+mi}{0}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

執行結果：

\begin{Verbatim}[commandchars=@\[\]]
The score of the english exam is 18
The score of simple english exam is 10
\end{Verbatim}

一個類別中也可以有同名的方法，但是他們必須有不同的輸出入型態。例如：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Exam} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{argv}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{k+kt}{int} \PYG{n}{voc} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{o}{,} \PYG{n}{grammar} \PYG{o}{=} \PYG{l+m+mi}{7}\PYG{o}{,} \PYG{n}{listen} \PYG{o}{=} \PYG{l+m+mi}{8}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{print}\PYG{o}{(}\PYG{l+s}{"The int score of the exam is "}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(} \PYG{o}{*}\PYG{o}{*}\PYG{n}{EnglishExam}\PYG{o}{.}\PYG{n+na}{displayScore}\PYG{o}{(}\PYG{l+m+mi}{3}\PYG{o}{,} \PYG{l+m+mi}{7}\PYG{o}{,} \PYG{l+m+mi}{8}\PYG{o}{)}\PYG{o}{*}\PYG{o}{*} \PYG{o}{)}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{print}\PYG{o}{(}\PYG{l+s}{"The double score of the exam is "}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(} \PYG{o}{*}\PYG{o}{*}\PYG{n}{EnglishExam}\PYG{o}{.}\PYG{n+na}{displayScore}\PYG{o}{(}\PYG{l+m+mf}{3.0}\PYG{o}{,} \PYG{l+m+mf}{8.0}\PYG{o}{,} \PYG{l+m+mf}{7.0}\PYG{o}{)}\PYG{o}{*}\PYG{o}{*} \PYG{o}{)}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}

\PYG{k+kd}{class} \PYG{n+nc}{EnglishExam} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{int}  \PYG{o}{*}\PYG{o}{*}\PYG{n}{displayScore}\PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{v}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{g}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{l}\PYG{o}{)}\PYG{o}{*}\PYG{o}{*}  \PYG{o}{\PYGZob{}}
                \PYG{k}{return} \PYG{n}{v} \PYG{o}{+} \PYG{n}{g} \PYG{o}{+} \PYG{n}{l}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{double}  \PYG{o}{*}\PYG{o}{*}\PYG{n}{displayScore}\PYG{o}{(}\PYG{k+kt}{double} \PYG{n}{v}\PYG{o}{,} \PYG{k+kt}{double} \PYG{n}{g}\PYG{o}{,} \PYG{k+kt}{double} \PYG{n}{l}\PYG{o}{)}\PYG{o}{*}\PYG{o}{*}  \PYG{o}{\PYGZob{}}
                \PYG{k}{return} \PYG{n}{v} \PYG{o}{+} \PYG{n}{g} \PYG{o}{+} \PYG{n}{l}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

執行結果：

\begin{Verbatim}[commandchars=@\[\]]
The int score of the exam is 18
The double score of the exam is 18.0
\end{Verbatim}

另一個 overloading 的例子是：＋。＋可以用來將數字相加，也可以將字串合併。例如：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{o}{,} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{o}{;}
\PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{print}\PYG{o}{(}\PYG{l+m+mi}{3} \PYG{o}{+} \PYG{n}{a} \PYG{o}{+} \PYG{n}{b}\PYG{o}{)}\PYG{o}{;}
\end{Verbatim}

執行結果：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{12}
\end{Verbatim}

例如：

\begin{Verbatim}[commandchars=@\[\]]
.. code-block:: java
\end{Verbatim}
\begin{quote}

String a = ``xy'', b = ``Z'';
System.out.print(``3'' + a + b);
\end{quote}

執行結果：

\begin{Verbatim}[commandchars=@\[\]]
3xyz
\end{Verbatim}

使用類別方法在程式中有許多好處：
\begin{enumerate}
\item {} 
增加程式碼的再用性：同樣的計算步驟，只需要透過呼叫類別方法便可以重複使用。

\item {} 
讓程式碼的細節，被隱藏在類別方法中：程式設計師在完成類別方法的撰寫後，便只需要知道那個類別方法的輸入、輸出與功用即可，而不用擔心執行的細節。

\item {} 
容易除錯：除錯的過程可以一個類別方法、一個類別方法的進行，容易找出錯誤的根源。

\item {} 
容易擴充類別方法內程式碼的功能：只要在類別方法內擴充其功能，而不用在每次呼叫時都重複的擴充。例如以下的程式碼擴充了成績的計算方式，所有 displayScore 的呼叫的計算結果都同步改變：

\end{enumerate}

除了使用 static 宣告類別方法外，還有也是使用 static 宣告的類別變數。
以下是一個在程式中內建三筆考試成績的資料，呼叫 displayScore 計算成績後，
將三筆資料加總並存入 total 這個類別變數中的範例：

\begin{Verbatim}[commandchars=@\[\]]
.. code-block:: java
\end{Verbatim}
\begin{quote}
\begin{description}
\item[{public class Exam \{}] \leavevmode
public static int total = 0;
\begin{description}
\item[{public static void main(String argv{[}{]}) \{}] \leavevmode
total = displayScore(3, 4, 5); // total = 12
total = total + displayScore(4, 5, 6);          // total = 27
total = total + displayScore(1, 2, 3);          // total = 33
System.out.print(``The total score is '');
System.out.println(total);

\end{description}

\}
\begin{description}
\item[{public static int displayScore(int v, int g, int l) \{}] \leavevmode
return v + g + l;

\end{description}

\}

\end{description}

\}
\end{quote}

執行結果：

\begin{Verbatim}[commandchars=@\[\]]
The total score is 33
\end{Verbatim}

程式設計師也可以使用不是定義在自己類別中的類別變數，而 Java 是以 \textbf{類別名稱.變數名稱}
使用定義在其他類別中的類別變數。以下便是一種將 total 宣告在另一個類別 EnglishExam 中的寫法是：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Exam} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{argv}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{n}{EnglishExam}\PYG{o}{.}\PYG{n+na}{computeScore}\PYG{o}{(}\PYG{l+m+mi}{3}\PYG{o}{,} \PYG{l+m+mi}{4}\PYG{o}{,} \PYG{l+m+mi}{5}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{EnglishExam}\PYG{o}{.}\PYG{n+na}{computeScore}\PYG{o}{(}\PYG{l+m+mi}{4}\PYG{o}{,} \PYG{l+m+mi}{5}\PYG{o}{,} \PYG{l+m+mi}{6}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{EnglishExam}\PYG{o}{.}\PYG{n+na}{computeScore}\PYG{o}{(}\PYG{l+m+mi}{1}\PYG{o}{,} \PYG{l+m+mi}{2}\PYG{o}{,} \PYG{l+m+mi}{3}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{print}\PYG{o}{(}\PYG{l+s}{"The total score is "}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{EnglishExam}\PYG{o}{.}\PYG{n+na}{total}\PYG{o}{)}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}

\PYG{k+kd}{class} \PYG{n+nc}{EnglishExam} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{int} \PYG{n}{total} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{;}

        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{computeScore}\PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{v}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{g}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{l}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{n}{total} \PYG{o}{=} \PYG{n}{total} \PYG{o}{+} \PYG{o}{(}\PYG{n}{v} \PYG{o}{+} \PYG{n}{g} \PYG{o}{+} \PYG{n}{l}\PYG{o}{)}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

執行結果：

\begin{Verbatim}[commandchars=@\[\]]
The total score is 33
\end{Verbatim}

以下則是一個為考試成績的計算，加入權重的範例。
在這個範例中是以 Exam.wV, Exam.wG, Exam.wL 來使用這三個類別變數：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Exam} \PYG{o}{\PYGZob{}}

        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{double} \PYG{n}{wV} \PYG{o}{=} \PYG{l+m+mf}{0.3}\PYG{o}{,} \PYG{n}{wG} \PYG{o}{=} \PYG{l+m+mf}{0.3}\PYG{o}{,} \PYG{n}{wL} \PYG{o}{=} \PYG{l+m+mf}{0.4}\PYG{o}{;}

        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{argv}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{k+kt}{int} \PYG{n}{voc} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{o}{,} \PYG{n}{grammar} \PYG{o}{=} \PYG{l+m+mi}{7}\PYG{o}{,} \PYG{n}{listen} \PYG{o}{=} \PYG{l+m+mi}{8}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{print}\PYG{o}{(}\PYG{l+s}{"The score of the english exam is "}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{EnglishExam}\PYG{o}{.}\PYG{n+na}{displayScore}\PYG{o}{(}\PYG{n}{voc}\PYG{o}{,} \PYG{n}{grammar}\PYG{o}{,} \PYG{n}{listen}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{print}\PYG{o}{(}\PYG{l+s}{"The score of simple english exam is "}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{SimpleEnglishExam}\PYG{o}{.}\PYG{n+na}{displayScore}\PYG{o}{(}\PYG{n}{voc}\PYG{o}{,} \PYG{n}{grammar}\PYG{o}{,} \PYG{n}{listen}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}

\PYG{k+kd}{class} \PYG{n+nc}{EnglishExam} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{double} \PYG{n+nf}{displayScore}\PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{v}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{g}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{l}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{v} \PYG{o}{*} \PYG{n}{Exam}\PYG{o}{.}\PYG{n+na}{wV} \PYG{o}{+} \PYG{n}{g} \PYG{o}{*} \PYG{n}{Exam}\PYG{o}{.}\PYG{n+na}{wG} \PYG{o}{+} \PYG{n}{l} \PYG{o}{*} \PYG{n}{Exam}\PYG{o}{.}\PYG{n+na}{wL}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}

\PYG{k+kd}{class} \PYG{n+nc}{SimpleEnglishExam} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{double} \PYG{n+nf}{displayScore}\PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{v}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{g}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{l}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{k}{return} \PYG{n}{v} \PYG{o}{*} \PYG{n}{Exam}\PYG{o}{.}\PYG{n+na}{wV} \PYG{o}{+} \PYG{n}{g} \PYG{o}{*} \PYG{n}{Exam}\PYG{o}{.}\PYG{n+na}{wG} \PYG{o}{+} \PYG{l+m+mi}{0}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

執行結果：

\begin{Verbatim}[commandchars=@\[\]]
The score of the english exam is 6.2
The score of simple english exam is 3.0
\end{Verbatim}

類別變數與區域變數，在變數的可用「區域」與存在的「時間」上都不相同。類別變數若是定義為 public，則它的可用區域便包括整個程式，而且在整個程式執行時都存在。區域變數則是在程式執行到一個區塊或方法內時，那個區塊或方法的區域變數才存在，一旦離開那個區塊或方法，便消失了。因此區域變數的可用區域，只在定義該區域變數的區塊或方法內。

以下是一個「計算蛋與水果總價」的程式及其執行過程的動畫：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{class} \PYG{n+nc}{Market} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{static} \PYG{k+kt}{int} \PYG{n}{sEgg} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{o}{,} \PYG{n}{sFruit} \PYG{o}{=} \PYG{l+m+mi}{20}\PYG{o}{;}
                \PYG{k+kd}{static} \PYG{k+kt}{int} \PYG{n+nf}{getMoney}\PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{nEgg}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{nFruit}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{k}{return} \PYG{n}{sEgg} \PYG{o}{*} \PYG{n}{nEgg} \PYG{o}{+} \PYG{n}{sFruit} \PYG{o}{*} \PYG{n}{nFruit}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}

\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Ex1} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String} \PYG{n}{argv}\PYG{o}{[}\PYG{o}{]}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{k+kt}{int} \PYG{n}{egg} \PYG{o}{=} \PYG{l+m+mi}{20}\PYG{o}{,} \PYG{n}{fruit} \PYG{o}{=} \PYG{l+m+mi}{30}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{print}\PYG{o}{(}\PYG{l+s}{"Money:"}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{Market}\PYG{o}{.}\PYG{n+na}{getMoney}\PYG{o}{(}\PYG{n}{egg}\PYG{o}{,} \PYG{n}{fruit}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

執行結果：

\begin{Verbatim}[commandchars=@\[\]]
Money:700
\end{Verbatim}

Media:Ex1new.swf 觀看執行過程


\chapter{運算式、句子與條件判斷句}
\label{java_cond::doc}\label{java_cond:id1}
運算式（expression）執行完畢會後傳回一個值；句子（statement）在執行之後，則不回傳值。一個運算式與句子在執行時都可能會改變電腦的狀態，例如：更改變數、陣列或檔案的內容。算術運算式已經介紹了，而最簡單的句子，包括：
\begin{enumerate}
\item {} 
expression statement：在運算式後加一個 '';'' 。

\item {} 
block statement：在 \{ \} 內可以有 0 或多個變數宣告或句子。

\end{enumerate}

這兩種句子，也都已經看過範例。這個單元將介紹關係運算式、邏輯運算式及 if、switch等句子。


\section{關係運算式}
\label{java_cond:id2}
以下是在寫關係運算式（relational expression）時常常會使用到的關係運算子（relational operator），整理如下：
\begin{itemize}
\item {} 
需注意關係運算式使用的  \textbf{``==''}  ，和寫設值運算式（assignment expression）的 ``='' 是不一樣的。

\end{itemize}


\section{邏輯運算式}
\label{java_cond:id3}
Java 常用的邏輯運算子（logical operators）有三個，分別是 \&\& (AND)、\textbar{}\textbar{} (OR)、! (NOT)。
邏輯運算式使用邏輯運算子以連結二個或以上的關係運算式。
\begin{itemize}
\item {} 
\&\& (AND)

\end{itemize}

\&\& 是「AND（且）」運算：左右二邊「都」為 true，結果為 true；其餘情況其結果都為 false。

如果左邊為 false，則系統就不會去執行右邊；
因為結果必為 false；既然左邊已經為 false，不管右邊結果為何，結果一定為 false。
\begin{itemize}
\item {} 
\textbar{}\textbar{} (OR)

\end{itemize}

\textbar{}\textbar{} 是「OR（或）」運算，左右二邊只要有一邊為 true，結果為 true；只有左右二邊都為 false，結果才為 false。

如果左邊為 true，則系統就不會去執行右邊；因為結果必為 true；
即然左邊已經為 true，不管右邊結果為何，結果一定為 true。
\begin{itemize}
\item {} 
! (NOT)

\end{itemize}

! 是「NOT（相反）」運算，其結果為 ! 右邊的相反。


\section{運算子的優先順序}
\label{java_cond:id4}
以下是在在寫運算式時常常會使用到的運算子的優先順序，整理如下：

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{
優先順序
} & \textbf{
運算子
}\\
\hline

1
 & 
\textbf{(} (左括號)  \textbf{)} (右括號) \textbf{++} (左遞增) \textbf{--} (左遞減)
\\

2
 & 
\textbf{+} (正) \textbf{-} (負) \textbf{!} (NOT) \textbf{++} (右遞增) \textbf{--} (右遞減)
\\

3
 & 
\textbf{*} (乘) \textbf{/} (除) \textbf{\%} (取餘數)
\\

4
 & 
\textbf{+} (加) \textbf{-} (減)
\\

5
 & 
\textbf{\textless{}} (小於) \textbf{\textless{}=} (小於等於) \textbf{\textgreater{}} (大於) \textbf{\textgreater{}=} (大於等於)
\\

6
 & 
\textbf{==} (等於) \textbf{!=} (不等於)
\\

7
 & 
\textbf{\&\&} (AND)
\\

8
 & 
\textbf{\textbar{}\textbar{}} (OR)
\\

9
 & 
\textbf{?:} (條件判斷)
\\
\hline
\end{tabulary}


上表雖然不易記憶，然而，由於 ``('' 與 '')'' 的優先順序是最優先，
所以在程式的設計過程中，我們可以藉由使用左、右括號來指定運算式的優先順序。

立即練習：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{48}
\PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{32}
\PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{55}

\PYG{n}{d} \PYG{o}{=} \PYG{n}{a}\PYG{o}{\textgreater{}}\PYG{n}{b}\PYG{o}{?}\PYG{n}{a}\PYG{o}{+}\PYG{n}{b}\PYG{o}{+}\PYG{o}{+}\PYG{o}{*}\PYG{o}{-}\PYG{o}{-}\PYG{n+nl}{c:}\PYG{n}{a}\PYG{o}{-}\PYG{n}{b}\PYG{o}{-}\PYG{o}{-}\PYG{o}{*}\PYG{o}{+}\PYG{o}{+}\PYG{n}{c}
\end{Verbatim}
\begin{enumerate}
\item {} 
請問 d 的值是多少？

\end{enumerate}

上面的程式碼，讀者可能需要查閱運算子優先次序，才能計算輸出的值是多少，
雖然對電腦來說，可以很快就按照規則計算出正確的數字，
但畢竟程式碼是由「人」撰寫和維護，要記住這些瑣碎的規則可是一點都不容易。

請再嘗試以下的練習：
\begin{enumerate}
\item {} 
在上一個練習的程式碼加上 ( ) 括號，讓你自己可以很容易看懂計算的優先次序。

\end{enumerate}


\section{Java 條件判斷句的種類}
\label{java_cond:java}
Java 的條件判斷句（statement）可以分成以下 3 種：
\begin{enumerate}
\item {} 
if...

\item {} 
if... else...

\item {} 
switch

\end{enumerate}


\subsection{if 條件判斷句}
\label{java_cond:if}
Java 語言 if (...) \{...\} 條件判斷句的流程圖及語法如下：

Image If-1.png

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{o}{(}\PYG{c+cm}{/* 條件判斷 */}\PYG{o}{)} \PYG{o}{\PYGZob{}}
  \PYG{c+c1}{//條件判斷成立時執行的程式碼}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

說明：
\begin{enumerate}
\item {} 
如果第 1 行的條件判斷成立（值 == true），則會執行第 2 \textasciitilde{} 4 行的程式碼（圖形藍色的路徑）。而如果條件判斷不成立（值 == false），則會跳過第 2 \textasciitilde{} 4 行程式碼不執行（圖形黑色 False 的路徑）。

\item {} 
如果第 1 行的條件判斷成立時，執行的程式碼只有一行，則區塊符號可以省略不寫。如果超過一行，其區塊符號 \{ \} 不可以省略。

\end{enumerate}

Example 1：請設計一個 Java 程式，讓使用者自行輸入一個成績，判斷輸入的成績是否「大於或等於」60 ，如果是就輸出「成績及格！」。

Image If-2.png

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{java.util.Scanner}\PYG{o}{;}
\PYG{k+kd}{class} \PYG{n+nc}{if\PYGZus{}loop} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String}\PYG{o}{[}\PYG{o}{]} \PYG{n}{args}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{n}{if\PYGZus{}condition}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}

  \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{if\PYGZus{}condition}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{print}\PYG{o}{(}\PYG{l+s}{"請輸入成績:"}\PYG{o}{)}\PYG{o}{;}
    \PYG{n}{Scanner} \PYG{n}{scanner} \PYG{o}{=} \PYG{k}{new} \PYG{n}{Scanner}\PYG{o}{(}\PYG{n}{System}\PYG{o}{.}\PYG{n+na}{in}\PYG{o}{)}\PYG{o}{;}
    \PYG{k+kt}{int} \PYG{n}{grade} \PYG{o}{=} \PYG{n}{scanner}\PYG{o}{.}\PYG{n+na}{nextInt}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}

    \PYG{k}{if} \PYG{o}{(}\PYG{n}{grade} \PYG{o}{\textgreater{}}\PYG{o}{=} \PYG{l+m+mi}{60}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{"成績及格!"}\PYG{o}{)}\PYG{o}{;}
    \PYG{o}{\PYGZcb{}}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

執行結果：

\begin{Verbatim}[commandchars=@\[\]]
請輸入成績:60
成績及格!
\end{Verbatim}

說明：
\begin{itemize}
\item {} 
輸入的 grade 為 60 ，條件判斷的結果為 true（60 \textgreater{}= 60），會執行條件判斷成立區塊內的程式碼，輸出「成績及格!」（圖形藍色的路徑）。

\item {} 
因為範例中條件判斷成立時，執行的程式碼只有一行： System.out.println(``成績及格!''); 所以區塊符號可以省略不寫。

\end{itemize}


\subsection{if… else… 條件判斷句}
\label{java_cond:if-else}
Java 語言 if (...) \{...\} else \{...\} 條件判斷句的語法如下：

Image If-else-1.png

\begin{Verbatim}[commandchars=@\[\]]
if (條件判斷)
{
  條件判斷成立時執行的程式碼;
  ....
}
else
{
  條件判斷不成立時執行的程式碼;
  ....
}
\end{Verbatim}

說明：
\begin{itemize}
\item {} 
如果第 1 行的條件判斷成立（值 == true），則執行第 2 \textasciitilde{} 5 行區塊符號內的程式碼（圖形藍色的路徑）。

\item {} 
如果第 1 行的條件判斷不成立（值 ==false），則跳過第 2 \textasciitilde{} 5 行的程式碼，而執行第 7 \textasciitilde{} 10 行區塊符號內的程式碼（圖形紅色的路徑）。

\item {} 
如果 if 條件判斷成立或不成立時，執行的程式碼只有一行，則該區塊符號可以省略不寫。而如果超過一行，則區塊符號不可以省略。

\item {} 
if 和 else 是彼此互斥的關係，二個條件區塊在程式執行的過程中，只會選擇一個條件區塊去執行。

\end{itemize}

Example 2：請設計一個 Java 程式，讓使用者輸入一個成績，判斷該輸入的成績是否「大於或等於」60 ，如果是就輸出「成績及格!」；如果不是則輸出「成績不及格!」。

Image If-else-2.png

\begin{Verbatim}[commandchars=@\[\]]
import java.util.Scanner;

class if@_else@_loop {
  public static void main(String@PYGZlb[]@PYGZrb[] args) {
    if@_else@_condition();
    if@_else@_condition();
  }

  public static void if@_else@_condition() {
    System.out.print("請輸入成績:");
　　 Scanner scanner = new Scanner(System.in);
　　 int grade = scanner.nextInt();

　　 if (grade @textgreater[]= 60) {
      System.out.println("成績及格!");
　　 }
    else {
      System.out.println("成績不及格!");
    }
  }
}
\end{Verbatim}

執行結果：

\begin{Verbatim}[commandchars=@\[\]]
請輸入成績:88
成績及格!
請輸入成績:59
成績不及格!
\end{Verbatim}

說明：
\begin{itemize}
\item {} 
第一次輸入的 grade 為 88 ，其條件判斷的結果為 True（88 \textgreater{}= 60），執行 if 成立區塊內的程式碼，輸出 「成績及格!」（圖形藍色的路徑）。

\item {} 
第二次輸入的 grade 為 59 ，其條件判斷的結果為 False（59 \textgreater{}= 60），執行 else 區塊內的程式碼，輸出 「成績不及格!」（圖形紅色的路徑）。

\item {} 
因為 if 條件判斷成立和不成立時，執行的程式碼都只有一行，所以二者的區塊符號都可以省略不寫。

\end{itemize}


\subsection{數個 if 的條件判斷}
\label{java_cond:id5}
幾個接續在一起的 if 句子，可以寫成： if (...) \{...\} else if (...) \{...\} else \{...\}：

{[}{[}Image:If-elseif-else-1.png{]}{]}

\begin{Verbatim}[commandchars=@\[\]]
if (條件判斷1) {
  條件判斷1成立時執行的程式碼;
  ....
}
else if (條件判斷2) {
  條件判斷2成立時執行的程式碼;
  ....
}
：
：
else {
  上述條件判斷都不成立時執行的程式碼;
  ....
}
\end{Verbatim}

說明：
\begin{itemize}
\item {} 
如果在第 1 行的條件判斷1 成立（值 == true），則執行第 2 \textasciitilde{} 5 行區塊符號內的程式碼（圖形藍色的路徑），並略過其餘的程式碼。

\item {} 
如果在第 6 行的條件判斷2 成立（值 == true），則執行第 7 \textasciitilde{} 10 行區塊符號內的程式碼（圖形綠色的路徑），並略過其餘的程式碼。

\item {} 
如果所有的條件判斷都不成立（值 == false），則跳過第 1 \textasciitilde{} 12 行的程式碼，而執行第 14 \textasciitilde{} 17 行區塊符號內的程式碼 (圖形紅色的路徑) 。

\item {} 
if 、 else if 和 else 是彼此互斥的關係，所有條件區塊在程式執行的過程中，只會選擇一個條件區塊去執行。

\end{itemize}

Example 3：請設計一個 Java 程式，讓使用者自行輸入一個成績，判斷該輸入的成績是屬於 A, B, C, D 或 E 。

{[}{[}Image:If-elseif-else-2.png{]}{]}

\begin{Verbatim}[commandchars=@\[\]]
import java.util.Scanner;
class if@_elseif@_else@_loop {
　　public static void main(String@PYGZlb[]@PYGZrb[] args) {
　　　　if@_elseif@_else@_condition();
　　　　if@_elseif@_else@_condition();
　　　　if@_elseif@_else@_condition();
　　　　if@_elseif@_else@_condition();
　　　　if@_elseif@_else@_condition();
　　}

　　public static void if@_elseif@_else@_condition() {
　　　　System.out.print("請輸入成績:");
　　　　Scanner scanner = new Scanner(System.in);
　　　　int grade = scanner.nextInt();

　　　　if (grade @textgreater[]= 90)
　　　　　　System.out.println("成績為A");
　　　　else if (grade @textgreater[]= 80)
　　　　　　System.out.println("成績為B");
　　　　else if (grade @textgreater[]= 70)
　　　　　　System.out.println("成績為C");
　　　　else if (grade @textgreater[]= 60)
　　　　　　System.out.println("成績為D");
           else
　　　　　　System.out.println("成績為E");
　　}
}
\end{Verbatim}

執行結果：

\begin{Verbatim}[commandchars=@\[\]]
請輸入成績:90
成績為A
請輸入成績:89
成績為B
請輸入成績:70
成績為C
請輸入成績:60
成績為D
請輸入成績:59
成績為E
\end{Verbatim}

說明：
\begin{itemize}
\item {} 
第一次輸入的 grade 為 90 ，符合條件判斷 1，輸出 ``成績為A'' (圖形藍色的路徑) 。

\item {} 
第二次輸入的 grade 為 89 ，符合條件判斷 2，輸出 ``成績為B'' (圖形綠色的路徑) 。

\item {} 
第三次輸入的 grade 為 70 ，符合條件判斷 3，輸出 ``成績為C'' (圖形粉紅色的路徑) 。

\item {} 
第四次輸入的 grade 為 60 ，符合條件判斷 4，輸出 ``成績為D'' (圖形淺藍色的路徑) 。

\item {} 
第五次輸入的 grade 為 59 ，都不符合上面的條件判斷，會執行 else 區塊內的程式碼，輸出 ``成績為E'' (圖形紅色的路徑) 。

\item {} 
因為 if 條件判斷、所有 else if 條件判斷或 else 成立時，執行的程式碼都只有一行，所以區塊符號都可以省略不寫。

\end{itemize}


\subsection{switch 與 break}
\label{java_cond:switch-break}

\subsubsection{breake}
\label{java_cond:breake}\begin{itemize}
\item {} 
break：在程式執行時，遇到 break，會跳過目前執行區塊後的程式碼，並跳出目前的區塊。

\end{itemize}


\subsubsection{switch}
\label{java_cond:switch}
當需要對一個 int、short、char、byte 或是 enum 型態值做多種不同的判斷時，可以使用 switch ，以下是 switch 的語法：

{[}{[}Image:Switch-1.png{]}{]}

\begin{Verbatim}[commandchars=@\[\]]
1  switch (變數或運算式) {
2      case 值1:
3          符合值1執行的程式碼;
4          ....
5          break;
6      case 值2:
7          符合值2執行的程式碼;
8          ....
9          break;
10       ：
11       ：
12     case 值n:
13         符合值n執行的程式碼;
14         ....
15         break;
16     default:
17         都不符合上述值執行的程式碼;
18         ....
19 }
\end{Verbatim}

說明：
\begin{itemize}
\item {} 
第 1 行： Switch 後面括號內的程式碼，可以是變數（例如：grade）或是運算式，然而其型態必需是 int、short、char、byte 或是 enum 型態（圖形藍色菱形的部份）。

\item {} 
第 2 、 6 、 12 行：用以判斷 switch 後面括號內的變數或運算式的值是否符合值1（第2行；圖形藍色的路徑）、值2（第6行；圖形綠色的路徑）、值n（第12行；圖形粉紅色的路徑）的條件判斷。值1、值2、值n必須是常數（compile-time constant）。

\item {} 
第 (3\textasciitilde{}4) 、 (7\textasciitilde{}8) 、 (13\textasciitilde{}14) 行：如果符合值1（圖形藍色的路徑）、值2（圖形綠色的路徑）、值n（圖形粉紅色的路徑）時會執行的程式碼。

\item {} 
第 16 行：如果都不符合 case 值1 到 case 值n 的情況下，則會去執行 default 區塊內（第17、18行；圖形紅色的路徑）的程式碼，然後離開整個 swtich 的條件判斷。

\item {} 
第 5 、 9 、 15 行： \textbf{當程式執行遇到 break 敘述，會結束 swtich 的執行} 。

\item {} 
在 Java 語言中， \textbf{switch 條件判斷的 case 的值只能是單一的常數值（compile-time constant），不可以是範圍值（例如：\textgreater{}=90）} 。

\end{itemize}

Example 4：請使用 switch 來設計一個 Java 程式，讓使用者自行輸入一個成績，判斷該輸入的成績是介於哪一個區間之內。

{[}{[}Image:Switch-2.png{]}{]}

\begin{Verbatim}[commandchars=@\[\]]
import java.util.Scanner;
class Switch@_Statement {
　　public static void main(String@PYGZlb[]@PYGZrb[] args) {
　　　　switch@_statement();
　　　　switch@_statement();
           switch@_statement();
　　　　switch@_statement();
　　　　switch@_statement();
           switch@_statement();
　　}

        public static void switch@_statement() {
　　　　System.out.print("請輸入成績:");
　　　　Scanner scanner = new Scanner(System.in);
　　　　int grade = scanner.nextInt();
           grade = (int)grade / 10;

           switch (grade) {
                   case 10:
                   case 9:
                           System.out.println("90@textasciitilde[]100");
                           break;
                   case 8:
                           System.out.println("80@textasciitilde[]89");
                           break;
                   case 7:
                           System.out.println("70@textasciitilde[]100");
                           break;
                   case 6:
                           System.out.println("60@textasciitilde[]69");
                           break;
                   default:
                           System.out.println("0@textasciitilde[]59");
           }
        }
}
\end{Verbatim}

執行結果：

\begin{Verbatim}[commandchars=@\[\]]
請輸入成績:100
90@textasciitilde[]100
請輸入成績:90
90@textasciitilde[]100
請輸入成績:89
80@textasciitilde[]89
請輸入成績:74
70@textasciitilde[]59
請輸入成績:60
60@textasciitilde[]69
請輸入成績:59
0@textasciitilde[]59
\end{Verbatim}

說明：
\begin{itemize}
\item {} 
第一次輸入的 grade 為 100，符合 case 10 的條件判斷，但 case 10 區塊內沒有 break 敘述（圖形藍色的路徑）會繼續往下執行到 case 9 區塊內的程式碼，輸出 ``90\textasciitilde{}100''（圖形綠色的路徑），之後遇到 break 敘述跳離開整個 swtich。

\item {} 
第二次輸入的 grade 為 90，符合 case 9 的條件判斷，會執行 case 9 區塊內的程式碼，輸出 ``90\textasciitilde{}100''（圖形綠色的路徑），之後遇到 break 敘述跳離開整個 swtich 。

\item {} 
第三次輸入的 grade 為 89，符合 case 8 的條件判斷，會執行 case 8 區塊內的程式碼，輸出 ``80\textasciitilde{}89''（圖形粉紅色的路徑），之後遇到 break 敘述跳離開整個 swtich。

\item {} 
第四次輸入的 grade 為 74，符合 case 7 的條件判斷，會執行 case 7 區塊內的程式碼，輸出 ``70\textasciitilde{}79''（圖形淺藍色的路徑），之後遇到 break 敘述跳離開整個 swtich。

\item {} 
第五次輸入的 grade 為 60，符合 case 6 的條件判斷，會執行 case 6 區塊內的程式碼，輸出 ``60\textasciitilde{}69''（圖形橘色的路徑），之後遇到 break 敘述跳離開整個 swtich。

\item {} 
第六次輸入的 grade 為 59，都不符合上面 case 的條件判斷，會執行 default 區塊內的程式碼，輸出 ``0\textasciitilde{}59''（圖形紅色的路徑），之後離開 swtich。

\end{itemize}


\subsection{巢狀條件判斷}
\label{java_cond:id6}
巢狀條件判斷（nested-if）：是指在一個 if 裡面還有 if 。

Example 5：請寫一個判斷使用者輸入的數是否是2或3或6的倍數，或者都不是他們倍數的java程式。

{[}{[}Image:nested\_if.png\textbar{}link={]}{]}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{java.util.Scanner}\PYG{o}{;}
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{Times} \PYG{o}{\PYGZob{}}
        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{n}{Scanner} \PYG{n}{keyboard} \PYG{o}{=} \PYG{k}{new} \PYG{n}{Scanner}\PYG{o}{(}\PYG{n}{System}\PYG{o}{.}\PYG{n+na}{in}\PYG{o}{)}\PYG{o}{;}

        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String}\PYG{o}{[}\PYG{o}{]} \PYG{n}{args}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{n}{times}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{times}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{times}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
                \PYG{n}{times}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
        \PYG{o}{\PYGZcb{}}

        \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{times}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{print}\PYG{o}{(}\PYG{l+s}{"請輸入一個整數："}\PYG{o}{)}\PYG{o}{;}
                \PYG{k+kt}{int} \PYG{n}{num} \PYG{o}{=} \PYG{n}{keyboard}\PYG{o}{.}\PYG{n+na}{nextInt}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}

                \PYG{k}{if} \PYG{o}{(}\PYG{o}{(}\PYG{n}{num} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{2}\PYG{o}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                        \PYG{k}{if} \PYG{o}{(}\PYG{o}{(}\PYG{n}{num} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{3}\PYG{o}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{num} \PYG{o}{+} \PYG{l+s}{"是2、3、6的倍數。"}\PYG{o}{)}\PYG{o}{;}
                        \PYG{o}{\PYGZcb{}}
                        \PYG{k}{else} \PYG{o}{\PYGZob{}}
                                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{num} \PYG{o}{+} \PYG{l+s}{"是2的倍數。"}\PYG{o}{)}\PYG{o}{;}
                        \PYG{o}{\PYGZcb{}}
                \PYG{o}{\PYGZcb{}}
                \PYG{k}{else} \PYG{o}{\PYGZob{}}
                        \PYG{k}{if} \PYG{o}{(}\PYG{o}{(}\PYG{n}{num} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{3}\PYG{o}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{)} \PYG{o}{\PYGZob{}}
                                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{num} \PYG{o}{+} \PYG{l+s}{"是3的倍數。"}\PYG{o}{)}\PYG{o}{;}
                        \PYG{o}{\PYGZcb{}}
                        \PYG{k}{else} \PYG{o}{\PYGZob{}}
                                \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{out}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{n}{num} \PYG{o}{+} \PYG{l+s}{"都不是2、3、6的倍數。"}\PYG{o}{)}\PYG{o}{;}
                        \PYG{o}{\PYGZcb{}}
                \PYG{o}{\PYGZcb{}}
        \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

輸出結果：

\begin{Verbatim}[commandchars=@\[\]]
請輸入一個整數：12
12是2、3、6的倍數。
請輸入一個整數：4
4是2的倍數。
請輸入一個整數：9
9是3的倍數。
請輸入一個整數：11
11都不是2、3、6的倍數。
\end{Verbatim}

說明：
\begin{itemize}
\item {} 
當輸入的 num 為 12 時，第一層（外層）可被 2 整除（執行 if 區塊），再往第二層（內層）可被 3 整除（執行 if 區塊），輸出 ``12是2、3、6的倍數。''（圖形藍色的路徑）。

\item {} 
當輸入的 num 為 4 時，第一層（外層）可被 2 整除（執行 if 區塊），再往第二層（內層）不可被 3 整除（執行 else 區塊），輸出 ``4是2的倍數。''（圖形粉紅色的路徑）。

\item {} 
當輸入的 num 為 9 時，第一層（外層）不可被 2 整除（執行 else 區塊），再往第二層（內層）可被 3 整除（執行 if 區塊內），輸出 ``9是3的倍數。''（圖形綠色的路徑）。

\item {} 
當輸入的 num 為 11 時，第一層（外層）不可被 2 整除（執行 else 區塊），再往第二層（內層）不可被 3 整除（執行 else 區塊），輸出 ``11都不是2、3、6的倍數。''（圖形紅色的路徑）。

\end{itemize}


\subsection{? : 條件判斷式}
\label{java_cond:id7}
條件判斷 ? 條件判斷成立時執行的程式碼 : 條件判斷不成立時執行的程式碼 ;

if 與 ? : 的差別在於 if 不傳回值；而 ? : 可以傳回值（見以下範例）

Example 6：請設計一個 Java 程式，可以判斷成績是否及格。

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{o}{(}\PYG{n}{grade} \PYG{o}{\textgreater{}}\PYG{o}{=} \PYG{l+m+mi}{60}\PYG{o}{)}
        \PYG{n}{message} \PYG{o}{=} \PYG{l+s}{"成績及格!"}\PYG{o}{;}
\PYG{k}{else}
        \PYG{n}{message} \PYG{o}{=} \PYG{l+s}{"成績不及格!"}\PYG{o}{;}
\end{Verbatim}

上面 Example 6 可以改寫成下面只有一行的 ? : 條件判斷式。

\begin{Verbatim}[commandchars=@\[\]]
message = (grade @textgreater[]=60) ? "成績及格!" : "成績不及格!";

message 的值是上例執行 ? : 運算式之後傳回的結果。
\end{Verbatim}



\renewcommand{\indexname}{Index}
\printindex
\end{document}
