算術運算式
=========

使用算術運算式要注意的是運算的優先次序。
例如：先乘除、後加減。如果不記得運算的優先次序，那麼最簡便的方法是使用（）也就是指定內層的刮號先執行。
以下是算術運算式的幾個範例：

.. code-block:: java
	2 + 3         // 傳回 5
	4 - 1         // 傳回 3
	(4 + 5) * -3  // 傳回 -27
	x * y         // 傳回 x 的值與 y 的值相乘的結果
	y / z         // 傳回 y 的值與 z 的值相除的結果
	7 % 4         // 傳回兩數相除的餘數 3

使用算術運算式另一項要注意的是型態的轉換，也就是在一個算術式中同時有整數與浮點數時，
Java 會將整數先轉換成浮點數然後再進行運算。

例如：

.. code-block:: java

	int i = (3 + 4) /  **3**  // 兩個整數相除，結果仍是整數，小數部分捨棄。傳回 2
	double f;
	f = (3 + 4) /  **3.0**    // 7 轉型成浮點數，然後與浮點數 3.0 相除。傳回 2.333...
	System.out.println(i);
	System.out.println(f);

印出：::

	2
	2.3333333333333335

如果需要指定轉換的型態，則可以使用以下的方式：

.. code-block:: java
	(double) i    // 得到 i 的 double 的值
	(int) f       // 得到 f 的 int 的值

至於 i、f 的原來的值還是不變。

如同一般的算術運算式，設值運算式（=）也會傳回值。例如：

.. code-block:: java

	x = 3         // 傳回 3
	y = (x = 3)   // 因為 x = 3 傳回3, 所以 y 的值也設成 3

自動將資料範圍較小的型態轉為資料範圍較大的型態，稱為自動轉型 (promotion)。
Java 資料型態範圍之大小次序為：::

	byte < short < int < long < float < double

以下的例子會出現 possible loss of precision 的錯誤：

.. code-block:: java
	short a = 1;
	long b = 2;
	int c = a + b;

這個錯誤是因為a會自動轉型成較大的 long 再跟 b 相加，
但是 int 型態的 c 放不下 long 的資料。
此時就要透過強制轉型(casting)，將 a 轉型成 int：

.. code-block:: java

	int c = (int)(a + b);

當資料型態由小轉為大時，會自動轉型；
當資料型態由大轉為小時，則需強迫轉型。
